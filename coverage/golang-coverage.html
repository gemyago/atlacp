
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>jobs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gemyago/atlacp/cmd/jobs/echo.go (94.1%)</option>
				
				<option value="file1">github.com/gemyago/atlacp/cmd/jobs/main.go (57.1%)</option>
				
				<option value="file2">github.com/gemyago/atlacp/cmd/jobs/root.go (100.0%)</option>
				
				<option value="file3">github.com/gemyago/atlacp/cmd/mcp/http.go (90.6%)</option>
				
				<option value="file4">github.com/gemyago/atlacp/cmd/mcp/main.go (57.1%)</option>
				
				<option value="file5">github.com/gemyago/atlacp/cmd/mcp/root.go (100.0%)</option>
				
				<option value="file6">github.com/gemyago/atlacp/cmd/mcp/stdio.go (90.6%)</option>
				
				<option value="file7">github.com/gemyago/atlacp/cmd/server/main.go (57.1%)</option>
				
				<option value="file8">github.com/gemyago/atlacp/cmd/server/root.go (100.0%)</option>
				
				<option value="file9">github.com/gemyago/atlacp/cmd/server/start.go (91.7%)</option>
				
				<option value="file10">github.com/gemyago/atlacp/internal/api/http/middleware/chain.go (100.0%)</option>
				
				<option value="file11">github.com/gemyago/atlacp/internal/api/http/middleware/recover.go (100.0%)</option>
				
				<option value="file12">github.com/gemyago/atlacp/internal/api/http/middleware/tracing.go (100.0%)</option>
				
				<option value="file13">github.com/gemyago/atlacp/internal/api/http/server/register.go (100.0%)</option>
				
				<option value="file14">github.com/gemyago/atlacp/internal/api/http/server/router.go (100.0%)</option>
				
				<option value="file15">github.com/gemyago/atlacp/internal/api/http/server/server.go (92.0%)</option>
				
				<option value="file16">github.com/gemyago/atlacp/internal/api/http/v1controllers/echo.go (100.0%)</option>
				
				<option value="file17">github.com/gemyago/atlacp/internal/api/http/v1controllers/health.go (100.0%)</option>
				
				<option value="file18">github.com/gemyago/atlacp/internal/api/http/v1controllers/register.go (100.0%)</option>
				
				<option value="file19">github.com/gemyago/atlacp/internal/api/http/v1routes.go (100.0%)</option>
				
				<option value="file20">github.com/gemyago/atlacp/internal/api/http/v1routes/handlers/echo_controller.go (100.0%)</option>
				
				<option value="file21">github.com/gemyago/atlacp/internal/api/http/v1routes/handlers/echo_params.go (100.0%)</option>
				
				<option value="file22">github.com/gemyago/atlacp/internal/api/http/v1routes/handlers/handlers.go (30.6%)</option>
				
				<option value="file23">github.com/gemyago/atlacp/internal/api/http/v1routes/handlers/health_controller.go (100.0%)</option>
				
				<option value="file24">github.com/gemyago/atlacp/internal/api/http/v1routes/internal/echo_request_payload_validation.go (100.0%)</option>
				
				<option value="file25">github.com/gemyago/atlacp/internal/api/http/v1routes/internal/echo_response_payload_validation.go (0.0%)</option>
				
				<option value="file26">github.com/gemyago/atlacp/internal/api/http/v1routes/internal/error_validation.go (0.0%)</option>
				
				<option value="file27">github.com/gemyago/atlacp/internal/api/http/v1routes/internal/health_response_payload_validation.go (0.0%)</option>
				
				<option value="file28">github.com/gemyago/atlacp/internal/api/http/v1routes/internal/validators.go (13.3%)</option>
				
				<option value="file29">github.com/gemyago/atlacp/internal/api/http/v1routes/models/health_response_payload.go (0.0%)</option>
				
				<option value="file30">github.com/gemyago/atlacp/internal/api/mcp/controllers/bitbucket.go (91.6%)</option>
				
				<option value="file31">github.com/gemyago/atlacp/internal/api/mcp/controllers/mock_bitbucket_service.go (62.1%)</option>
				
				<option value="file32">github.com/gemyago/atlacp/internal/api/mcp/controllers/register.go (100.0%)</option>
				
				<option value="file33">github.com/gemyago/atlacp/internal/api/mcp/server/server.go (89.3%)</option>
				
				<option value="file34">github.com/gemyago/atlacp/internal/api/mcp/server/testing.go (90.9%)</option>
				
				<option value="file35">github.com/gemyago/atlacp/internal/app/accounts_testing.go (55.0%)</option>
				
				<option value="file36">github.com/gemyago/atlacp/internal/app/auth.go (100.0%)</option>
				
				<option value="file37">github.com/gemyago/atlacp/internal/app/bitbucket.go (98.3%)</option>
				
				<option value="file38">github.com/gemyago/atlacp/internal/app/bitbucket_auth.go (100.0%)</option>
				
				<option value="file39">github.com/gemyago/atlacp/internal/app/echo.go (100.0%)</option>
				
				<option value="file40">github.com/gemyago/atlacp/internal/app/mock_atlassian_accounts_repository.go (65.4%)</option>
				
				<option value="file41">github.com/gemyago/atlacp/internal/app/mock_bitbucket_auth_factory.go (69.6%)</option>
				
				<option value="file42">github.com/gemyago/atlacp/internal/app/mock_bitbucket_client.go (62.1%)</option>
				
				<option value="file43">github.com/gemyago/atlacp/internal/app/models/health_response_payload.go (0.0%)</option>
				
				<option value="file44">github.com/gemyago/atlacp/internal/app/register.go (100.0%)</option>
				
				<option value="file45">github.com/gemyago/atlacp/internal/config/load.go (92.0%)</option>
				
				<option value="file46">github.com/gemyago/atlacp/internal/config/provide.go (100.0%)</option>
				
				<option value="file47">github.com/gemyago/atlacp/internal/di/dig.go (100.0%)</option>
				
				<option value="file48">github.com/gemyago/atlacp/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file49">github.com/gemyago/atlacp/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file50">github.com/gemyago/atlacp/internal/diag/slog.go (96.6%)</option>
				
				<option value="file51">github.com/gemyago/atlacp/internal/diag/testing.go (75.0%)</option>
				
				<option value="file52">github.com/gemyago/atlacp/internal/services/atlassian_accounts.go (92.2%)</option>
				
				<option value="file53">github.com/gemyago/atlacp/internal/services/bitbucket/approve_pr.go (100.0%)</option>
				
				<option value="file54">github.com/gemyago/atlacp/internal/services/bitbucket/client.go (100.0%)</option>
				
				<option value="file55">github.com/gemyago/atlacp/internal/services/bitbucket/create_pr.go (100.0%)</option>
				
				<option value="file56">github.com/gemyago/atlacp/internal/services/bitbucket/create_task.go (100.0%)</option>
				
				<option value="file57">github.com/gemyago/atlacp/internal/services/bitbucket/get_pr.go (100.0%)</option>
				
				<option value="file58">github.com/gemyago/atlacp/internal/services/bitbucket/get_task.go (100.0%)</option>
				
				<option value="file59">github.com/gemyago/atlacp/internal/services/bitbucket/list_tasks.go (100.0%)</option>
				
				<option value="file60">github.com/gemyago/atlacp/internal/services/bitbucket/merge_pr.go (100.0%)</option>
				
				<option value="file61">github.com/gemyago/atlacp/internal/services/bitbucket/testing.go (48.6%)</option>
				
				<option value="file62">github.com/gemyago/atlacp/internal/services/bitbucket/update_pr.go (100.0%)</option>
				
				<option value="file63">github.com/gemyago/atlacp/internal/services/bitbucket/update_task.go (100.0%)</option>
				
				<option value="file64">github.com/gemyago/atlacp/internal/services/http/client_factory.go (100.0%)</option>
				
				<option value="file65">github.com/gemyago/atlacp/internal/services/http/middleware/auth.go (100.0%)</option>
				
				<option value="file66">github.com/gemyago/atlacp/internal/services/http/middleware/error_handling.go (100.0%)</option>
				
				<option value="file67">github.com/gemyago/atlacp/internal/services/http/middleware/logging.go (100.0%)</option>
				
				<option value="file68">github.com/gemyago/atlacp/internal/services/http/send_request.go (94.1%)</option>
				
				<option value="file69">github.com/gemyago/atlacp/internal/services/jira/client.go (100.0%)</option>
				
				<option value="file70">github.com/gemyago/atlacp/internal/services/jira/get_ticket.go (96.2%)</option>
				
				<option value="file71">github.com/gemyago/atlacp/internal/services/jira/manage_labels.go (100.0%)</option>
				
				<option value="file72">github.com/gemyago/atlacp/internal/services/jira/transition_ticket.go (100.0%)</option>
				
				<option value="file73">github.com/gemyago/atlacp/internal/services/register.go (100.0%)</option>
				
				<option value="file74">github.com/gemyago/atlacp/internal/services/shutdown.go (95.8%)</option>
				
				<option value="file75">github.com/gemyago/atlacp/internal/services/testing.go (12.5%)</option>
				
				<option value="file76">github.com/gemyago/atlacp/internal/services/time.go (100.0%)</option>
				
				<option value="file77">github.com/gemyago/atlacp/internal/testing/mocks/mocks.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/api/http"
        "github.com/gemyago/atlacp/internal/api/http/server"
        "github.com/gemyago/atlacp/internal/app"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

// This is an example of minimalistic job. In real world it would do something more useful.

type echoJobParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        *app.EchoService

        noop bool
}

func runEchoJob(ctx context.Context, params echoJobParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        echoService := params.EchoService
        res, err := echoService.SendEcho(ctx, &amp;app.EchoData{Message: "Hello, World!"})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send echo: %w", err)
        }</span>
        <span class="cov1" title="1">rootLogger.InfoContext(ctx, "Echo succeeded", slog.String("response", res.Message))
        return nil</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "echo",
                Short: "Command run echo job",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Run in noop mode. Useful for testing if setup is all working.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        server.Register(container),
                        http.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params echoJobParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return runEchoJob(cmd.Context(), params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/config"
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "jobs",
                Short: "Command to run jobs",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlag("jsonLogs", cmd.PersistentFlags().Lookup("json-logs")))
        lo.Must0(cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")))
        lo.Must0(cfg.BindPFlag("env", cmd.PersistentFlags().Lookup("env")))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        mcpserver "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startHTTPServerParams struct {
        dig.In `ignore-unexported:"true"`

        noop bool

        RootLogger *slog.Logger

        MCPServer *mcpserver.MCPServer

        *services.ShutdownHooks
}

func startHTTPServer(rootCtx context.Context, params startHTTPServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.MCPServer.NewStreamableHTTPServer()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newHTTPCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        noop := false
        cmd := &amp;cobra.Command{
                Use:   "http",
                Short: "Start MCP server with HTTP transport",
                Long:  "Start MCP server using HTTP transport for web-based MCP clients",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                        return container.Invoke(func(p startHTTPServerParams) error </span><span class="cov1" title="1">{
                                p.noop = noop
                                return startHTTPServer(cmd.Context(), p)
                        }</span>)
                },
        }
        <span class="cov10" title="6">cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Run in noop mode. Useful for testing if setup is all working.",
        )

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="6">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStdioCmd(container),
                newHTTPCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/api/mcp/controllers"
        "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/config"
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "mcp",
                Short: "MCP (Model Context Protocol) server command",
                Long:  "Start MCP server with stdio or HTTP transport for providing tools to MCP clients",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentFlags().StringP(
                "atlassian-accounts-file",
                "a",
                "",
                "Path to the Atlassian accounts file.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlag("atlassian.accountsFilePath", cmd.PersistentFlags().Lookup("atlassian-accounts-file")))
        lo.Must0(cfg.BindPFlag("jsonLogs", cmd.PersistentFlags().Lookup("json-logs")))
        lo.Must0(cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")))
        lo.Must0(cfg.BindPFlag("env", cmd.PersistentFlags().Lookup("env")))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="6">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov4" title="2">{
                        return err
                }</span>

                <span class="cov7" title="4">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov4" title="2">{
                        return err
                }</span>

                <span class="cov4" title="2">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        // mcp components
                        controllers.Register(container),
                        di.ProvideAll(container,
                                server.NewMCPServer,
                        ),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="6">return cmd</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os"
        "os/signal"
        "time"

        mcpserver "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type stdioServerParams struct {
        dig.In `ignore-unexported:"true"`

        noop bool

        RootLogger *slog.Logger

        MCPServer *mcpserver.MCPServer

        *services.ShutdownHooks
}

func startStdioServer(rootCtx context.Context, params stdioServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting stdio server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- params.MCPServer.ListenStdioServer(signalCtx, os.Stdin, os.Stdout)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStdioCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        cmd := &amp;cobra.Command{
                Use:   "stdio",
                Short: "Start MCP server with stdio transport",
                Long:  "Start MCP server using stdio transport for communication with MCP clients",
        }

        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Run in noop mode. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(p stdioServerParams) error </span><span class="cov1" title="1">{
                        p.noop = noop
                        return startStdioServer(cmd.Context(), p)
                }</span>)
        }

        <span class="cov10" title="6">return cmd</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="3">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStartServerCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/config"
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "server",
                Short: "Command to start the server",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlag("jsonLogs", cmd.PersistentFlags().Lookup("json-logs")))
        lo.Must0(cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")))
        lo.Must0(cfg.BindPFlag("env", cmd.PersistentFlags().Lookup("env")))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="3">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov6" title="2">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov1" title="1">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os/signal"
        "time"

        "github.com/gemyago/atlacp/internal/api/http"
        "github.com/gemyago/atlacp/internal/api/http/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startServerParams struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        HTTPServer *server.HTTPServer

        *services.ShutdownHooks

        noop bool
}

func startServer(params startServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.HTTPServer
        rootCtx := context.Background()

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStartServerCmd(container *dig.Container) *cobra.Command <span class="cov10" title="3">{
        cmd := &amp;cobra.Command{
                Use:   "start",
                Short: "Command to start server",
        }
        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Do not start. Just setup deps and exit. Useful for testing if setup is all working.",
        )
        cmd.PreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return errors.Join(
                        server.Register(container),
                        http.Register(container),
                )
        }</span>
        <span class="cov10" title="3">cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(params startServerParams) error </span><span class="cov1" title="1">{
                        params.noop = noop
                        return startServer(params)
                }</span>)
        }
        <span class="cov10" title="3">return cmd</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import "net/http"

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) func(http.Handler) http.Handler <span class="cov6" title="6">{
        return func(h http.Handler) http.Handler </span><span class="cov6" title="6">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov10" title="18">{
                        h = middlewares[i](h)
                }</span>
                <span class="cov6" title="6">return h</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "errors"
        "log/slog"
        "net/http"
        "runtime/debug"
)

// NewRecovererMiddleware creates a middleware that will handle panics
// log them and respond with 500 to client. This should be the last in a chain.
func NewRecovererMiddleware(rootLogger *slog.Logger) Middleware <span class="cov10" title="8">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="8">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if rvr := recover(); rvr != nil </span><span class="cov4" title="2">{
                                        if err, ok := rvr.(error); ok &amp;&amp; errors.Is(err, http.ErrAbortHandler) </span><span class="cov1" title="1">{
                                                rootLogger.InfoContext(r.Context(), "Request aborted")
                                                return
                                        }</span>
                                        <span class="cov1" title="1">rootLogger.ErrorContext(
                                                r.Context(),
                                                "Unhandled panic",
                                                slog.Any("panic", rvr),
                                                slog.String("stack", string(debug.Stack())),
                                        )
                                        // TODO: Do not write header if already written
                                        w.WriteHeader(http.StatusInternalServerError)</span>
                                }
                        }()

                        <span class="cov7" title="4">next.ServeHTTP(w, r)</span>
                }

                <span class="cov10" title="8">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gofrs/uuid/v5"
)

type TracingMiddlewareCfg struct {
        generateUUID func() string
}

func NewTracingMiddlewareCfg() *TracingMiddlewareCfg <span class="cov10" title="7">{
        return &amp;TracingMiddlewareCfg{
                generateUUID: func() string </span><span class="cov4" title="2">{
                        return uuid.Must(uuid.NewV4()).String()
                }</span>,
        }
}

func NewTracingMiddleware(cfg *TracingMiddlewareCfg) Middleware <span class="cov10" title="7">{
        generateUUID := cfg.generateUUID
        return func(next http.Handler) http.Handler </span><span class="cov10" title="7">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="3">{
                        correlationID := req.Header.Get("x-correlation-id")
                        if correlationID == "" </span><span class="cov4" title="2">{
                                correlationID = generateUUID()
                        }</span>
                        <span class="cov6" title="3">logAttributes := diag.GetLogAttributesFromContext(req.Context())
                        logAttributes.CorrelationID = slog.StringValue(correlationID)
                        nextCtx := diag.SetLogAttributesToContext(req.Context(), logAttributes)
                        next.ServeHTTP(w, req.WithContext(nextCtx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package server

import (
        "github.com/gemyago/atlacp/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(
                container,
                NewHTTPServer,
        )
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package server

import "net/http"

type HTTPRouter http.ServeMux

func (*HTTPRouter) PathValue(r *http.Request, paramName string) string <span class="cov1" title="1">{
        return r.PathValue(paramName)
}</span>

func (router *HTTPRouter) HandleRoute(method, pathPattern string, h http.Handler) <span class="cov10" title="5">{
        (*http.ServeMux)(router).Handle(method+" "+pathPattern, h)
}</span>

func (router *HTTPRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov7" title="3">{
        (*http.ServeMux)(router).ServeHTTP(w, r)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/gemyago/atlacp/internal/api/http/middleware"
        "github.com/gemyago/atlacp/internal/services"
        sloghttp "github.com/samber/slog-http"
        "go.uber.org/dig"
)

type HTTPServerDeps struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        // config
        Host              string        `name:"config.httpServer.host"`
        Port              int           `name:"config.httpServer.port"`
        IdleTimeout       time.Duration `name:"config.httpServer.idleTimeout"`
        ReadHeaderTimeout time.Duration `name:"config.httpServer.readHeaderTimeout"`
        ReadTimeout       time.Duration `name:"config.httpServer.readTimeout"`
        WriteTimeout      time.Duration `name:"config.httpServer.writeTimeout"`
        AccessLogsLevel   string        `name:"config.httpServer.accessLogsLevel"`

        // handler
        Handler http.Handler

        // services
        *services.ShutdownHooks

        // listeningSignal is an optional channel that Start will close when the server is listening.
        // Primarily for testing.
        listeningSignal chan&lt;- struct{}
}

type HTTPServer struct {
        httpSrv *http.Server
        deps    HTTPServerDeps
        logger  *slog.Logger
}

func (srv *HTTPServer) Start(ctx context.Context) error <span class="cov1" title="1">{
        listener, err := net.Listen("tcp", srv.httpSrv.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", srv.httpSrv.Addr, err)
        }</span>

        <span class="cov1" title="1">actualAddr := listener.Addr().String()
        srv.logger.InfoContext(ctx, "Started http listener",
                slog.String("addr", actualAddr),
                slog.String("idleTimeout", srv.deps.IdleTimeout.String()),
                slog.String("readHeaderTimeout", srv.deps.ReadHeaderTimeout.String()),
                slog.String("readTimeout", srv.deps.ReadTimeout.String()),
                slog.String("writeTimeout", srv.deps.WriteTimeout.String()),
                slog.String("accessLogsLevel", srv.deps.AccessLogsLevel),
        )

        if srv.deps.listeningSignal != nil </span><span class="cov1" title="1">{
                close(srv.deps.listeningSignal)
        }</span>

        // http.Serve always returns a non-nil error.
        // It returns http.ErrServerClosed when Shutdown or Close is called.
        <span class="cov1" title="1">err = srv.httpSrv.Serve(listener)
        if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("http server Serve error: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func buildMiddlewareChain(deps HTTPServerDeps) http.Handler <span class="cov10" title="6">{
        defaultLogLevel := slog.LevelInfo
        clientErrorLevel := slog.LevelWarn
        serverErrorLevel := slog.LevelError

        if deps.AccessLogsLevel != "" </span><span class="cov4" title="2">{
                if err := defaultLogLevel.UnmarshalText([]byte(deps.AccessLogsLevel)); err != nil </span><span class="cov1" title="1">{
                        panic(fmt.Errorf("failed to unmarshal access logs level: %w", err))</span>
                }
                <span class="cov1" title="1">clientErrorLevel = defaultLogLevel
                serverErrorLevel = defaultLogLevel</span>
        }

        // Router wire-up
        <span class="cov9" title="5">chain := middleware.Chain(
                middleware.NewTracingMiddleware(middleware.NewTracingMiddlewareCfg()),
                sloghttp.NewWithConfig(deps.RootLogger, sloghttp.Config{
                        DefaultLevel:     defaultLogLevel,
                        ClientErrorLevel: clientErrorLevel,
                        ServerErrorLevel: serverErrorLevel,

                        WithUserAgent:      true,
                        WithRequestID:      false, // We handle it ourselves (tracing middleware)
                        WithRequestHeader:  true,
                        WithResponseHeader: true,
                        WithSpanID:         true,
                        WithTraceID:        true,
                }),
                middleware.NewRecovererMiddleware(deps.RootLogger),
        )
        return chain(deps.Handler)</span>
}

// NewHTTPServer constructor factory for general use *http.Server.
func NewHTTPServer(deps HTTPServerDeps) *HTTPServer <span class="cov6" title="3">{
        address := fmt.Sprintf("%s:%d", deps.Host, deps.Port)
        srv := &amp;http.Server{
                Addr:              address,
                IdleTimeout:       deps.IdleTimeout,
                ReadHeaderTimeout: deps.ReadHeaderTimeout,
                ReadTimeout:       deps.ReadTimeout,
                WriteTimeout:      deps.WriteTimeout,
                Handler:           buildMiddlewareChain(deps),
                ErrorLog:          slog.NewLogLogger(deps.RootLogger.Handler(), slog.LevelError),
        }

        deps.ShutdownHooks.Register("http-server", srv.Shutdown)

        return &amp;HTTPServer{
                deps:    deps,
                httpSrv: srv,
                logger:  deps.RootLogger.WithGroup("http-server"),
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package v1controllers

import (
        "context"
        "net/http"

        "github.com/gemyago/atlacp/internal/api/http/v1routes/handlers"
        "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
        "github.com/gemyago/atlacp/internal/app"
)

type EchoController struct {
        *app.EchoService
}

type sendEchoTransformer struct{}

func (sendEchoTransformer) TransformRequest(
        _ *http.Request,
        echoReq *handlers.EchoSendEchoRequest,
) (*app.EchoData, error) <span class="cov1" title="1">{
        return (*app.EchoData)(echoReq.Payload), nil
}</span>

func (sendEchoTransformer) TransformResponse(
        _ context.Context,
        echoRes *app.EchoData,
) (*models.EchoResponsePayload, error) <span class="cov1" title="1">{
        return (*models.EchoResponsePayload)(echoRes), nil
}</span>

func (c EchoController) SendEcho(b handlers.HandlerBuilder[
        *handlers.EchoSendEchoRequest,
        *models.EchoResponsePayload,
]) http.Handler <span class="cov10" title="2">{
        return b.HandleWith(
                handlers.TransformAction(c.EchoService.SendEcho, sendEchoTransformer{}),
        )
}</span>

var _ handlers.EchoController = (*EchoController)(nil)

func newEchoController(echoService *app.EchoService) *EchoController <span class="cov1" title="1">{
        return &amp;EchoController{EchoService: echoService}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package v1controllers

import (
        "context"
        "net/http"

        "github.com/gemyago/atlacp/internal/api/http/v1routes/handlers"
        "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

type HealthController struct{}

func (HealthController) HealthCheck(
        b handlers.NoParamsHandlerBuilder[*models.HealthResponsePayload],
) http.Handler <span class="cov10" title="2">{
        return b.HandleWith(func(_ context.Context) (*models.HealthResponsePayload, error) </span><span class="cov1" title="1">{
                return &amp;models.HealthResponsePayload{
                        Status: models.HealthResponsePayloadStatusOK,
                }, nil
        }</span>)
}

var _ handlers.HealthController = (*HealthController)(nil)
</pre>
		
		<pre class="file" id="file18" style="display: none">package v1controllers

import (
        "github.com/gemyago/atlacp/internal/di"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                newEchoController,
                di.ProvideValue(&amp;HealthController{}),
        )
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package http

import (
        "errors"
        "log/slog"
        "net/http"

        "github.com/gemyago/atlacp/internal/api/http/server"
        "github.com/gemyago/atlacp/internal/api/http/v1controllers"
        "github.com/gemyago/atlacp/internal/api/http/v1routes/handlers"
        "github.com/gemyago/atlacp/internal/di"
        "go.uber.org/dig"
)

// Use apigen to generate v1routes
//go:generate go run github.com/gemyago/apigen ./v1routes.yaml ./v1routes

type V1RoutesDeps struct {
        dig.In

        RootLogger *slog.Logger

        *v1controllers.HealthController
        *v1controllers.EchoController
}

func NewRootHandler(deps V1RoutesDeps) http.Handler <span class="cov1" title="1">{ // coverage-ignore // Little value in testing wireup code.
        logger := deps.RootLogger.WithGroup("http")

        rootHandler := handlers.NewRootHandler(
                (*server.HTTPRouter)(http.NewServeMux()),
                handlers.WithLogger(logger),
        )
        rootHandler.RegisterHealthRoutes(deps.HealthController)
        rootHandler.RegisterEchoRoutes(deps.EchoController)

        return rootHandler
}</span>

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return errors.Join(
                v1controllers.Register(container),
                di.ProvideAll(container,
                        NewRootHandler,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = http.MethodGet
var _ = time.Time{}
var _ = json.Unmarshal
var _ = fmt.Sprint
type _ func() EchoRequestPayload

// EchoSendEchoRequest represents params for sendEcho operation
//
// Request: POST /echo.
type EchoSendEchoRequest struct {
        // Payload is parsed from request body and declared as payload.
        Payload *EchoRequestPayload
}

type echoControllerBuilder struct {
        // POST /echo
        //
        // Request type: EchoSendEchoRequest,
        //
        // Response type: EchoResponsePayload
        SendEcho genericHandlerBuilder[
                *EchoSendEchoRequest,
                *EchoResponsePayload,
                handlerActionFunc[*EchoSendEchoRequest, *EchoResponsePayload],
                httpHandlerActionFunc[*EchoSendEchoRequest, *EchoResponsePayload],
        ]
}

func newEchoControllerBuilder(app *RootHandler) *echoControllerBuilder <span class="cov10" title="2">{
        return &amp;echoControllerBuilder{
                // POST /echo
                SendEcho: newGenericHandlerBuilder(
                        app,
                        newHandlerAdapter[
                                *EchoSendEchoRequest,
                                *EchoResponsePayload,
                        ](),
                        newHTTPHandlerAdapter[
                                *EchoSendEchoRequest,
                                *EchoResponsePayload,
                        ](),
                        makeActionBuilderParams[
                                *EchoSendEchoRequest,
                                *EchoResponsePayload,
                        ]{
                                defaultStatus: 200,
                                paramsParser:  newParamsParserEchoSendEcho(app),
                        },
                ),
        }
}</span>

type EchoController interface {
        // POST /echo
        //
        // Request type: EchoSendEchoRequest,
        //
        // Response type: EchoResponsePayload
        SendEcho(HandlerBuilder[
                *EchoSendEchoRequest,
                *EchoResponsePayload,
        ]) http.Handler
}

// RegisterEchoRoutes will attach the following routes to the root handler:
// 
// - POST /echo
// 
// Routes will use provided controller to handle requests.
func(rootHandler *RootHandler) RegisterEchoRoutes(controller EchoController) *RootHandler <span class="cov10" title="2">{
        builder := newEchoControllerBuilder(rootHandler)
        rootHandler.router.HandleRoute("POST", "/echo", controller.SendEcho(builder.SendEcho))
        return rootHandler
}</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "net/http"
        "time"

        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
        . "github.com/gemyago/atlacp/internal/api/http/v1routes/internal"
)

// Below is to workaround unused imports if that happens.
var _ = BindingContext{}
var _ = http.MethodGet
var _ = time.Time{}
type _ func() EchoRequestPayload

type paramsParserEchoSendEcho struct {
        bindPayload requestParamBinder[*http.Request, *EchoRequestPayload]
}

func (p *paramsParserEchoSendEcho) parse(router httpRouter, req *http.Request) (*EchoSendEchoRequest, error) <span class="cov1" title="1">{
        bindingCtx := BindingContext{}
        reqParams := &amp;EchoSendEchoRequest{}
        // body params
        p.bindPayload(bindingCtx.Fork("body"), readRequestBodyValue(req), &amp;reqParams.Payload)
        return reqParams, bindingCtx.AggregatedError()
}</span>

func newParamsParserEchoSendEcho(rootHandler *RootHandler) paramsParser[*EchoSendEchoRequest] <span class="cov10" title="2">{
        return &amp;paramsParserEchoSendEcho{
                bindPayload: newRequestParamBinder(binderParams[*http.Request, *EchoRequestPayload]{
                        required: true,
                        parseValue: parseSoloValueParamAsSoloValue(
                                parseJSONPayload[*EchoRequestPayload],
                        ),
                        validateValue: NewEchoRequestPayloadValidator(),
                }),
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/gemyago/atlacp/internal/api/http/v1routes/internal"
        "golang.org/x/exp/constraints"
)

type trackedResponseWriter interface {
        // HeaderWritten returns true if headers were written.
        HeaderWritten() bool

        // BodyWritten returns true if body was written.
        BodyWritten() bool
}

type httpRouter interface {
        // PathValue returns a named path parameter of a given name
        PathValue(r *http.Request, paramName string) string

        // HandleRoute register a given handler function to handle given route
        HandleRoute(method, pathPattern string, h http.Handler)

        // ServeHTTP is a standard http.Handler method
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type errorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)

// slogLogger is a fully compatible with slog and used to allow injecting the instance.
type slogLogger interface {
        Log(ctx context.Context, level slog.Level, msg string, args ...any)
        LogAttrs(ctx context.Context, level slog.Level, msg string, attrs ...slog.Attr)
}

// RootHandler is a central point of the generated HTTP server. It is responsible for
// registering routes and customizing router behavior.
// The RootHandler implements http.Handler interface and can be used as a standard
// http.Handler in any context that expects it.
type RootHandler struct {
        router               httpRouter
        handleParsingErrors  errorHandlerFunc
        handleActionErrors   errorHandlerFunc
        handleResponseErrors errorHandlerFunc
        knownParsers         *knownParsersDef
        logger               slogLogger
}

type RootHandlerOpt func(*RootHandler)

// WithLogger allows to set custom logger for the root handler.
// The default logger is slog.Default().
func WithLogger(logger slogLogger) RootHandlerOpt <span class="cov1" title="1">{
        return func(r *RootHandler) </span><span class="cov1" title="1">{
                r.logger = logger
        }</span>
}

// WithParsingErrorHandler allows to set custom handler for parsing errors.
// Parsing errors are errors that occur during request parsing and validation.
// The default implementation will respond with 400 status code and validation
// errors serialized as JSON. No sensitive information is exposed, just field names.
// The default implementation will also log the error using configured logger.
func WithParsingErrorHandler(handler errorHandlerFunc) RootHandlerOpt <span class="cov0" title="0">{
        return func(h *RootHandler) </span><span class="cov0" title="0">{
                h.handleParsingErrors = handler
        }</span>
}

// WithActionErrorHandler allows to set custom handler for action errors.
// Action errors are errors that occur during controller action execution.
// The default implementation will respond with 500 status code and no output.
// The default implementation will also log the error using configured logger.
func WithActionErrorHandler(handler errorHandlerFunc) RootHandlerOpt <span class="cov0" title="0">{
        return func(h *RootHandler) </span><span class="cov0" title="0">{
                h.handleActionErrors = handler
        }</span>
}

// WithResponseErrorHandler allows to set custom handler for response errors.
// Response errors are errors that occur while writing response.
// The default implementation will attempt to respond with 500 status code and no output.
// The default implementation will also log the error using configured logger.
func WithResponseErrorHandler(handler errorHandlerFunc) RootHandlerOpt <span class="cov0" title="0">{
        return func(h *RootHandler) </span><span class="cov0" title="0">{
                h.handleResponseErrors = handler
        }</span>
}

// NewRootHandler creates a new instance of the root handler.
func NewRootHandler(router httpRouter, opts ...RootHandlerOpt) *RootHandler <span class="cov4" title="3">{
        rootHandler := &amp;RootHandler{
                router:       router,
                logger:       slog.Default(),
                knownParsers: newKnownParsers(),
        }
        rootHandler.handleActionErrors = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                rootHandler.logger.LogAttrs(r.Context(), slog.LevelError, "Failed to process request", slog.Any("error", err))
                if tw, ok := w.(trackedResponseWriter); ok &amp;&amp; !tw.HeaderWritten() </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                }</span>
        }
        <span class="cov4" title="3">rootHandler.handleResponseErrors = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                rootHandler.logger.LogAttrs(r.Context(), slog.LevelError, "Failed to write response", slog.Any("err", err))
                if tw, ok := w.(trackedResponseWriter); ok &amp;&amp; !tw.HeaderWritten() </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                }</span>
        }
        <span class="cov4" title="3">rootHandler.handleParsingErrors = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                w.Header().Add("Content-Type", "application/json; charset=utf-8")
                w.WriteHeader(http.StatusBadRequest)
                rootHandler.logger.LogAttrs(r.Context(), slog.LevelWarn, "Failed to parse request", slog.Any("err", err))
                var aggregatedErr internal.AggregatedBindingError
                if ok := errors.As(err, &amp;aggregatedErr); ok </span><span class="cov0" title="0">{
                        if writeErr := json.NewEncoder(w).Encode(aggregatedErr); writeErr != nil </span><span class="cov0" title="0">{
                                rootHandler.handleResponseErrors(w, r, writeErr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
        <span class="cov4" title="3">for _, opt := range opts </span><span class="cov1" title="1">{
                opt(rootHandler)
        }</span>
        <span class="cov4" title="3">return rootHandler</span>
}

func (rootHandler *RootHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        rootHandler.router.ServeHTTP(w, r)
}</span>

type paramsParser[TReqParams any] interface {
        parse(router httpRouter, req *http.Request) (TReqParams, error)
}

type void *int

type voidParamsParser struct{}

func (p voidParamsParser) parse(_ httpRouter, _ *http.Request) (void, error) <span class="cov1" title="1">{
        return void(nil), nil
}</span>

func makeVoidParamsParser(_ *RootHandler) paramsParser[void] <span class="cov3" title="2">{
        return voidParamsParser{}
}</span>

func readPathValue(key string, router httpRouter, req *http.Request) internal.OptionalVal[string] <span class="cov0" title="0">{
        return internal.OptionalVal[string]{Value: router.PathValue(req, key), Assigned: true}
}</span>

func readQueryValue(key string, values url.Values) internal.OptionalVal[[]string] <span class="cov0" title="0">{
        if values.Has(key) </span><span class="cov0" title="0">{
                return internal.OptionalVal[[]string]{Value: values[key], Assigned: true}
        }</span>
        <span class="cov0" title="0">return internal.OptionalVal[[]string]{}</span>
}

func readRequestBodyValue(req *http.Request) internal.OptionalVal[*http.Request] <span class="cov1" title="1">{
        // We may need a different method to check if the body is empty
        // if content length approach will be causing issues. For this case
        // best would be to read the body to buffer and check its length. It will be fully consumed anyway.
        if req.ContentLength &gt; 0 </span><span class="cov1" title="1">{
                return internal.OptionalVal[*http.Request]{Value: req, Assigned: true}
        }</span>
        <span class="cov0" title="0">return internal.OptionalVal[*http.Request]{}</span>
}

type rawValueParser[TRawVal any, TTargetVal any] func(TRawVal, *TTargetVal) error

func parseJSONPayload[TTargetVal any](req *http.Request, target *TTargetVal) error <span class="cov1" title="1">{
        return json.NewDecoder(req.Body).Decode(target)
}</span>

var _ rawValueParser[*http.Request, string] = parseJSONPayload

func newStringToNumberParser[TTargetVal constraints.Integer | constraints.Float](
        bitSize int, parseFn func(string, int) (TTargetVal, error),
) rawValueParser[string, TTargetVal] <span class="cov10" title="12">{
        return func(ov string, target *TTargetVal) error </span><span class="cov0" title="0">{
                val, err := parseFn(ov, bitSize)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*target = val
                return nil</span>
        }
}

func newStringToDateTimeParser(isDateOnly bool) rawValueParser[string, time.Time] <span class="cov7" title="6">{
        return func(ov string, t *time.Time) error </span><span class="cov0" title="0">{
                format := time.RFC3339Nano
                if isDateOnly </span><span class="cov0" title="0">{
                        format = time.DateOnly
                }</span>
                <span class="cov0" title="0">val, err := time.Parse(format, ov)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*t = val
                return nil</span>
        }
}

func parseDecInt[TInt constraints.Integer](str string, bitSize int) (TInt, error) <span class="cov0" title="0">{
        res, err := strconv.ParseInt(str, 10, bitSize)
        return (TInt)(res), err
}</span>

func parseFloat[TFloat constraints.Float](str string, bitSize int) (TFloat, error) <span class="cov0" title="0">{
        res, err := strconv.ParseFloat(str, bitSize)
        return (TFloat)(res), err
}</span>

func parseMultiValueParamAsSoloValue[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[[]string, TTargetVal] <span class="cov0" title="0">{
        return func(s []string, tv *TTargetVal) error </span><span class="cov0" title="0">{
                return targetParser(s[0], tv)
        }</span>
}

// parseSoloValueParamAsSoloValue is noop and used just to simplify templates.
func parseSoloValueParamAsSoloValue[TRawVal any, TTargetVal any](
        targetParser rawValueParser[TRawVal, TTargetVal],
) rawValueParser[TRawVal, TTargetVal] <span class="cov3" title="2">{
        return targetParser
}</span>

// parseSoloValueParamAsSlice will always parse the input as csv string.
func parseSoloValueParamAsSlice[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[string, []TTargetVal] <span class="cov0" title="0">{
        return func(s string, tv *[]TTargetVal) error </span><span class="cov0" title="0">{
                items := strings.Split(s, ",")
                resultingSlice := make([]TTargetVal, 0, len(items))
                for i, item := range items </span><span class="cov0" title="0">{
                        var val TTargetVal
                        if err := targetParser(item, &amp;val); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse value at index %d: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">resultingSlice = append(resultingSlice, val)</span>
                }
                <span class="cov0" title="0">*tv = resultingSlice
                return nil</span>
        }
}

// parseMultiValueParamAsSlice will parse each value in the input slice separately.
func parseMultiValueParamAsSlice[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[[]string, []TTargetVal] <span class="cov0" title="0">{
        return func(s []string, tv *[]TTargetVal) error </span><span class="cov0" title="0">{
                resultingSlice := make([]TTargetVal, 0, len(s))
                for i, item := range s </span><span class="cov0" title="0">{
                        var val TTargetVal
                        if err := targetParser(item, &amp;val); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to parse value at index %d: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">resultingSlice = append(resultingSlice, val)</span>
                }
                <span class="cov0" title="0">*tv = resultingSlice
                return nil</span>
        }
}

func parseNullableParam[TTargetVal any](
        targetParser rawValueParser[string, TTargetVal],
) rawValueParser[string, *TTargetVal] <span class="cov0" title="0">{
        return func(s string, tv **TTargetVal) error </span><span class="cov0" title="0">{
                if s == "" || s == "null" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">*tv = new(TTargetVal)
                return targetParser(s, *tv)</span>
        }
}

type knownParsersDef struct {
        stringParser  rawValueParser[string, string]
        dateParser    rawValueParser[string, time.Time]
        timeParser    rawValueParser[string, time.Time]
        int32Parser   rawValueParser[string, int32]
        int64Parser   rawValueParser[string, int64]
        float32Parser rawValueParser[string, float32]
        float64Parser rawValueParser[string, float64]
        boolParser    rawValueParser[string, bool]
}

const bitSize32 = 32
const bitSize64 = 64

func newKnownParsers() *knownParsersDef <span class="cov4" title="3">{
        return &amp;knownParsersDef{
                stringParser: func(ov string, s *string) error </span><span class="cov0" title="0">{
                        *s = ov
                        return nil
                }</span>,
                dateParser:    newStringToDateTimeParser(true),
                timeParser:    newStringToDateTimeParser(false),
                int32Parser:   newStringToNumberParser[int32](bitSize32, parseDecInt),
                int64Parser:   newStringToNumberParser[int64](bitSize64, parseDecInt),
                float32Parser: newStringToNumberParser[float32](bitSize32, parseFloat),
                float64Parser: newStringToNumberParser(bitSize64, strconv.ParseFloat),
                boolParser: func(ov string, s *bool) error <span class="cov0" title="0">{
                        switch ov </span>{
                        case "true":<span class="cov0" title="0">
                                *s = true</span>
                        case "false":<span class="cov0" title="0">
                                *s = false</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("unexpected boolean format %v", ov)</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                },
        }
}

type requestParamBinder[TRawVal any, TTargetVal any] func(
        bindingCtx *internal.BindingContext,
        rawVal internal.OptionalVal[TRawVal],
        receiver *TTargetVal,
)

type binderParams[TRawVal any, TTargetVal any] struct {
        required      bool
        parseValue    rawValueParser[TRawVal, TTargetVal]
        validateValue internal.FieldValidator[TTargetVal]
}

func newRequestParamBinder[TRawVal any, TTargetVal any](
        params binderParams[TRawVal, TTargetVal],
) requestParamBinder[TRawVal, TTargetVal] <span class="cov3" title="2">{
        return func(
                bindingCtx *internal.BindingContext,
                rawVal internal.OptionalVal[TRawVal],
                receiver *TTargetVal,
        ) </span><span class="cov1" title="1">{
                if !rawVal.Assigned </span><span class="cov0" title="0">{
                        if params.required </span><span class="cov0" title="0">{
                                bindingCtx.AppendFieldError(internal.FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     internal.ErrValueRequired.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov1" title="1">if err := params.parseValue(rawVal.Value, receiver); err != nil </span><span class="cov0" title="0">{
                        bindingCtx.AppendFieldError(internal.FieldBindingError{
                                Location: bindingCtx.BuildPath(),
                                Code:     internal.ErrBadValueFormat.Error(),
                                Err:      err,
                        })
                        return
                }</span>
                <span class="cov1" title="1">params.validateValue(bindingCtx, *receiver)</span>
        }
}

type universalActionHandlerFunc[
        TReq any,
        TRes any,
] func(http.ResponseWriter, *http.Request, TReq) (TRes, error)

// action handlers without http context exposed.
type handlerActionFunc[TReq any, TRes any] = func(context.Context, TReq) (TRes, error)
type handlerActionFuncNoParams[TReq void, TRes any] = func(context.Context) (TRes, error)
type handlerActionFuncNoResponse[TReq any, TRes void] = func(context.Context, TReq) error
type handlerActionFuncNoParamsNoResponse[TReq void, TRes void] = func(context.Context) error

// action handlers with http context exposed.
type httpHandlerActionFunc[TReq any, TRes any] = func(http.ResponseWriter, *http.Request, TReq) (TRes, error)
type httpHandlerActionFuncNoParams[TReq void, TRes any] = func(http.ResponseWriter, *http.Request) (TRes, error)
type httpHandlerActionFuncNoResponse[TReq any, TRes void] = func(http.ResponseWriter, *http.Request, TReq) error
type httpHandlerActionFuncNoParamsNoResponse[TReq void, TRes void] = func(http.ResponseWriter, *http.Request) error

// handlerActionFuncConstraint represents possible combination of handler action functions.
// Each function can be with or without parameters and with or without response.
// Additionally each function can have access to http objects for possible direct manipulation.
type handlerActionFuncConstraint[TReq any, TRes any] interface {
        handlerActionFunc[TReq, TRes] |
                handlerActionFuncNoParams[void, TRes] |
                handlerActionFuncNoResponse[TReq, void] |
                handlerActionFuncNoParamsNoResponse[void, void] |

                httpHandlerActionFunc[TReq, TRes] |
                httpHandlerActionFuncNoParams[void, TRes] |
                httpHandlerActionFuncNoResponse[TReq, void] |
                httpHandlerActionFuncNoParamsNoResponse[void, void]
}

type handlerRequestTransformer[TReq any, TAppReq any] interface {
        TransformRequest(*http.Request, TReq) (TAppReq, error)
}

type handlerResponseTransformer[TRes any, TAppRes any] interface {
        TransformResponse(context.Context, TAppRes) (TRes, error)
}

type handlerTransformer[TReq any, TRes any, TAppReq any, TAppRes any] interface {
        handlerRequestTransformer[TReq, TAppReq]
        handlerResponseTransformer[TRes, TAppRes]
}

// TransformAction can be used to transform generated action handler to satisfy
// application layer implementation. Use it to reduce boilerplate code in the
// controller layer and keep controller slim and declarative.
//
// Errors produced during request or response transformation will be handled with
// action error handler. You can customize error handling using WithActionErrorHandler option
// when initializing RootHandler with NewRootHandler method.
//
// Please note that the TransformAction is tightly coupled with the generated code
// and should not be used outside of the controller layer.
func TransformAction[
        TReqGenerated any,
        TReqApplication any,
        TResGenerated any,
        TResApplication any,
        TActionGenerated handlerActionFunc[TReqGenerated, TResGenerated],
        TActionApplication handlerActionFunc[TReqApplication, TResApplication],
](
        appAction TActionApplication,
        transformer handlerTransformer[TReqGenerated, TResGenerated, TReqApplication, TResApplication],
) TActionGenerated <span class="cov3" title="2">{
        return func(ctx context.Context, rec TReqGenerated) (TResGenerated, error) </span><span class="cov1" title="1">{
                var emptyRes TResGenerated
                contextualReq, ok := ctx.(contextualRequest)
                if !ok </span><span class="cov0" title="0">{
                        return emptyRes, errors.New("could not obtain http.Request during request params transformation")
                }</span>

                <span class="cov1" title="1">req, err := transformer.TransformRequest(contextualReq.req, rec)
                if err != nil </span><span class="cov0" title="0">{
                        return emptyRes, err
                }</span>
                <span class="cov1" title="1">res, err := appAction(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return emptyRes, err
                }</span>
                <span class="cov1" title="1">return transformer.TransformResponse(ctx, res)</span>
        }
}

// TransformNoParamsAction is a variation of TransformAction for actions without parameters.
// Please see the TransformAction for more details.
func TransformNoParamsAction[
        TResGenerated any,
        TResApplication any,
        TActionGenerated handlerActionFuncNoParams[void, TResGenerated],
        TActionApplication handlerActionFuncNoParams[void, TResApplication],
](
        appAction TActionApplication,
        transformer handlerResponseTransformer[TResGenerated, TResApplication],
) TActionGenerated <span class="cov0" title="0">{
        return func(ctx context.Context) (TResGenerated, error) </span><span class="cov0" title="0">{
                var emptyRes TResGenerated
                res, err := appAction(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return emptyRes, err
                }</span>
                <span class="cov0" title="0">return transformer.TransformResponse(ctx, res)</span>
        }
}

// TransformNoResponseAction is a variation of TransformAction for actions without response body.
// Please see the TransformAction for more details.
func TransformNoResponseAction[
        TReqGenerated any,
        TReqApplication any,
        TActionGenerated handlerActionFuncNoResponse[TReqGenerated, void],
        TActionApplication handlerActionFuncNoResponse[TReqApplication, void],
](
        appAction TActionApplication,
        transformer handlerRequestTransformer[TReqGenerated, TReqApplication],
) TActionGenerated <span class="cov0" title="0">{
        return func(ctx context.Context, rec TReqGenerated) error </span><span class="cov0" title="0">{
                contextualReq, ok := ctx.(contextualRequest)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("could not obtain http.Request during request params transformation")
                }</span>

                <span class="cov0" title="0">req, err := transformer.TransformRequest(contextualReq.req, rec)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return appAction(ctx, req)</span>
        }
}

type genericHandlerBuilder[
        TReq any,
        TRes any,
        TPlainHandler handlerActionFuncConstraint[TReq, TRes],
        THttpHandler handlerActionFuncConstraint[TReq, TRes],
] interface {
        // HandleWith creates a new http.Handler from a given func.
        //
        // The action handler is not supposed to have access to http objects and
        // in most scenarios can just delegate the work to the application logic layer.
        // If you need access to http objects use HandleWithHTTP
        HandleWith(TPlainHandler) http.Handler

        // HandleWithHTTP creates a new http.Handler from a given func.
        //
        // The action handler allows direct access to http.ResponseWriter and *http.Request.
        // It also provides parsed request parameters and allows sending structured response.
        // If you need fully customized behavior, feel free not to use the builder and
        // return the handler directly.
        HandleWithHTTP(THttpHandler) http.Handler
}

type HandlerBuilder[TReq any, TRes any] genericHandlerBuilder[
        TReq,
        TRes,
        handlerActionFunc[TReq, TRes],
        httpHandlerActionFunc[TReq, TRes],
]

type NoParamsHandlerBuilder[TRes any] genericHandlerBuilder[
        void,
        TRes,
        handlerActionFuncNoParams[void, TRes],
        httpHandlerActionFuncNoParams[void, TRes],
]

type NoResponseHandlerBuilder[TReq any] genericHandlerBuilder[
        TReq,
        void,
        handlerActionFuncNoResponse[TReq, void],
        httpHandlerActionFuncNoResponse[TReq, void],
]

type NoParamsNoResponseHandlerBuilder genericHandlerBuilder[
        void,
        void,
        handlerActionFuncNoParamsNoResponse[void, void],
        httpHandlerActionFuncNoParamsNoResponse[void, void],
]

type makeActionBuilderParams[
        TReqParams any,
        TResData any,
] struct {
        defaultStatus int
        voidResult    bool
        paramsParser  paramsParser[TReqParams]
}

type actionBuilderHandlerAdapter[
        TReq any,
        TRes any,
        THandler handlerActionFuncConstraint[TReq, TRes],
] func(THandler) universalActionHandlerFunc[TReq, TRes]

// Allows accessing underlying http.Request in certain scenarios (transformers)
// where just context is available but http.Request is needed.
type contextualRequest struct{ req *http.Request }

func (cr contextualRequest) Deadline() (time.Time, bool) <span class="cov0" title="0">{
        return cr.req.Context().Deadline()
}</span>

func (cr contextualRequest) Done() &lt;-chan struct{} <span class="cov0" title="0">{
        return cr.req.Context().Done()
}</span>

func (cr contextualRequest) Err() error <span class="cov0" title="0">{
        return cr.req.Context().Err()
}</span>

func (cr contextualRequest) Value(key any) any <span class="cov1" title="1">{
        return cr.req.Context().Value(key)
}</span>

var _ context.Context = (*contextualRequest)(nil)

func newHandlerAdapter[
        TReq any,
        TRes any,
        THandler handlerActionFunc[TReq, TRes],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov3" title="2">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov3" title="2">{
                return func(_ http.ResponseWriter, httpReq *http.Request, req TReq) (TRes, error) </span><span class="cov1" title="1">{
                        return t(contextualRequest{req: httpReq}, req)
                }</span>
        }
}

func newHandlerAdapterNoParams[
        TReq any,
        TRes any,
        THandler handlerActionFuncNoParams[void, TRes],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov3" title="2">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov3" title="2">{
                return func(_ http.ResponseWriter, r *http.Request, _ TReq) (TRes, error) </span><span class="cov1" title="1">{
                        return t(r.Context())
                }</span>
        }
}

func newHandlerAdapterNoResponse[
        TReq any,
        TRes any,
        THandler handlerActionFuncNoResponse[TReq, void],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov0" title="0">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(_ http.ResponseWriter, r *http.Request, req TReq) (TRes, error) </span><span class="cov0" title="0">{
                        var emptyRes TRes
                        if err := t(contextualRequest{req: r}, req); err != nil </span><span class="cov0" title="0">{
                                return emptyRes, err
                        }</span>
                        <span class="cov0" title="0">return emptyRes, nil</span>
                }
        }
}

func newHandlerAdapterNoParamsNoResponse[
        TReq any,
        TRes any,
        THandler handlerActionFuncNoParamsNoResponse[void, void],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov0" title="0">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(_ http.ResponseWriter, r *http.Request, _ TReq) (TRes, error) </span><span class="cov0" title="0">{
                        var emptyRes TRes
                        return emptyRes, t(r.Context())
                }</span>
        }
}

func newHTTPHandlerAdapter[
        TReq any,
        TRes any,
        THandler httpHandlerActionFunc[TReq, TRes],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov3" title="2">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request, req TReq) (TRes, error) </span><span class="cov0" title="0">{
                        return t(w, r, req)
                }</span>
        }
}

func newHTTPHandlerAdapterNoParams[
        TReq any,
        TRes any,
        THandler httpHandlerActionFuncNoParams[void, TRes],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov3" title="2">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request, _ TReq) (TRes, error) </span><span class="cov0" title="0">{
                        return t(w, r)
                }</span>
        }
}

func newHTTPHandlerAdapterNoResponse[
        TReq any,
        TRes any,
        THandler httpHandlerActionFuncNoResponse[TReq, void],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov0" title="0">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request, req TReq) (TRes, error) </span><span class="cov0" title="0">{
                        var emptyRes TRes
                        if err := t(w, r, req); err != nil </span><span class="cov0" title="0">{
                                return emptyRes, err
                        }</span>
                        <span class="cov0" title="0">return emptyRes, nil</span>
                }
        }
}

func newHTTPHandlerAdapterNoParamsNoResponse[
        TReq any,
        TRes any,
        THandler httpHandlerActionFuncNoParamsNoResponse[void, void],
]() actionBuilderHandlerAdapter[TReq, TRes, THandler] <span class="cov0" title="0">{
        return func(t THandler) universalActionHandlerFunc[TReq, TRes] </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request, _ TReq) (TRes, error) </span><span class="cov0" title="0">{
                        var emptyRes TRes
                        return emptyRes, t(w, r)
                }</span>
        }
}

type actionsResponseWriter struct {
        targetWriter  http.ResponseWriter
        headerWritten bool
        bodyWritten   bool
        defaultStatus int
}

func (w *actionsResponseWriter) HeaderWritten() bool <span class="cov0" title="0">{
        return w.headerWritten
}</span>

func (w *actionsResponseWriter) BodyWritten() bool <span class="cov3" title="2">{
        return w.bodyWritten
}</span>

func (w *actionsResponseWriter) Header() http.Header <span class="cov0" title="0">{
        return w.targetWriter.Header()
}</span>

func (w *actionsResponseWriter) WriteHeader(statusCode int) <span class="cov3" title="2">{
        w.headerWritten = true
        w.targetWriter.WriteHeader(statusCode)
}</span>

func (w *actionsResponseWriter) Write(data []byte) (int, error) <span class="cov3" title="2">{
        if !w.headerWritten </span><span class="cov3" title="2">{
                w.WriteHeader(w.defaultStatus)
        }</span>
        <span class="cov3" title="2">w.bodyWritten = true
        return w.targetWriter.Write(data)</span>
}

var _ trackedResponseWriter = &amp;actionsResponseWriter{}
var _ http.ResponseWriter = &amp;actionsResponseWriter{}

type genericHandlerBuilderImpl[
        TReq any,
        TRes any,
        TPlainHandler handlerActionFuncConstraint[TReq, TRes],
        THttpHandler handlerActionFuncConstraint[TReq, TRes],
] struct {
        rootHandler        *RootHandler
        handlerAdapter     actionBuilderHandlerAdapter[TReq, TRes, TPlainHandler]
        httpHandlerAdapter actionBuilderHandlerAdapter[TReq, TRes, THttpHandler]
        params             makeActionBuilderParams[TReq, TRes]
}

func (ab genericHandlerBuilderImpl[TReq, TRes, TPlainHandler, THttpHandler]) createHandler(
        handler universalActionHandlerFunc[TReq, TRes],
) http.Handler <span class="cov6" title="4">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov3" title="2">{
                aw := &amp;actionsResponseWriter{
                        targetWriter:  w,
                        defaultStatus: ab.params.defaultStatus,
                }

                reqParams, err := ab.params.paramsParser.parse(ab.rootHandler.router, r)
                if err != nil </span><span class="cov0" title="0">{
                        ab.rootHandler.handleParsingErrors(aw, r, err)
                        return
                }</span>

                <span class="cov3" title="2">resData, err := handler(aw, r, reqParams)
                if err != nil </span><span class="cov0" title="0">{
                        ab.rootHandler.handleActionErrors(aw, r, err)
                        return
                }</span>

                <span class="cov3" title="2">if ab.params.voidResult </span><span class="cov0" title="0">{
                        // Do not write header twice
                        if !aw.HeaderWritten() </span><span class="cov0" title="0">{
                                aw.WriteHeader(ab.params.defaultStatus)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                // This means the action handler has written the response itself.
                <span class="cov3" title="2">if aw.BodyWritten() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov3" title="2">w.Header().Add("Content-Type", "application/json; charset=utf-8")
                // Not sending the status here. The action writer will send it in case of
                // success. If error has happened while encoding, then the error handler will have
                // a chance to set the status.
                if encodingErr := json.NewEncoder(aw).Encode(resData); encodingErr != nil </span><span class="cov0" title="0">{
                        ab.rootHandler.handleResponseErrors(aw, r, encodingErr)
                }</span>
        })
}

func (ab genericHandlerBuilderImpl[TReq, TRes, TPlainHandler, THttpHandler]) HandleWith(
        inputHandler TPlainHandler,
) http.Handler <span class="cov6" title="4">{
        return ab.createHandler(ab.handlerAdapter(inputHandler))
}</span>

func (ab genericHandlerBuilderImpl[TReq, TRes, TPlainHandler, THttpHandler]) HandleWithHTTP(
        handler THttpHandler,
) http.Handler <span class="cov0" title="0">{
        return ab.createHandler(ab.httpHandlerAdapter(handler))
}</span>

func newGenericHandlerBuilder[
        TReq any,
        TRes any,
        TPlainHandler handlerActionFuncConstraint[TReq, TRes],
        THttpHandler handlerActionFuncConstraint[TReq, TRes],
](
        rootHandler *RootHandler,
        handlerAdapter actionBuilderHandlerAdapter[TReq, TRes, TPlainHandler],
        httpHandlerAdapter actionBuilderHandlerAdapter[TReq, TRes, THttpHandler],
        params makeActionBuilderParams[TReq, TRes],
) genericHandlerBuilder[TReq, TRes, TPlainHandler, THttpHandler] <span class="cov6" title="4">{
        return genericHandlerBuilderImpl[TReq, TRes, TPlainHandler, THttpHandler]{
                rootHandler:        rootHandler,
                handlerAdapter:     handlerAdapter,
                httpHandlerAdapter: httpHandlerAdapter,
                params:             params,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by apigen DO NOT EDIT.

package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = http.MethodGet
var _ = time.Time{}
var _ = json.Unmarshal
var _ = fmt.Sprint
type _ func() Error



type healthControllerBuilder struct {
        // GET /health
        //
        // Request type: none
        //
        // Response type: HealthResponsePayload
        HealthCheck genericHandlerBuilder[
                void,
                *HealthResponsePayload,
                handlerActionFuncNoParams[void, *HealthResponsePayload],
                httpHandlerActionFuncNoParams[void, *HealthResponsePayload],
        ]
}

func newHealthControllerBuilder(app *RootHandler) *healthControllerBuilder <span class="cov10" title="2">{
        return &amp;healthControllerBuilder{
                // GET /health
                HealthCheck: newGenericHandlerBuilder(
                        app,
                        newHandlerAdapterNoParams[
                                void,
                                *HealthResponsePayload,
                        ](),
                        newHTTPHandlerAdapterNoParams[
                                void,
                                *HealthResponsePayload,
                        ](),
                        makeActionBuilderParams[
                                void,
                                *HealthResponsePayload,
                        ]{
                                defaultStatus: 200,
                                paramsParser:  makeVoidParamsParser(app),
                        },
                ),
        }
}</span>

type HealthController interface {
        // GET /health
        //
        // Request type: none
        //
        // Response type: HealthResponsePayload
        HealthCheck(NoParamsHandlerBuilder[
                *HealthResponsePayload,
        ]) http.Handler
}

// RegisterHealthRoutes will attach the following routes to the root handler:
// 
// - GET /health
// 
// Routes will use provided controller to handle requests.
func(rootHandler *RootHandler) RegisterHealthRoutes(controller HealthController) *RootHandler <span class="cov10" title="2">{
        builder := newHealthControllerBuilder(rootHandler)
        rootHandler.router.HandleRoute("GET", "/health", controller.HealthCheck(builder.HealthCheck))
        return rootHandler
}</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewEchoRequestPayloadValidator() FieldValidator[*EchoRequestPayload] <span class="cov10" title="2">{
        validateMessage := NewSimpleFieldValidator[string](
                EnsureNonDefault[string],
        )
        
        return func(bindingCtx *BindingContext, value *EchoRequestPayload) </span><span class="cov1" title="1">{
                validateMessage(bindingCtx.Fork("message"), value.Message)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewEchoResponsePayloadValidator() FieldValidator[*EchoResponsePayload] <span class="cov0" title="0">{
        validateMessage := NewSimpleFieldValidator[string](
                EnsureNonDefault[string],
        )
        
        return func(bindingCtx *BindingContext, value *EchoResponsePayload) </span><span class="cov0" title="0">{
                validateMessage(bindingCtx.Fork("message"), value.Message)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewErrorValidator() FieldValidator[*Error] <span class="cov0" title="0">{
        validateCode := NewSimpleFieldValidator[*interface{}](
                SkipNullValidator(EnsureNonDefault[interface{}]),
        )
        validateMessage := NewSimpleFieldValidator[string](
        )
        
        return func(bindingCtx *BindingContext, value *Error) </span><span class="cov0" title="0">{
                validateCode(bindingCtx.Fork("code"), value.Code)
                validateMessage(bindingCtx.Fork("message"), value.Message)
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "time"
        . "github.com/gemyago/atlacp/internal/api/http/v1routes/models"
)

// Below is to workaround unused imports.
var _ = time.Time{}

func NewHealthResponsePayloadValidator() FieldValidator[*HealthResponsePayload] <span class="cov0" title="0">{
        validateStatus := NewSimpleFieldValidator[HealthResponsePayloadStatus](
                EnsureNonDefault[HealthResponsePayloadStatus],
        )
        
        return func(bindingCtx *BindingContext, value *HealthResponsePayload) </span><span class="cov0" title="0">{
                validateStatus(bindingCtx.Fork("status"), value.Status)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by apigen DO NOT EDIT.

package internal

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"

        "golang.org/x/exp/constraints"
)

type BindingError string

const (
        // ErrBadValueFormat error means data provided can not be parsed to a target type.
        ErrBadValueFormat BindingError = "BAD_FORMAT"

        // ErrValueRequired error code indicates that the required value has not been provided.
        ErrValueRequired BindingError = "INVALID_REQUIRED"

        // ErrInvalidValueOutOfRange error code indicates that the value is out of range of allowable values
        // this is usually when number is out of min/max range, or string is outside of limits.
        ErrInvalidValueOutOfRange BindingError = "INVALID_OUT_OF_RANGE"

        // ErrInvalidValue error code a generic validation error.
        ErrInvalidValue BindingError = "INVALID"
)

func (c BindingError) Error() string <span class="cov0" title="0">{
        return string(c)
}</span>

// FieldBindingError occurs at parsing/validation stage and holds
// context on field that the error is related to.
type FieldBindingError struct {
        Location string `json:"location"`
        Err      error  `json:"-"`
        Code     string `json:"code"`
}

func (be FieldBindingError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("field %s code=%s, error: %v", be.Location, be.Code, be.Err)
}</span>

type AggregatedBindingError struct {
        Errors []FieldBindingError `json:"errors"`
}

func (c AggregatedBindingError) Error() string <span class="cov0" title="0">{
        errs := make([]error, len(c.Errors))
        for i, err := range c.Errors </span><span class="cov0" title="0">{
                errs[i] = err
        }</span>
        <span class="cov0" title="0">return errors.Join(errs...).Error()</span>
}

type BindingContext struct {
        parent       *BindingContext
        field        string
        memoizedPath string
        errors       []FieldBindingError
}

func (c *BindingContext) Fork(field string) *BindingContext <span class="cov10" title="2">{
        return &amp;BindingContext{
                parent: c,
                field:  field,
        }
}</span>

func (c *BindingContext) BuildPath() string <span class="cov0" title="0">{
        if c.memoizedPath != "" </span><span class="cov0" title="0">{
                return c.memoizedPath
        }</span>
        <span class="cov0" title="0">if c.parent == nil </span><span class="cov0" title="0">{
                return c.field
        }</span>
        <span class="cov0" title="0">parentPath := c.parent.BuildPath()
        if parentPath == "" </span><span class="cov0" title="0">{
                c.memoizedPath = c.field
        }</span> else<span class="cov0" title="0"> {
                c.memoizedPath = parentPath + "." + c.field
        }</span>
        <span class="cov0" title="0">return c.memoizedPath</span>
}

func (c *BindingContext) AppendFieldError(err FieldBindingError) <span class="cov0" title="0">{
        if c.parent != nil </span><span class="cov0" title="0">{
                c.parent.AppendFieldError(err)
                return
        }</span>
        <span class="cov0" title="0">c.errors = append(c.errors, err)</span>
}

func (c BindingContext) AggregatedError() error <span class="cov1" title="1">{
        if c.parent != nil </span><span class="cov0" title="0">{
                return c.parent.AggregatedError()
        }</span>
        <span class="cov1" title="1">if len(c.errors) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return AggregatedBindingError{Errors: c.errors}</span>
}

type OptionalVal[TVal any] struct {
        Value    TVal
        Assigned bool
}

type ValueValidator[TTargetVal any] func(TTargetVal) error

// EnsureNonDefault will validate if given value is non default for given type.
//
// There is no easy way to make a truly required validation (e.g if field is present)
// without a custom marshaler and shadow models, which will impact performance.
// So keeping a non default validation as a reasonable tradeoff.
func EnsureNonDefault[TTargetVal comparable](val TTargetVal) error <span class="cov1" title="1">{
        var empty TTargetVal
        if val == empty </span><span class="cov0" title="0">{
                return fmt.Errorf("provided value %v is default for given type and considered empty: %w", val, ErrValueRequired)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

var _ = EnsureNonDefault[int]

// EnsureArrayFieldRequired will validate if given array is not empty.
func EnsureArrayFieldRequired[TTargetVal any](val []TTargetVal) error <span class="cov0" title="0">{
        if len(val) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("provided array is empty: %w", ErrValueRequired)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var _ = EnsureArrayFieldRequired[int]

func SkipNullValidator[TTargetVal any](target ValueValidator[TTargetVal]) ValueValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(tv *TTargetVal) error </span><span class="cov0" title="0">{
                if tv == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return target(*tv)</span>
        }
}

func SkipNullFieldValidator[TTargetVal any](target FieldValidator[*TTargetVal]) FieldValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(bindingCtx *BindingContext, value *TTargetVal) </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">target(bindingCtx, value)</span>
        }
}

func NewMinMaxValueValidator[TTargetVal constraints.Ordered](
        threshold TTargetVal,
        exclusive bool,
        isMin bool,
) ValueValidator[TTargetVal] <span class="cov0" title="0">{
        return func(tv TTargetVal) error </span><span class="cov0" title="0">{
                // From OpenAPI spec:
                // exclusiveMinimum: false or not included        value ≥ minimum
                // exclusiveMinimum: true        value &gt; minimum
                // exclusiveMaximum: false or not included        value ≤ maximum
                // exclusiveMaximum: true        value &lt; maximum

                if isMin &amp;&amp; ((exclusive &amp;&amp; tv &lt;= threshold) || (!exclusive &amp;&amp; tv &lt; threshold)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v is less than minimum %v: %w", tv, threshold, ErrInvalidValueOutOfRange)
                }</span>
                <span class="cov0" title="0">if !isMin &amp;&amp; ((exclusive &amp;&amp; tv &gt;= threshold) || (!exclusive &amp;&amp; tv &gt; threshold)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v is greater than maximum %v: %w", tv, threshold, ErrInvalidValueOutOfRange)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

type Measurable[T any] interface {
        ~string | ~[]T
}

func NewMinMaxLengthValidator[TTargetVal any, TValidatorVal Measurable[TTargetVal]](
        threshold int,
        isMin bool,
) ValueValidator[TValidatorVal] <span class="cov0" title="0">{
        return func(tv TValidatorVal) error </span><span class="cov0" title="0">{
                targetLen := len(tv)
                if isMin &amp;&amp; targetLen &lt; threshold </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "value %v has length (%d) less than minimum %v: %w",
                                tv, targetLen, threshold, ErrInvalidValueOutOfRange,
                        )
                }</span>
                <span class="cov0" title="0">if !isMin &amp;&amp; targetLen &gt; threshold </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "value %v has length (%d) more than maximum %v: %w", tv,
                                targetLen, threshold, ErrInvalidValueOutOfRange,
                        )
                }</span>

                <span class="cov0" title="0">return nil</span>
        }
}

func NewPatternValidator[TTargetValue string](patternStr string) ValueValidator[string] <span class="cov0" title="0">{
        pattern := regexp.MustCompile(patternStr)
        return func(v string) error </span><span class="cov0" title="0">{
                if !pattern.MatchString(v) </span><span class="cov0" title="0">{
                        return fmt.Errorf("value %v does not match pattern %v: %w", v, patternStr, ErrInvalidValue)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

type FieldValidator[TValue any] func(
        bindingCtx *BindingContext,
        value TValue,
)

func NewSimpleFieldValidator[
        TValue any,
](validators ...ValueValidator[TValue]) FieldValidator[TValue] <span class="cov10" title="2">{
        return func(
                bindingCtx *BindingContext,
                value TValue,
        ) </span><span class="cov1" title="1">{
                for _, v := range validators </span><span class="cov1" title="1">{
                        if err := v(value); err != nil </span><span class="cov0" title="0">{
                                errCode := ErrInvalidValue
                                errors.As(err, &amp;errCode)
                                bindingCtx.AppendFieldError(FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     errCode.Error(),
                                        Err:      err,
                                })
                                return
                        }</span>
                }
        }
}

type ObjectFieldValidatorParams struct {
        Nullable bool
        Required bool
}

func NewObjectFieldValidator[TTargetVal any](
        params ObjectFieldValidatorParams,
        modelValidator FieldValidator[*TTargetVal],
) FieldValidator[*TTargetVal] <span class="cov0" title="0">{
        return func(bindingCtx *BindingContext, value *TTargetVal) </span><span class="cov0" title="0">{
                if value == nil </span><span class="cov0" title="0">{
                        if params.Required &amp;&amp; !params.Nullable </span><span class="cov0" title="0">{
                                bindingCtx.AppendFieldError(FieldBindingError{
                                        Location: bindingCtx.BuildPath(),
                                        Code:     ErrValueRequired.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">modelValidator(bindingCtx, value)</span>
        }
}

func NewArrayValidator[
        TValue any,
](
        validateField FieldValidator[[]TValue],
        validateItems FieldValidator[TValue],
) FieldValidator[[]TValue] <span class="cov0" title="0">{
        return func(
                bindingCtx *BindingContext,
                value []TValue,
        ) </span><span class="cov0" title="0">{
                validateField(bindingCtx, value)
                for i, v := range value </span><span class="cov0" title="0">{
                        // TODO: Consider fmt.Stringer approach, defer conversion and benchmark if makes noticeable difference.
                        validateItems(bindingCtx.Fork(strconv.Itoa(i)), v)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by apigen DO NOT EDIT.

package models

import (
        "encoding/json"
        "fmt"
        "time"
)

// Unused imports workaround.
var _ = time.Time{}
var _ = json.Unmarshal
var _ = fmt.Sprint
type HealthResponsePayloadStatus string

// List of HealthResponsePayloadStatus values.
const (
        HealthResponsePayloadStatusOK HealthResponsePayloadStatus = "OK"
)

func(v HealthResponsePayloadStatus) IsOK() bool <span class="cov0" title="0">{
  return v == HealthResponsePayloadStatusOK
}</span>

func(v HealthResponsePayloadStatus) String() string <span class="cov0" title="0">{
        return string(v)
}</span>

type assignableHealthResponsePayloadStatus interface {
        IsOK() bool
        String() string
}

func AsHealthResponsePayloadStatus(v assignableHealthResponsePayloadStatus) (HealthResponsePayloadStatus) <span class="cov0" title="0">{
        return HealthResponsePayloadStatus(v.String())
}</span>

func ParseHealthResponsePayloadStatus(str string, target *HealthResponsePayloadStatus) error <span class="cov0" title="0">{
        switch str </span>{
        case "OK":<span class="cov0" title="0">
                *target = HealthResponsePayloadStatusOK</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unexpected HealthResponsePayloadStatus value: %s", str)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *HealthResponsePayloadStatus) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var str string
        if err := json.Unmarshal(data, &amp;str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ParseHealthResponsePayloadStatus(str, v)</span>
}

// All allowed values of HealthResponsePayloadStatus enum.
var AllowableHealthResponsePayloadStatusValues = []HealthResponsePayloadStatus{
        HealthResponsePayloadStatusOK,
}

type HealthResponsePayload struct { 
        Status HealthResponsePayloadStatus `json:"status"`
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strconv"

        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
        "go.uber.org/dig"
)

const (
        // TaskStateResolved represents a "RESOLVED" task state.
        TaskStateResolved = "RESOLVED"

        // TaskStateUnresolved represents an "UNRESOLVED" task state.
        TaskStateUnresolved = "UNRESOLVED"
)

// bitbucketService defines the operations required by the BitbucketController.
// This interface matches the methods from app.BitbucketService that are used by the controller.
type bitbucketService interface {
        CreatePR(ctx context.Context, params app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error)
        ReadPR(ctx context.Context, params app.BitbucketReadPRParams) (*bitbucket.PullRequest, error)
        UpdatePR(ctx context.Context, params app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error)
        ApprovePR(ctx context.Context, params app.BitbucketApprovePRParams) (*bitbucket.Participant, error)
        MergePR(ctx context.Context, params app.BitbucketMergePRParams) (*bitbucket.PullRequest, error)
        ListTasks(ctx context.Context, params app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error)
        UpdateTask(ctx context.Context, params app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)
        CreateTask(ctx context.Context, params app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error)
}

// Ensure that app.BitbucketService implements bitbucketService.
var _ bitbucketService = (*app.BitbucketService)(nil)

// BitbucketControllerDeps contains dependencies for the Bitbucket MCP controller.
type BitbucketControllerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        BitbucketService bitbucketService
}

// BitbucketController provides MCP Bitbucket tool functionality.
type BitbucketController struct {
        logger           *slog.Logger
        bitbucketService bitbucketService
}

// NewBitbucketController creates a new Bitbucket MCP controller.
func NewBitbucketController(deps BitbucketControllerDeps) *BitbucketController <span class="cov10" title="57">{
        return &amp;BitbucketController{
                logger:           deps.RootLogger.WithGroup("mcp.bitbucket-controller"),
                bitbucketService: deps.BitbucketService,
        }
}</span>

// newCreatePRServerTool returns a server tool for creating pull requests.
func (bc *BitbucketController) newCreatePRServerTool() server.ServerTool <span class="cov6" title="12">{
        tool := mcp.NewTool(
                "bitbucket_create_pr",
                mcp.WithDescription("Create a pull request in Bitbucket"),
                mcp.WithString("title",
                        mcp.Description("Pull request title"),
                        mcp.Required(),
                ),
                mcp.WithString("source_branch",
                        mcp.Description("Source branch name"),
                        mcp.Required(),
                ),
                mcp.WithString("target_branch",
                        mcp.Description("Target branch name"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("description",
                        mcp.Description("Pull request description"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
                mcp.WithBoolean("draft",
                        mcp.Description("Create as draft pull request (optional, defaults to false)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="8">{
                bc.logger.Debug("Received bitbucket_create_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                title, err := request.RequireString("title")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid title parameter", err), nil
                }</span>

                <span class="cov5" title="7">sourceBranch, err := request.RequireString("source_branch")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid source_branch parameter", err), nil
                }</span>

                <span class="cov4" title="6">targetBranch, err := request.RequireString("target_branch")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid target_branch parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">description := request.GetString("description", "")
                account := request.GetString("account", "")
                draft := request.GetBool("draft", false)

                // Create parameters for the service layer
                params := app.BitbucketCreatePRParams{
                        Title:        title,
                        SourceBranch: sourceBranch,
                        DestBranch:   targetBranch,
                        Description:  description,
                        AccountName:  account,
                        RepoOwner:    repoOwner,
                        RepoName:     repoName,
                        Draft:        draft,
                }

                // Call the service to create the pull request
                pr, err := bc.bitbucketService.CreatePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create pull request: %w", err)
                }</span>

                <span class="cov2" title="2">return mcp.NewToolResultText(fmt.Sprintf("Created pull request #%d: %s", pr.ID, pr.Title)), nil</span>
        }

        <span class="cov6" title="12">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newReadPRServerTool returns a server tool for reading pull request details.
func (bc *BitbucketController) newReadPRServerTool() server.ServerTool <span class="cov6" title="10">{
        tool := mcp.NewTool(
                "bitbucket_read_pr",
                mcp.WithDescription("Get pull request details from Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="6">{
                bc.logger.Debug("Received bitbucket_read_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketReadPRParams{
                        PullRequestID: prID,
                        AccountName:   account,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                }

                // Call the service to read the pull request
                pr, err := bc.bitbucketService.ReadPR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to read pull request: %w", err)
                }</span>

                // Convert PR to JSON for the resource
                <span class="cov2" title="2">prJSON, err := json.MarshalIndent(pr, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal pull request to JSON: %w", err)
                }</span>

                // Create a summary text for the PR
                <span class="cov2" title="2">summaryText := fmt.Sprintf("Pull request #%d: %s (Status: %s)", pr.ID, pr.Title, pr.State)

                // Return both a summary text and the full PR data as a resource
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },

                                // Sending json as text since some clients (Cursor)
                                // do not support resources (at least not yet)
                                mcp.NewTextContent(string(prJSON)),
                        },
                }, nil</span>
        }

        <span class="cov6" title="10">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newUpdatePRServerTool returns a server tool for updating pull requests.
func (bc *BitbucketController) newUpdatePRServerTool() server.ServerTool <span class="cov6" title="10">{
        tool := mcp.NewTool(
                "bitbucket_update_pr",
                mcp.WithDescription("Update a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("title",
                        mcp.Description("New pull request title"),
                ),
                mcp.WithString("description",
                        mcp.Description("New pull request description"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="6">{
                bc.logger.Debug("Received bitbucket_update_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // At least one of title or description must be provided
                <span class="cov3" title="3">title := request.GetString("title", "")
                description := request.GetString("description", "")

                if title == "" &amp;&amp; description == "" </span><span class="cov1" title="1">{
                        return mcp.NewToolResultError("At least one of title or description must be provided"), nil
                }</span>

                // Optional parameters
                <span class="cov2" title="2">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketUpdatePRParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        Title:         title,
                        Description:   description,
                        AccountName:   account,
                }

                // Call the service to update the pull request
                pr, err := bc.bitbucketService.UpdatePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to update pull request: %w", err)
                }</span>

                <span class="cov1" title="1">return mcp.NewToolResultText(fmt.Sprintf("Updated pull request #%d: %s", pr.ID, pr.Title)), nil</span>
        }

        <span class="cov6" title="10">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newApprovePRServerTool returns a server tool for approving pull requests.
func (bc *BitbucketController) newApprovePRServerTool() server.ServerTool <span class="cov5" title="9">{
        tool := mcp.NewTool(
                "bitbucket_approve_pr",
                mcp.WithDescription("Approve a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="5">{
                bc.logger.Debug("Received bitbucket_approve_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="4">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov2" title="2">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketApprovePRParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                // Call the service to approve the pull request
                participant, err := bc.bitbucketService.ApprovePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to approve pull request: %w", err)
                }</span>

                // Create a response with the approval details
                <span class="cov1" title="1">return mcp.NewToolResultText(fmt.Sprintf("Pull request #%d approved by %s",
                        prID, participant.User.DisplayName)), nil</span>
        }

        <span class="cov5" title="9">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newMergePRServerTool returns a server tool for merging pull requests.
func (bc *BitbucketController) newMergePRServerTool() server.ServerTool <span class="cov5" title="9">{
        tool := mcp.NewTool(
                "bitbucket_merge_pr",
                mcp.WithDescription("Merge a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("merge_strategy",
                        mcp.Description("Merge strategy (merge_commit, squash, fast_forward)"),
                ),
                mcp.WithString("commit_message",
                        mcp.Description("Custom commit message for the merge (optional)"),
                ),
                mcp.WithString("close_source_branch",
                        mcp.Description("Whether to close the source branch after merge (true/false)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="5">{
                bc.logger.Debug("Received bitbucket_merge_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">mergeStrategy := request.GetString("merge_strategy", "")
                commitMessage := request.GetString("commit_message", "")
                closeSourceBranch := request.GetBool("close_source_branch", false)
                account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketMergePRParams{
                        PullRequestID:     prID,
                        RepoOwner:         repoOwner,
                        RepoName:          repoName,
                        MergeStrategy:     mergeStrategy,
                        Message:           commitMessage,
                        CloseSourceBranch: closeSourceBranch,
                        AccountName:       account,
                }

                // Call the service to merge the pull request
                pr, err := bc.bitbucketService.MergePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to merge pull request: %w", err)
                }</span>

                // Create a response with the merge details
                <span class="cov2" title="2">var strategyText string
                if mergeStrategy != "" </span><span class="cov2" title="2">{
                        strategyText = fmt.Sprintf(" using %s strategy", mergeStrategy)
                }</span>

                <span class="cov2" title="2">var closeBranchText string
                if closeSourceBranch </span><span class="cov1" title="1">{
                        closeBranchText = " and source branch was closed"
                }</span>

                <span class="cov2" title="2">return mcp.NewToolResultText(fmt.Sprintf("Pull request #%d successfully merged%s%s",
                        pr.ID, strategyText, closeBranchText)), nil</span>
        }

        <span class="cov5" title="9">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newListPRTasksServerTool returns a server tool for listing tasks on a pull request.
func (bc *BitbucketController) newListPRTasksServerTool() server.ServerTool <span class="cov6" title="11">{
        tool := mcp.NewTool(
                "bitbucket_list_pr_tasks",
                mcp.WithDescription("List tasks on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="7">{
                bc.logger.Debug("Received bitbucket_list_pr_tasks request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="6">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov4" title="4">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketListTasksParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                // Call the service to list tasks
                tasks, err := bc.bitbucketService.ListTasks(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to list tasks: %w", err)
                }</span>

                // Create a response with the tasks details
                <span class="cov3" title="3">var responseText string
                if tasks.Size == 0 </span><span class="cov0" title="0">{
                        responseText = "No tasks found for this pull request"
                }</span> else<span class="cov3" title="3"> {
                        responseText = fmt.Sprintf("Found %d tasks", tasks.Size)
                        for _, task := range tasks.Values </span><span class="cov4" title="6">{
                                // Get creator display name, handling nil Creator
                                var creatorName string
                                if task.Creator != nil &amp;&amp; task.Creator.DisplayName != "" </span><span class="cov4" title="4">{
                                        creatorName = task.Creator.DisplayName
                                }</span> else<span class="cov2" title="2"> {
                                        creatorName = "unknown user"
                                }</span>

                                <span class="cov4" title="6">responseText += fmt.Sprintf("\nTask #%d: [%s] %s (by %s)",
                                        task.ID,
                                        task.State,
                                        task.Content.Raw,
                                        creatorName)</span>
                        }
                }

                <span class="cov3" title="3">return mcp.NewToolResultText(responseText), nil</span>
        }

        <span class="cov6" title="11">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newUpdatePRTaskServerTool returns a server tool for updating a task on a pull request.
func (bc *BitbucketController) newUpdatePRTaskServerTool() server.ServerTool <span class="cov6" title="10">{
        tool := mcp.NewTool(
                "bitbucket_update_pr_task",
                mcp.WithDescription("Update a task on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithNumber("task_id",
                        mcp.Description("Task ID to update"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("content",
                        mcp.Description("New content for the task (optional if state is provided)"),
                ),
                mcp.WithString("state",
                        mcp.Description("New state for the task: RESOLVED or UNRESOLVED (optional if content is provided)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := bc.makeUpdatePRTaskHandler()

        return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }
}</span>

// makeUpdatePRTaskHandler creates a handler function for the update PR task tool.
// This is split out to reduce the overall function length.
func (bc *BitbucketController) makeUpdatePRTaskHandler() func(
        ctx context.Context,
        request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) <span class="cov6" title="10">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="6">{
                bc.logger.Debug("Received bitbucket_update_pr_task request", "params", request.Params)

                // Extract parameters and validate
                params, errResult := bc.validateUpdateTaskParams(request)
                if errResult != nil </span><span class="cov3" title="3">{
                        return errResult, nil // This returns a tool result error
                }</span>

                // Call the service to update the task
                <span class="cov3" title="3">task, err := bc.bitbucketService.UpdateTask(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to update task: %w", err)
                }</span>

                // Build response text
                <span class="cov2" title="2">responseText := bc.formatUpdateTaskResponse(task, params.TaskID, params.Content, params.State)
                return mcp.NewToolResultText(responseText), nil</span>
        }
}

// validateUpdateTaskParams extracts and validates parameters for the update task request.
func (bc *BitbucketController) validateUpdateTaskParams(
        request mcp.CallToolRequest,
) (app.BitbucketUpdateTaskParams, *mcp.CallToolResult) <span class="cov4" title="6">{
        // Extract required parameters
        prID, err := request.RequireInt("pr_id")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err)
        }</span>

        <span class="cov4" title="5">taskID, err := request.RequireInt("task_id")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid task_id parameter", err)
        }</span>

        <span class="cov4" title="4">repoOwner, err := request.RequireString("repo_owner")
        if err != nil </span><span class="cov0" title="0">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err)
        }</span>

        <span class="cov4" title="4">repoName, err := request.RequireString("repo_name")
        if err != nil </span><span class="cov0" title="0">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err)
        }</span>

        // Optional parameters
        <span class="cov4" title="4">content := request.GetString("content", "")
        state := request.GetString("state", "")
        account := request.GetString("account", "")

        // Either content or state must be provided
        if content == "" &amp;&amp; state == "" </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultError("Either content or state must be provided")
        }</span>

        // Validate state if provided
        <span class="cov3" title="3">if state != "" &amp;&amp; state != TaskStateResolved &amp;&amp; state != TaskStateUnresolved </span><span class="cov0" title="0">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultError("State must be either RESOLVED or UNRESOLVED")
        }</span>

        // Create and return parameters for the service layer
        <span class="cov3" title="3">return app.BitbucketUpdateTaskParams{
                PullRequestID: prID,
                TaskID:        taskID,
                RepoOwner:     repoOwner,
                RepoName:      repoName,
                AccountName:   account,
                Content:       content,
                State:         state,
        }, nil</span>
}

// formatUpdateTaskResponse creates an appropriate response message based on what was updated.
func (bc *BitbucketController) formatUpdateTaskResponse(
        task *bitbucket.PullRequestCommentTask,
        taskID int,
        content,
        state string,
) string <span class="cov2" title="2">{
        switch </span>{
        case content != "" &amp;&amp; state != "":<span class="cov1" title="1">
                return fmt.Sprintf("Updated task #%d content and marked as %s", taskID, task.State)</span>
        case content != "":<span class="cov0" title="0">
                return fmt.Sprintf("Updated task #%d content", taskID)</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("Updated task #%d state to %s", taskID, task.State)</span>
        }
}

// newCreatePRTaskServerTool returns a server tool for creating tasks on a pull request.
func (bc *BitbucketController) newCreatePRTaskServerTool() server.ServerTool <span class="cov4" title="6">{
        tool := mcp.NewTool(
                "bitbucket_create_pr_task",
                mcp.WithDescription("Create a task on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("content",
                        mcp.Description("Task content"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithNumber("comment_id",
                        mcp.Description("Comment ID to associate with the task (optional)"),
                ),
                mcp.WithString("state",
                        mcp.Description("Initial state for the task: RESOLVED or UNRESOLVED (optional, defaults to UNRESOLVED)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := bc.makeCreatePRTaskHandler()

        return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }
}</span>

// makeCreatePRTaskHandler creates a handler function for the create PR task tool.
// This is split out to reduce the overall function length.
func (bc *BitbucketController) makeCreatePRTaskHandler() func(
        ctx context.Context,
        request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) <span class="cov4" title="6">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov1" title="1">{
                bc.logger.Debug("Received bitbucket_create_pr_task request", "params", request.Params)

                // Extract required parameters
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov1" title="1">content, err := request.RequireString("content")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid content parameter", err), nil
                }</span>

                <span class="cov1" title="1">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov1" title="1">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov1" title="1">account := request.GetString("account", "")
                state := request.GetString("state", "")
                commentIDStr := request.GetString("comment_id", "")

                // Parse comment_id if provided
                var commentID int64
                if commentIDStr != "" </span><span class="cov0" title="0">{
                        // Try to convert the string to int64
                        var commentIDFloat float64
                        commentIDFloat, parseErr := strconv.ParseFloat(commentIDStr, 64)
                        if parseErr != nil </span><span class="cov0" title="0">{
                                return mcp.NewToolResultErrorFromErr("Invalid comment_id parameter", parseErr), nil
                        }</span>
                        <span class="cov0" title="0">commentID = int64(commentIDFloat)</span>
                }

                // Validate state if provided
                <span class="cov1" title="1">if state != "" &amp;&amp; state != TaskStateResolved &amp;&amp; state != TaskStateUnresolved </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError("State must be either RESOLVED or UNRESOLVED"), nil
                }</span>

                // Create parameters for the service layer
                <span class="cov1" title="1">params := app.BitbucketCreateTaskParams{
                        PullRequestID: prID,
                        Content:       content,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                        State:         state,
                        CommentID:     commentID,
                }

                // Call the service to create the task
                task, err := bc.bitbucketService.CreateTask(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create task: %w", err)
                }</span>

                // Format response text
                <span class="cov1" title="1">var responseText string
                if task.Comment != nil </span><span class="cov0" title="0">{
                        responseText = fmt.Sprintf("Created task on PR #%d: %s (on comment #%d)",
                                prID, task.Content.Raw, task.Comment.ID)
                }</span> else<span class="cov1" title="1"> {
                        responseText = fmt.Sprintf("Created task on PR #%d: %s", prID, task.Content.Raw)
                }</span>

                <span class="cov1" title="1">return mcp.NewToolResultText(responseText), nil</span>
        }
}

// NewTools returns the tools for this controller.
func (bc *BitbucketController) NewTools() []server.ServerTool <span class="cov3" title="3">{
        return []server.ServerTool{
                bc.newCreatePRServerTool(),
                bc.newReadPRServerTool(),
                bc.newUpdatePRServerTool(),
                bc.newApprovePRServerTool(),
                bc.newMergePRServerTool(),
                bc.newListPRTasksServerTool(),
                bc.newUpdatePRTaskServerTool(),
                bc.newCreatePRTaskServerTool(),
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package controllers

import (
        context "context"

        app "github.com/gemyago/atlacp/internal/app"
        bitbucket "github.com/gemyago/atlacp/internal/services/bitbucket"

        mock "github.com/stretchr/testify/mock"
)

// MockbitbucketService is an autogenerated mock type for the bitbucketService type
type MockbitbucketService struct {
        mock.Mock
}

type MockbitbucketService_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketService) EXPECT() *MockbitbucketService_Expecter <span class="cov7" title="21">{
        return &amp;MockbitbucketService_Expecter{mock: &amp;_m.Mock}
}</span>

// ApprovePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ApprovePR(ctx context.Context, params app.BitbucketApprovePRParams) (*bitbucket.Participant, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ApprovePR")</span>
        }

        <span class="cov2" title="2">var r0 *bitbucket.Participant
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketApprovePRParams) (*bitbucket.Participant, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketApprovePRParams) *bitbucket.Participant); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                if ret.Get(0) != nil </span><span class="cov2" title="2">{
                        r0 = ret.Get(0).(*bitbucket.Participant)
                }</span>
        }

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketApprovePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockbitbucketService_ApprovePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApprovePR'
type MockbitbucketService_ApprovePR_Call struct {
        *mock.Call
}

// ApprovePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketApprovePRParams
func (_e *MockbitbucketService_Expecter) ApprovePR(ctx interface{}, params interface{}) *MockbitbucketService_ApprovePR_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketService_ApprovePR_Call{Call: _e.mock.On("ApprovePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_ApprovePR_Call) Run(run func(ctx context.Context, params app.BitbucketApprovePRParams)) *MockbitbucketService_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketApprovePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ApprovePR_Call) Return(_a0 *bitbucket.Participant, _a1 error) *MockbitbucketService_ApprovePR_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ApprovePR_Call) RunAndReturn(run func(context.Context, app.BitbucketApprovePRParams) (*bitbucket.Participant, error)) *MockbitbucketService_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) CreatePR(ctx context.Context, params app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketCreatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_CreatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePR'
type MockbitbucketService_CreatePR_Call struct {
        *mock.Call
}

// CreatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketCreatePRParams
func (_e *MockbitbucketService_Expecter) CreatePR(ctx interface{}, params interface{}) *MockbitbucketService_CreatePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_CreatePR_Call{Call: _e.mock.On("CreatePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_CreatePR_Call) Run(run func(ctx context.Context, params app.BitbucketCreatePRParams)) *MockbitbucketService_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketCreatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_CreatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_CreatePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_CreatePR_Call) RunAndReturn(run func(context.Context, app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateTask provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) CreateTask(ctx context.Context, params app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateTask")</span>
        }

        <span class="cov1" title="1">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketCreateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockbitbucketService_CreateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTask'
type MockbitbucketService_CreateTask_Call struct {
        *mock.Call
}

// CreateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketCreateTaskParams
func (_e *MockbitbucketService_Expecter) CreateTask(ctx interface{}, params interface{}) *MockbitbucketService_CreateTask_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketService_CreateTask_Call{Call: _e.mock.On("CreateTask", ctx, params)}
}</span>

func (_c *MockbitbucketService_CreateTask_Call) Run(run func(ctx context.Context, params app.BitbucketCreateTaskParams)) *MockbitbucketService_CreateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketCreateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_CreateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketService_CreateTask_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_CreateTask_Call) RunAndReturn(run func(context.Context, app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketService_CreateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListTasks provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ListTasks(ctx context.Context, params app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListTasks")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PaginatedTasks
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListTasksParams) *bitbucket.PaginatedTasks); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PaginatedTasks)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketListTasksParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketService_ListTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTasks'
type MockbitbucketService_ListTasks_Call struct {
        *mock.Call
}

// ListTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketListTasksParams
func (_e *MockbitbucketService_Expecter) ListTasks(ctx interface{}, params interface{}) *MockbitbucketService_ListTasks_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketService_ListTasks_Call{Call: _e.mock.On("ListTasks", ctx, params)}
}</span>

func (_c *MockbitbucketService_ListTasks_Call) Run(run func(ctx context.Context, params app.BitbucketListTasksParams)) *MockbitbucketService_ListTasks_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketListTasksParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ListTasks_Call) Return(_a0 *bitbucket.PaginatedTasks, _a1 error) *MockbitbucketService_ListTasks_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ListTasks_Call) RunAndReturn(run func(context.Context, app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error)) *MockbitbucketService_ListTasks_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MergePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) MergePR(ctx context.Context, params app.BitbucketMergePRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MergePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketMergePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketMergePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketMergePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_MergePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergePR'
type MockbitbucketService_MergePR_Call struct {
        *mock.Call
}

// MergePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketMergePRParams
func (_e *MockbitbucketService_Expecter) MergePR(ctx interface{}, params interface{}) *MockbitbucketService_MergePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_MergePR_Call{Call: _e.mock.On("MergePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_MergePR_Call) Run(run func(ctx context.Context, params app.BitbucketMergePRParams)) *MockbitbucketService_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketMergePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_MergePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_MergePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_MergePR_Call) RunAndReturn(run func(context.Context, app.BitbucketMergePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ReadPR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ReadPR(ctx context.Context, params app.BitbucketReadPRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ReadPR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketReadPRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketReadPRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketReadPRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_ReadPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadPR'
type MockbitbucketService_ReadPR_Call struct {
        *mock.Call
}

// ReadPR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketReadPRParams
func (_e *MockbitbucketService_Expecter) ReadPR(ctx interface{}, params interface{}) *MockbitbucketService_ReadPR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_ReadPR_Call{Call: _e.mock.On("ReadPR", ctx, params)}
}</span>

func (_c *MockbitbucketService_ReadPR_Call) Run(run func(ctx context.Context, params app.BitbucketReadPRParams)) *MockbitbucketService_ReadPR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketReadPRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ReadPR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_ReadPR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ReadPR_Call) RunAndReturn(run func(context.Context, app.BitbucketReadPRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_ReadPR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdatePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) UpdatePR(ctx context.Context, params app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePR")</span>
        }

        <span class="cov2" title="2">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                if ret.Get(0) != nil </span><span class="cov2" title="2">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketUpdatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockbitbucketService_UpdatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePR'
type MockbitbucketService_UpdatePR_Call struct {
        *mock.Call
}

// UpdatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketUpdatePRParams
func (_e *MockbitbucketService_Expecter) UpdatePR(ctx interface{}, params interface{}) *MockbitbucketService_UpdatePR_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketService_UpdatePR_Call{Call: _e.mock.On("UpdatePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_UpdatePR_Call) Run(run func(ctx context.Context, params app.BitbucketUpdatePRParams)) *MockbitbucketService_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketUpdatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_UpdatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_UpdatePR_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_UpdatePR_Call) RunAndReturn(run func(context.Context, app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateTask provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) UpdateTask(ctx context.Context, params app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateTask")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketUpdateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_UpdateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTask'
type MockbitbucketService_UpdateTask_Call struct {
        *mock.Call
}

// UpdateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketUpdateTaskParams
func (_e *MockbitbucketService_Expecter) UpdateTask(ctx interface{}, params interface{}) *MockbitbucketService_UpdateTask_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_UpdateTask_Call{Call: _e.mock.On("UpdateTask", ctx, params)}
}</span>

func (_c *MockbitbucketService_UpdateTask_Call) Run(run func(ctx context.Context, params app.BitbucketUpdateTaskParams)) *MockbitbucketService_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketUpdateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_UpdateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketService_UpdateTask_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_UpdateTask_Call) RunAndReturn(run func(context.Context, app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketService_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketService creates a new instance of MockbitbucketService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketService(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketService <span class="cov10" title="55">{
        mock := &amp;MockbitbucketService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="55">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="55">return mock</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package controllers

import (
        "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/di"
        "go.uber.org/dig"
)

type controllerResult struct {
        dig.Out

        Controller server.ToolsFactory `group:"mcp-controllers"`
}

func newToolsFactory[T server.ToolsFactory](controller T) controllerResult <span class="cov10" title="2">{
        return controllerResult{
                Controller: controller,
        }
}</span>

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewBitbucketController,
                newToolsFactory[*BitbucketController],
                di.ProvideAs[*app.BitbucketService, bitbucketService],
        )
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package server

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "time"

        httpserver "github.com/gemyago/atlacp/internal/api/http/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/gofrs/uuid/v5"
        "github.com/mark3labs/mcp-go/mcp"
        mcpserver "github.com/mark3labs/mcp-go/server"
        "go.uber.org/dig"
)

// Constants for server configuration.
const (
        httpReadTimeout  = 30 * time.Second
        httpWriteTimeout = 30 * time.Second
        httpIdleTimeout  = 120 * time.Second
        shutdownTimeout  = 10 * time.Second
)

type ToolsFactory interface {
        NewTools() []mcpserver.ServerTool
}

type ToolsFactoryFunc func() []mcpserver.ServerTool

func (f ToolsFactoryFunc) NewTools() []mcpserver.ServerTool <span class="cov8" title="5">{
        return f()
}</span>

// MCPServerDeps contains dependencies for creating the MCP server.
type MCPServerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Name     string `name:"config.mcpServer.name"`
        Version  string `name:"config.mcpServer.version"`
        HTTPHost string `name:"config.mcpServer.httpHost"`
        HTTPPort int    `name:"config.mcpServer.httpPort"`

        // services
        *services.ShutdownHooks

        // controllers
        Controllers []ToolsFactory `group:"mcp-controllers"`
}

// ToolInfo contains information about a registered tool.
type ToolInfo struct {
        Tool    mcp.Tool
        Handler mcpserver.ToolHandlerFunc
}

// MCPServer wraps the mcp-go server with additional functionality.
type MCPServer struct {
        mcpServer     *mcpserver.MCPServer
        deps          MCPServerDeps
        logger        *slog.Logger
        shutdownHooks *services.ShutdownHooks
}

// NewMCPServer creates a new MCP server instance.
func NewMCPServer(deps MCPServerDeps) *MCPServer <span class="cov10" title="7">{
        logger := deps.RootLogger.WithGroup("mcp-server")

        mcpServer := mcpserver.NewMCPServer(
                deps.Name,
                deps.Version,
                mcpserver.WithToolCapabilities(true),
                mcpserver.WithToolHandlerMiddleware(
                        func(next mcpserver.ToolHandlerFunc) mcpserver.ToolHandlerFunc </span><span class="cov8" title="5">{
                                return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov8" title="5">{
                                        nextCtx := ctx
                                        diagCtx := diag.GetLogAttributesFromContext(nextCtx)

                                        // We may need to revisit this. It may be so that the diag context is always set
                                        // for the stdio transport at least.
                                        if diagCtx.CorrelationID.Kind() != slog.KindString </span><span class="cov6" title="3">{
                                                diagCtx.CorrelationID = slog.StringValue(uuid.Must(uuid.NewV4()).String())
                                                nextCtx = diag.SetLogAttributesToContext(nextCtx, diagCtx)
                                        }</span>

                                        // It may be quite verbose and we may want to log just the "processed" part.
                                        <span class="cov8" title="5">logger.InfoContext(nextCtx, "Processing tool call",
                                                slog.String("tool", req.Params.Name),
                                                slog.Any("params", req.Params),
                                                slog.Any("meta", req.Params.Meta),
                                        )

                                        res, err := next(nextCtx, req)
                                        if err != nil </span><span class="cov4" title="2">{
                                                diagCtx = diag.GetLogAttributesFromContext(nextCtx)
                                                correlationID := diagCtx.CorrelationID.String()

                                                logger.ErrorContext(nextCtx, "Error processing tool call",
                                                        slog.String("tool", req.Params.Name),
                                                        slog.Any("error", err),
                                                )

                                                errorMessage := fmt.Sprintf("Error details: %s; CorrelationID: %s", err.Error(), correlationID)
                                                return mcp.NewToolResultError(errorMessage), nil
                                        }</span>

                                        <span class="cov6" title="3">logger.InfoContext(nextCtx, "Tool call processed",
                                                slog.String("tool", req.Params.Name),
                                        )
                                        return res, nil</span>
                                }
                        },
                ),
                mcpserver.WithRecovery(),
        )

        <span class="cov10" title="7">mcpSrv := &amp;MCPServer{
                deps:          deps,
                mcpServer:     mcpServer,
                logger:        deps.RootLogger.WithGroup("mcp-server"),
                shutdownHooks: deps.ShutdownHooks,
        }

        for _, controller := range deps.Controllers </span><span class="cov10" title="7">{
                tools := controller.NewTools()
                mcpSrv.mcpServer.AddTools(tools...)
        }</span>

        <span class="cov10" title="7">return mcpSrv</span>
}

// ListenStdioServer starts the MCP server with stdio transport.
func (s *MCPServer) ListenStdioServer(
        ctx context.Context,
        stdin io.Reader,
        stdout io.Writer,
) error <span class="cov0" title="0">{ // coverage-ignore -- Challenging to test this
        stdioSrv := mcpserver.NewStdioServer(s.mcpServer)
        s.logger.InfoContext(ctx, "Starting MCP server with stdio transport",
                slog.String("name", s.deps.Name),
                slog.String("version", s.deps.Version))

        return stdioSrv.Listen(ctx, stdin, stdout)
}</span>

// NewStreamableHTTPServer creates a new streamable HTTP server.
func (s *MCPServer) NewStreamableHTTPServer() *httpserver.HTTPServer <span class="cov1" title="1">{
        return httpserver.NewHTTPServer(httpserver.HTTPServerDeps{
                RootLogger: s.logger,

                Host:              s.deps.HTTPHost,
                Port:              s.deps.HTTPPort,
                IdleTimeout:       httpIdleTimeout,
                ReadHeaderTimeout: httpReadTimeout,
                ReadTimeout:       httpReadTimeout,
                WriteTimeout:      httpWriteTimeout,

                ShutdownHooks: s.shutdownHooks,
                Handler: mcpserver.NewStreamableHTTPServer(
                        s.mcpServer,
                        mcpserver.WithStateLess(true),
                ),
        })
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">//go:build !release

package server

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "sync"

        "github.com/mark3labs/mcp-go/client"
        "github.com/mark3labs/mcp-go/client/transport"
        "github.com/mark3labs/mcp-go/mcp"
        mcpserver "github.com/mark3labs/mcp-go/server"
)

// testMCPServer encapsulates an MCP server and manages resources like pipes and context.
type testMCPServer struct {
        serverReader *io.PipeReader
        serverWriter *io.PipeWriter
        clientReader *io.PipeReader
        clientWriter *io.PipeWriter

        logBuffer bytes.Buffer

        transport transport.Interface
        client    *client.Client

        wg sync.WaitGroup
}

// newTestMCPServer creates a new MCP server instance with the given name, but does not start the server.
// Useful for tests where you need to add tools before starting the server.
func newTestMCPServer() *testMCPServer <span class="cov10" title="5">{
        server := &amp;testMCPServer{}

        // Set up pipes for client-server communication
        server.serverReader, server.clientWriter = io.Pipe()
        server.clientReader, server.serverWriter = io.Pipe()

        // Return the configured server
        return server
}</span>

// Start starts the server in a goroutine. Make sure to defer Close() after Start().
// When using NewServer(), the returned server is already started.
func (s *testMCPServer) Start(
        ctx context.Context,
        mcpServer *mcpserver.MCPServer,
) error <span class="cov10" title="5">{
        s.wg.Add(1)

        go func() </span><span class="cov10" title="5">{
                defer s.wg.Done()

                logger := log.New(&amp;s.logBuffer, "", 0)

                stdioServer := mcpserver.NewStdioServer(mcpServer)
                stdioServer.SetErrorLogger(logger)

                if err := stdioServer.Listen(ctx, s.serverReader, s.serverWriter); err != nil </span><span class="cov10" title="5">{
                        logger.Println("StdioServer.Listen failed:", err)
                }</span>
        }()

        <span class="cov10" title="5">s.transport = transport.NewIO(s.clientReader, s.clientWriter, io.NopCloser(&amp;s.logBuffer))
        if err := s.transport.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transport.Start(): %w", err)
        }</span>

        <span class="cov10" title="5">s.client = client.NewClient(s.transport)

        var initReq mcp.InitializeRequest
        initReq.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
        if _, err := s.client.Initialize(ctx, initReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client.Initialize(): %w", err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

// Client returns an MCP client connected to the server.
// The client is already initialized, i.e. you do _not_ need to call Client.Initialize().
func (s *testMCPServer) Client() *client.Client <span class="cov10" title="5">{
        return s.client
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">//go:build !release

package app

import (
        "github.com/go-faker/faker/v4"
)

// AtlassianAccountOpt is a function that configures an AtlassianAccount.
type AtlassianAccountOpt func(*AtlassianAccount)

// WithAtlassianAccountDefault sets the account as default.
func WithAtlassianAccountDefault(isDefault bool) AtlassianAccountOpt <span class="cov4" title="5">{
        return func(a *AtlassianAccount) </span><span class="cov4" title="5">{
                a.Default = isDefault
        }</span>
}

// WithAtlassianAccountName sets the account name.
func WithAtlassianAccountName(name string) AtlassianAccountOpt <span class="cov6" title="9">{
        return func(a *AtlassianAccount) </span><span class="cov6" title="9">{
                a.Name = name
        }</span>
}

// WithAtlassianAccountBitbucket adds a Bitbucket configuration to the account.
func WithAtlassianAccountBitbucket(opts ...AtlassianTokenOpt) AtlassianAccountOpt <span class="cov0" title="0">{
        return func(a *AtlassianAccount) </span><span class="cov0" title="0">{
                a.Bitbucket = NewRandomAtlassianToken(opts...)
        }</span>
}

// WithAtlassianAccountJira adds a Jira configuration to the account.
func WithAtlassianAccountJira(opts ...AtlassianTokenOpt) AtlassianAccountOpt <span class="cov0" title="0">{
        return func(a *AtlassianAccount) </span><span class="cov0" title="0">{
                a.Jira = NewRandomAtlassianToken(opts...)
        }</span>
}

// BitbucketAccountOpt is a function that configures a BitbucketAccount.
type AtlassianTokenOpt func(*AtlassianToken)

// WithBitbucketAccountToken sets the Bitbucket token.
func WithBitbucketAccountToken(token string) AtlassianTokenOpt <span class="cov0" title="0">{
        return func(b *AtlassianToken) </span><span class="cov0" title="0">{
                b.Value = token
        }</span>
}

// WithBitbucketAccountTokenType sets the Bitbucket token type.
func WithBitbucketAccountTokenType(tokenType string) AtlassianTokenOpt <span class="cov0" title="0">{
        return func(b *AtlassianToken) </span><span class="cov0" title="0">{
                b.Type = tokenType
        }</span>
}

// NewRandomAtlassianAccount generates a random AtlassianAccount for testing.
// Options can be used to customize the account.
func NewRandomAtlassianAccount(opts ...AtlassianAccountOpt) AtlassianAccount <span class="cov8" title="23">{
        account := AtlassianAccount{
                Name:      faker.Name(),
                Bitbucket: NewRandomAtlassianToken(),
                Jira:      NewRandomAtlassianToken(),
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov7" title="14">{
                opt(&amp;account)
        }</span>

        <span class="cov8" title="23">return account</span>
}

// NewRandomBitbucketAccount generates a random BitbucketAccount for testing.
func NewRandomAtlassianToken(opts ...AtlassianTokenOpt) *AtlassianToken <span class="cov10" title="46">{
        account := &amp;AtlassianToken{
                Type:  faker.Word(),
                Value: faker.UUIDHyphenated(),
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(account)
        }</span>

        <span class="cov10" title="46">return account</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package app

import (
        "context"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// staticTokenProvider provides a static token for authentication.
type staticTokenProvider struct {
        token string
}

// newStaticTokenProvider creates a new provider that returns a static token.
func newStaticTokenProvider(token string) *staticTokenProvider <span class="cov10" title="34">{
        return &amp;staticTokenProvider{token: token}
}</span>

// GetToken returns the static token.
func (p *staticTokenProvider) GetToken(_ context.Context) (middleware.Token, error) <span class="cov3" title="3">{
        return middleware.Token{Type: "Bearer", Value: p.token}, nil
}</span>

type tokenProviderFunc func(ctx context.Context) (middleware.Token, error)

func (f tokenProviderFunc) GetToken(ctx context.Context) (middleware.Token, error) <span class="cov5" title="7">{
        return f(ctx)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "go.uber.org/dig"
)

// Task states.
const (
        // TaskStateResolved is the state value for a resolved task.
        TaskStateResolved = "RESOLVED"

        // TaskStateUnresolved is the state value for an unresolved task.
        TaskStateUnresolved = "UNRESOLVED"
)

// BitbucketService provides business logic for Bitbucket operations.
type BitbucketService struct {
        client      bitbucketClient
        authFactory bitbucketAuthFactory
        logger      *slog.Logger
}

// BitbucketServiceDeps contains dependencies for the Bitbucket service.
type BitbucketServiceDeps struct {
        dig.In

        Client      bitbucketClient
        AuthFactory bitbucketAuthFactory
        RootLogger  *slog.Logger
}

// NewBitbucketService creates a new Bitbucket service.
func NewBitbucketService(deps BitbucketServiceDeps) *BitbucketService <span class="cov10" title="41">{
        return &amp;BitbucketService{
                client:      deps.Client,
                authFactory: deps.AuthFactory,
                logger:      deps.RootLogger.WithGroup("app.bitbucket-service"),
        }
}</span>

// BitbucketCreatePRParams contains parameters for creating a pull request.
type BitbucketCreatePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Title of the pull request
        Title string `json:"title"`

        // Description of the pull request
        Description string `json:"description"`

        // Source branch name
        SourceBranch string `json:"source_branch"`

        // Destination branch name
        DestBranch string `json:"dest_branch"`

        // Whether to close the source branch after merging
        CloseSourceBranch bool `json:"close_source_branch"`

        // Reviewer usernames (optional)
        Reviewers []string `json:"reviewers,omitempty"`

        // Whether to create the pull request as a draft
        Draft bool `json:"draft,omitempty"`
}

// BitbucketReadPRParams contains parameters for retrieving a pull request.
type BitbucketReadPRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

// BitbucketUpdatePRParams contains parameters for updating a pull request.
type BitbucketUpdatePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Updated title (optional)
        Title string `json:"title,omitempty"`

        // Updated description (optional)
        Description string `json:"description,omitempty"`
}

// BitbucketApprovePRParams contains parameters for approving a pull request.
type BitbucketApprovePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

// BitbucketMergePRParams contains parameters for merging a pull request.
type BitbucketMergePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Merge commit message (optional)
        Message string `json:"message,omitempty"`

        // Whether to close the source branch after merging
        CloseSourceBranch bool `json:"close_source_branch"`

        // Merge strategy (merge_commit, squash, fast_forward)
        MergeStrategy string `json:"merge_strategy,omitempty"`
}

// BitbucketListTasksParams contains parameters for listing tasks on a pull request.
type BitbucketListTasksParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Optional query to filter tasks (optional)
        Query string `json:"query,omitempty"`

        // Sort order for tasks (optional)
        Sort string `json:"sort,omitempty"`

        // Maximum number of tasks to return per page (optional)
        PageLen int `json:"page_len,omitempty"`
}

// BitbucketUpdateTaskParams contains parameters for updating a task on a pull request.
type BitbucketUpdateTaskParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Task ID to update
        TaskID int `json:"task_id"`

        // Updated task content (optional)
        Content string `json:"content,omitempty"`

        // Updated task state: "RESOLVED" or "UNRESOLVED" (optional)
        State string `json:"state,omitempty"`
}

// BitbucketCreateTaskParams contains parameters for creating a task on a pull request.
type BitbucketCreateTaskParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Task content
        Content string `json:"content"`

        // Comment ID to associate with the task (optional)
        CommentID int64 `json:"comment_id,omitempty"`

        // Task state: "RESOLVED" or "UNRESOLVED" (optional)
        // If not provided, defaults to "UNRESOLVED"
        State string `json:"state,omitempty"`
}

// CreatePR creates a new pull request.
func (s *BitbucketService) CreatePR(
        ctx context.Context,
        params BitbucketCreatePRParams,
) (*bitbucket.PullRequest, error) <span class="cov6" title="9">{
        s.logger.InfoContext(ctx, "Creating pull request",
                slog.String("repo", params.RepoName),
                slog.String("source", params.SourceBranch),
                slog.String("dest", params.DestBranch))

        // Validate required parameters
        if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov6" title="8">if params.Title == "" </span><span class="cov1" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov5" title="7">if params.SourceBranch == "" </span><span class="cov1" title="1">{
                return nil, errors.New("source branch is required")
        }</span>
        <span class="cov5" title="6">if params.DestBranch == "" </span><span class="cov1" title="1">{
                return nil, errors.New("destination branch is required")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="5">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Build pull request object
        prRequest := &amp;bitbucket.PullRequest{
                Title:             params.Title,
                Description:       params.Description,
                CloseSourceBranch: params.CloseSourceBranch,
                Source: bitbucket.PullRequestSource{
                        Branch: bitbucket.PullRequestBranch{
                                Name: params.SourceBranch,
                        },
                },
                Destination: &amp;bitbucket.PullRequestDestination{
                        Branch: bitbucket.PullRequestBranch{
                                Name: params.DestBranch,
                        },
                },
                Draft: params.Draft,
        }

        // Add reviewers if specified
        if len(params.Reviewers) &gt; 0 </span><span class="cov1" title="1">{
                prRequest.Reviewers = make([]bitbucket.PullRequestAuthor, len(params.Reviewers))
                for i, reviewer := range params.Reviewers </span><span class="cov2" title="2">{
                        prRequest.Reviewers[i] = bitbucket.PullRequestAuthor{
                                Username: reviewer,
                        }
                }</span>
        }

        // Call the client to create the pull request
        <span class="cov4" title="5">return s.client.CreatePR(ctx, tokenProvider, bitbucket.CreatePRParams{
                Username: params.RepoOwner,
                RepoSlug: params.RepoName,
                Request:  prRequest,
        })</span>
}

// ReadPR retrieves a specific pull request.
func (s *BitbucketService) ReadPR(ctx context.Context, params BitbucketReadPRParams) (*bitbucket.PullRequest, error) <span class="cov5" title="6">{
        s.logger.InfoContext(ctx, "Reading pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="5">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="4">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov3" title="3">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to get the pull request
        pr, err := s.client.GetPR(ctx, tokenProvider, bitbucket.GetPRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get pull request: %w", err)
        }</span>

        <span class="cov2" title="2">return pr, nil</span>
}

// UpdatePR updates an existing pull request.
func (s *BitbucketService) UpdatePR(
        ctx context.Context,
        params BitbucketUpdatePRParams,
) (*bitbucket.PullRequest, error) <span class="cov6" title="8">{
        s.logger.InfoContext(ctx, "Updating pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="6">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov4" title="5">if params.Title == "" &amp;&amp; params.Description == "" </span><span class="cov1" title="1">{
                return nil, errors.New("either title or description must be provided")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Create update request with provided fields
        updateRequest := &amp;bitbucket.PullRequest{
                Title:       params.Title,
                Description: params.Description,
        }

        // Call the client to update the pull request
        pr, err := s.client.UpdatePR(ctx, tokenProvider, bitbucket.UpdatePRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
                Request:       updateRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update pull request: %w", err)
        }</span>

        <span class="cov3" title="3">return pr, nil</span>
}

// ApprovePR approves a pull request.
func (s *BitbucketService) ApprovePR(
        ctx context.Context,
        params BitbucketApprovePRParams,
) (*bitbucket.Participant, error) <span class="cov5" title="6">{
        s.logger.InfoContext(ctx, "Approving pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="5">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="4">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov3" title="3">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to approve the pull request
        participant, err := s.client.ApprovePR(ctx, tokenProvider, bitbucket.ApprovePRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to approve pull request: %w", err)
        }</span>

        <span class="cov2" title="2">return participant, nil</span>
}

// MergePR merges a pull request.
func (s *BitbucketService) MergePR(ctx context.Context, params BitbucketMergePRParams) (*bitbucket.PullRequest, error) <span class="cov6" title="8">{
        s.logger.InfoContext(ctx, "Merging pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID),
                slog.String("strategy", params.MergeStrategy))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="6">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Validate merge strategy if provided
        <span class="cov4" title="5">if params.MergeStrategy != "" &amp;&amp; !isValidMergeStrategy(params.MergeStrategy) </span><span class="cov1" title="1">{
                return nil, errors.New("invalid merge strategy: must be one of merge_commit, squash, or fast_forward")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Create merge parameters
        mergeParams := &amp;bitbucket.PullRequestMergeParameters{
                CloseSourceBranch: params.CloseSourceBranch,
                Message:           params.Message,
        }

        // Only add merge strategy if specified
        if params.MergeStrategy != "" </span><span class="cov3" title="3">{
                mergeParams.MergeStrategy = params.MergeStrategy
        }</span>

        // Call the client to merge the pull request
        <span class="cov4" title="4">pr, err := s.client.MergePR(ctx, tokenProvider, bitbucket.MergePRParams{
                Username:        params.RepoOwner,
                RepoSlug:        params.RepoName,
                PullRequestID:   params.PullRequestID,
                MergeParameters: mergeParams,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to merge pull request: %w", err)
        }</span>

        <span class="cov3" title="3">return pr, nil</span>
}

// isValidMergeStrategy checks if the provided merge strategy is valid.
func isValidMergeStrategy(strategy string) bool <span class="cov4" title="4">{
        validStrategies := map[string]bool{
                "merge_commit": true,
                "squash":       true,
                "fast_forward": true,
                "":             true, // Empty is valid, will use repo default
        }
        return validStrategies[strategy]
}</span>

// ListTasks retrieves a list of tasks for a specific pull request.
func (s *BitbucketService) ListTasks(
        ctx context.Context,
        params BitbucketListTasksParams,
) (*bitbucket.PaginatedTasks, error) <span class="cov5" title="7">{
        s.logger.InfoContext(ctx, "Listing pull request tasks",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="6">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="5">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to list tasks
        tasks, err := s.client.ListPullRequestTasks(ctx, tokenProvider, bitbucket.ListPullRequestTasksParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                Query:     params.Query,
                Sort:      params.Sort,
                PageLen:   params.PageLen,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to list pull request tasks: %w", err)
        }</span>

        <span class="cov3" title="3">return tasks, nil</span>
}

// UpdateTask updates a task on a pull request.
func (s *BitbucketService) UpdateTask(
        ctx context.Context,
        params BitbucketUpdateTaskParams,
) (*bitbucket.PullRequestCommentTask, error) <span class="cov6" title="9">{
        s.logger.InfoContext(ctx, "Updating pull request task",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID),
                slog.Int("task_id", params.TaskID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov6" title="8">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="7">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov5" title="6">if params.TaskID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("task ID must be positive")
        }</span>
        <span class="cov4" title="5">if params.Content == "" &amp;&amp; params.State == "" </span><span class="cov1" title="1">{
                return nil, errors.New("either content or state must be provided")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to update the task
        task, err := s.client.UpdateTask(ctx, tokenProvider, bitbucket.UpdateTaskParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                TaskID:    params.TaskID,
                Content:   params.Content,
                State:     params.State,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov3" title="3">return task, nil</span>
}

// CreateTask creates a new task on a pull request.
func (s *BitbucketService) CreateTask(
        ctx context.Context,
        params BitbucketCreateTaskParams,
) (*bitbucket.PullRequestCommentTask, error) <span class="cov6" title="8">{
        s.logger.InfoContext(ctx, "Creating task on pull request",
                slog.String("repo", params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="6">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov4" title="5">if params.Content == "" </span><span class="cov1" title="1">{
                return nil, errors.New("content is required")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Prepare the client parameters
        clientParams := bitbucket.CreatePullRequestTaskParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                Content:   params.Content,
                CommentID: params.CommentID,
        }

        // Handle optional state parameter
        if params.State != "" </span><span class="cov0" title="0">{
                // Convert state to pending flag (RESOLVED -&gt; false, UNRESOLVED -&gt; true)
                pending := params.State != TaskStateResolved
                clientParams.Pending = &amp;pending
        }</span>

        // Call the client to create the task
        <span class="cov4" title="4">task, err := s.client.CreatePullRequestTask(ctx, tokenProvider, clientParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov3" title="3">return task, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package app

import (
        "context"
        "errors"
        "log/slog"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

// bitbucketAuthFactory is a factory for creating bitbucketAuth implementations.
type bitbucketAuthFactory interface {
        // getTokenProvider returns a TokenProvider for the specified account name.
        // If accountName is empty, uses the default account.
        getTokenProvider(ctx context.Context, accountName string) TokenProvider
}

// bitbucketAuthFactoryImpl provides authentication for Bitbucket operations by resolving
// account information and providing tokens for API requests.
type bitbucketAuthFactoryImpl struct {
        accountsRepo AtlassianAccountsRepository
        logger       *slog.Logger
}

// BitbucketAuthFactoryDeps contains dependencies for the Bitbucket account auth.
type BitbucketAuthFactoryDeps struct {
        dig.In

        AccountsRepo AtlassianAccountsRepository
        RootLogger   *slog.Logger
}

// newBitbucketAuthFactory creates a new Bitbucket account auth component.
func newBitbucketAuthFactory(deps BitbucketAuthFactoryDeps) bitbucketAuthFactory <span class="cov10" title="8">{
        return &amp;bitbucketAuthFactoryImpl{
                accountsRepo: deps.AccountsRepo,
                logger:       deps.RootLogger.WithGroup("app.bitbucket-account-auth"),
        }
}</span>

// getTokenProvider returns a TokenProvider for the specified account name.
// If accountName is empty, uses the default account.
func (a *bitbucketAuthFactoryImpl) getTokenProvider(_ context.Context, accountName string) TokenProvider <span class="cov8" title="6">{
        return tokenProviderFunc(func(ctx context.Context) (middleware.Token, error) </span><span class="cov8" title="6">{
                var account *AtlassianAccount
                var err error

                if accountName == "" </span><span class="cov7" title="4">{
                        account, err = a.accountsRepo.GetDefaultAccount(ctx)
                        if err != nil </span><span class="cov4" title="2">{
                                return middleware.Token{}, err
                        }</span>
                } else<span class="cov4" title="2"> {
                        account, err = a.accountsRepo.GetAccountByName(ctx, accountName)
                        if err != nil </span><span class="cov1" title="1">{
                                return middleware.Token{}, err
                        }</span>
                }

                // Validate account has Bitbucket configuration
                <span class="cov5" title="3">if account.Bitbucket == nil </span><span class="cov1" title="1">{
                        return middleware.Token{}, errors.New("bitbucket configuration not found for account: " + account.Name)
                }</span>

                <span class="cov4" title="2">return middleware.Token{
                        Type:  account.Bitbucket.Type,
                        Value: account.Bitbucket.Value,
                }, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package app

import (
        "context"
        "log/slog"

        "go.uber.org/dig"
)

// Minimalistic application layer service example.

type EchoData struct {
        Message string
}

type EchoServiceDeps struct {
        dig.In

        RootLogger *slog.Logger
}

type EchoService struct {
        logger *slog.Logger
}

func (svc *EchoService) SendEcho(ctx context.Context, data *EchoData) (*EchoData, error) <span class="cov8" title="3">{
        svc.logger.InfoContext(ctx, "Going to echo data", slog.String("message", data.Message))
        return &amp;EchoData{
                Message: data.Message,
        }, nil
}</span>

func NewEchoService(deps EchoServiceDeps) *EchoService <span class="cov10" title="4">{
        return &amp;EchoService{
                logger: deps.RootLogger.WithGroup("app.echo-service"),
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockAtlassianAccountsRepository is an autogenerated mock type for the AtlassianAccountsRepository type
type MockAtlassianAccountsRepository struct {
        mock.Mock
}

type MockAtlassianAccountsRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockAtlassianAccountsRepository) EXPECT() *MockAtlassianAccountsRepository_Expecter <span class="cov10" title="6">{
        return &amp;MockAtlassianAccountsRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetAccountByName provides a mock function with given fields: ctx, name
func (_m *MockAtlassianAccountsRepository) GetAccountByName(ctx context.Context, name string) (*AtlassianAccount, error) <span class="cov4" title="2">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAccountByName")</span>
        }

        <span class="cov4" title="2">var r0 *AtlassianAccount
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*AtlassianAccount, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov4" title="2">if rf, ok := ret.Get(0).(func(context.Context, string) *AtlassianAccount); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov4" title="2"> {
                if ret.Get(0) != nil </span><span class="cov4" title="2">{
                        r0 = ret.Get(0).(*AtlassianAccount)
                }</span>
        }

        <span class="cov4" title="2">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov4" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="2">return r0, r1</span>
}

// MockAtlassianAccountsRepository_GetAccountByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountByName'
type MockAtlassianAccountsRepository_GetAccountByName_Call struct {
        *mock.Call
}

// GetAccountByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockAtlassianAccountsRepository_Expecter) GetAccountByName(ctx interface{}, name interface{}) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov4" title="2">{
        return &amp;MockAtlassianAccountsRepository_GetAccountByName_Call{Call: _e.mock.On("GetAccountByName", ctx, name)}
}</span>

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) Run(run func(ctx context.Context, name string)) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) Return(_a0 *AtlassianAccount, _a1 error) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov4" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) RunAndReturn(run func(context.Context, string) (*AtlassianAccount, error)) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetDefaultAccount provides a mock function with given fields: ctx
func (_m *MockAtlassianAccountsRepository) GetDefaultAccount(ctx context.Context) (*AtlassianAccount, error) <span class="cov7" title="4">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetDefaultAccount")</span>
        }

        <span class="cov7" title="4">var r0 *AtlassianAccount
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (*AtlassianAccount, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov7" title="4">if rf, ok := ret.Get(0).(func(context.Context) *AtlassianAccount); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov7" title="4"> {
                if ret.Get(0) != nil </span><span class="cov7" title="4">{
                        r0 = ret.Get(0).(*AtlassianAccount)
                }</span>
        }

        <span class="cov7" title="4">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov7" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="4">return r0, r1</span>
}

// MockAtlassianAccountsRepository_GetDefaultAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultAccount'
type MockAtlassianAccountsRepository_GetDefaultAccount_Call struct {
        *mock.Call
}

// GetDefaultAccount is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAtlassianAccountsRepository_Expecter) GetDefaultAccount(ctx interface{}) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov7" title="4">{
        return &amp;MockAtlassianAccountsRepository_GetDefaultAccount_Call{Call: _e.mock.On("GetDefaultAccount", ctx)}
}</span>

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) Run(run func(ctx context.Context)) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) Return(_a0 *AtlassianAccount, _a1 error) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov7" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) RunAndReturn(run func(context.Context) (*AtlassianAccount, error)) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockAtlassianAccountsRepository creates a new instance of MockAtlassianAccountsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAtlassianAccountsRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockAtlassianAccountsRepository <span class="cov10" title="6">{
        mock := &amp;MockAtlassianAccountsRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="6">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="6">return mock</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockbitbucketAuthFactory is an autogenerated mock type for the bitbucketAuthFactory type
type MockbitbucketAuthFactory struct {
        mock.Mock
}

type MockbitbucketAuthFactory_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketAuthFactory) EXPECT() *MockbitbucketAuthFactory_Expecter <span class="cov9" title="31">{
        return &amp;MockbitbucketAuthFactory_Expecter{mock: &amp;_m.Mock}
}</span>

// getTokenProvider provides a mock function with given fields: ctx, accountName
func (_m *MockbitbucketAuthFactory) getTokenProvider(ctx context.Context, accountName string) TokenProvider <span class="cov9" title="31">{
        ret := _m.Called(ctx, accountName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for getTokenProvider")</span>
        }

        <span class="cov9" title="31">var r0 TokenProvider
        if rf, ok := ret.Get(0).(func(context.Context, string) TokenProvider); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountName)
        }</span> else<span class="cov9" title="31"> {
                if ret.Get(0) != nil </span><span class="cov9" title="31">{
                        r0 = ret.Get(0).(TokenProvider)
                }</span>
        }

        <span class="cov9" title="31">return r0</span>
}

// MockbitbucketAuthFactory_getTokenProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getTokenProvider'
type MockbitbucketAuthFactory_getTokenProvider_Call struct {
        *mock.Call
}

// getTokenProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - accountName string
func (_e *MockbitbucketAuthFactory_Expecter) getTokenProvider(ctx interface{}, accountName interface{}) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov9" title="31">{
        return &amp;MockbitbucketAuthFactory_getTokenProvider_Call{Call: _e.mock.On("getTokenProvider", ctx, accountName)}
}</span>

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) Run(run func(ctx context.Context, accountName string)) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) Return(_a0 TokenProvider) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov9" title="31">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) RunAndReturn(run func(context.Context, string) TokenProvider) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketAuthFactory creates a new instance of MockbitbucketAuthFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketAuthFactory(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketAuthFactory <span class="cov10" title="39">{
        mock := &amp;MockbitbucketAuthFactory{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="39">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="39">return mock</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        bitbucket "github.com/gemyago/atlacp/internal/services/bitbucket"

        mock "github.com/stretchr/testify/mock"
)

// MockbitbucketClient is an autogenerated mock type for the bitbucketClient type
type MockbitbucketClient struct {
        mock.Mock
}

type MockbitbucketClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketClient) EXPECT() *MockbitbucketClient_Expecter <span class="cov9" title="31">{
        return &amp;MockbitbucketClient_Expecter{mock: &amp;_m.Mock}
}</span>

// ApprovePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) ApprovePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ApprovePRParams) (*bitbucket.Participant, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ApprovePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.Participant
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) (*bitbucket.Participant, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) *bitbucket.Participant); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.Participant)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketClient_ApprovePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApprovePR'
type MockbitbucketClient_ApprovePR_Call struct {
        *mock.Call
}

// ApprovePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.ApprovePRParams
func (_e *MockbitbucketClient_Expecter) ApprovePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_ApprovePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketClient_ApprovePR_Call{Call: _e.mock.On("ApprovePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_ApprovePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ApprovePRParams)) *MockbitbucketClient_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.ApprovePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_ApprovePR_Call) Return(_a0 *bitbucket.Participant, _a1 error) *MockbitbucketClient_ApprovePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_ApprovePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) (*bitbucket.Participant, error)) *MockbitbucketClient_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) CreatePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePR")</span>
        }

        <span class="cov4" title="5">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                if ret.Get(0) != nil </span><span class="cov4" title="5">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockbitbucketClient_CreatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePR'
type MockbitbucketClient_CreatePR_Call struct {
        *mock.Call
}

// CreatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.CreatePRParams
func (_e *MockbitbucketClient_Expecter) CreatePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_CreatePR_Call <span class="cov4" title="5">{
        return &amp;MockbitbucketClient_CreatePR_Call{Call: _e.mock.On("CreatePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_CreatePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePRParams)) *MockbitbucketClient_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.CreatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_CreatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_CreatePR_Call <span class="cov4" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_CreatePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePullRequestTask provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) CreatePullRequestTask(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePullRequestTask")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_CreatePullRequestTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePullRequestTask'
type MockbitbucketClient_CreatePullRequestTask_Call struct {
        *mock.Call
}

// CreatePullRequestTask is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.CreatePullRequestTaskParams
func (_e *MockbitbucketClient_Expecter) CreatePullRequestTask(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_CreatePullRequestTask_Call{Call: _e.mock.On("CreatePullRequestTask", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePullRequestTaskParams)) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.CreatePullRequestTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) GetPR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketClient_GetPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPR'
type MockbitbucketClient_GetPR_Call struct {
        *mock.Call
}

// GetPR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.GetPRParams
func (_e *MockbitbucketClient_Expecter) GetPR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_GetPR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketClient_GetPR_Call{Call: _e.mock.On("GetPR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_GetPR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRParams)) *MockbitbucketClient_GetPR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.GetPRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_GetPR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_GetPR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_GetPR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_GetPR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListPullRequestTasks provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) ListPullRequestTasks(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListPullRequestTasks")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PaginatedTasks
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) *bitbucket.PaginatedTasks); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PaginatedTasks)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_ListPullRequestTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPullRequestTasks'
type MockbitbucketClient_ListPullRequestTasks_Call struct {
        *mock.Call
}

// ListPullRequestTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.ListPullRequestTasksParams
func (_e *MockbitbucketClient_Expecter) ListPullRequestTasks(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_ListPullRequestTasks_Call{Call: _e.mock.On("ListPullRequestTasks", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPullRequestTasksParams)) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.ListPullRequestTasksParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) Return(_a0 *bitbucket.PaginatedTasks, _a1 error) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error)) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MergePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) MergePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.MergePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MergePR")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_MergePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergePR'
type MockbitbucketClient_MergePR_Call struct {
        *mock.Call
}

// MergePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.MergePRParams
func (_e *MockbitbucketClient_Expecter) MergePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_MergePR_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_MergePR_Call{Call: _e.mock.On("MergePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_MergePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.MergePRParams)) *MockbitbucketClient_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.MergePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_MergePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_MergePR_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_MergePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdatePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) UpdatePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePR")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_UpdatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePR'
type MockbitbucketClient_UpdatePR_Call struct {
        *mock.Call
}

// UpdatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.UpdatePRParams
func (_e *MockbitbucketClient_Expecter) UpdatePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_UpdatePR_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_UpdatePR_Call{Call: _e.mock.On("UpdatePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_UpdatePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdatePRParams)) *MockbitbucketClient_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.UpdatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_UpdatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_UpdatePR_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_UpdatePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateTask provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) UpdateTask(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateTask")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_UpdateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTask'
type MockbitbucketClient_UpdateTask_Call struct {
        *mock.Call
}

// UpdateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.UpdateTaskParams
func (_e *MockbitbucketClient_Expecter) UpdateTask(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_UpdateTask_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_UpdateTask_Call{Call: _e.mock.On("UpdateTask", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_UpdateTask_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdateTaskParams)) *MockbitbucketClient_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.UpdateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_UpdateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketClient_UpdateTask_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_UpdateTask_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketClient_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketClient creates a new instance of MockbitbucketClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketClient <span class="cov10" title="39">{
        mock := &amp;MockbitbucketClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="39">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="39">return mock</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by apigen DO NOT EDIT.

package models

import (
        "encoding/json"
        "fmt"
        "time"
)

// Unused imports workaround.
var _ = time.Time{}
var _ = json.Unmarshal
var _ = fmt.Sprint
type HealthResponsePayloadStatus string

// List of HealthResponsePayloadStatus values.
const (
        HealthResponsePayloadStatusOK HealthResponsePayloadStatus = "OK"
)

func(v HealthResponsePayloadStatus) IsOK() bool <span class="cov0" title="0">{
  return v == HealthResponsePayloadStatusOK
}</span>

func(v HealthResponsePayloadStatus) String() string <span class="cov0" title="0">{
        return string(v)
}</span>

type assignableHealthResponsePayloadStatus interface {
        IsOK() bool
        String() string
}

func AsHealthResponsePayloadStatus(v assignableHealthResponsePayloadStatus) (HealthResponsePayloadStatus) <span class="cov0" title="0">{
        return HealthResponsePayloadStatus(v.String())
}</span>

func ParseHealthResponsePayloadStatus(str string, target *HealthResponsePayloadStatus) error <span class="cov0" title="0">{
        switch str </span>{
        case "OK":<span class="cov0" title="0">
                *target = HealthResponsePayloadStatusOK</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unexpected HealthResponsePayloadStatus value: %s", str)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *HealthResponsePayloadStatus) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var str string
        if err := json.Unmarshal(data, &amp;str); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ParseHealthResponsePayloadStatus(str, v)</span>
}

// All allowed values of HealthResponsePayloadStatus enum.
var AllowableHealthResponsePayloadStatusValues = []HealthResponsePayloadStatus{
        HealthResponsePayloadStatusOK,
}

type HealthResponsePayload struct { 
        Status HealthResponsePayloadStatus `json:"status"`
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package app

import (
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="4">{
        return di.ProvideAll(container,
                NewEchoService,
                NewBitbucketService,
                newBitbucketAuthFactory,
                di.ProvideAs[*bitbucket.Client, bitbucketClient],
        )
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package config

import (
        "embed"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="41">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov7" title="16">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov8" title="25">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov8" title="25">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov7" title="14">{
        if val != "" </span><span class="cov5" title="6">{
                opts.env = val
        }</span>
        <span class="cov7" title="14">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov7" title="16">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func New() *viper.Viper <span class="cov7" title="16">{
        v := viper.New()
        v.SetEnvPrefix("APP")
        v.SetConfigType("json")
        v.SetEnvKeyReplacer(
                strings.NewReplacer("-", "_", ".", "_"),
        )
        v.AutomaticEnv()
        return v
}</span>

func Load(cfg *viper.Viper, opts *LoadOpts) error <span class="cov7" title="16">{
        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="15">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov4" title="5">{
                return err
        }</span>

        // load env user if exists
        <span class="cov6" title="10">if err := mergeResourceCfg(cfg, opts.env+"-user.json"); err != nil </span><span class="cov6" title="10">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="10">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package config

import (
        "fmt"

        "github.com/gemyago/atlacp/internal/di"
        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="66">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="65">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov5" title="9">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt32() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetInt32(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov8" title="33">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov7" title="21">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov3" title="4">{
        return di.ProvideAll(container,
                provideConfigValue(cfg, "gracefulShutdownTimeout").asDuration(),

                // http server config
                provideConfigValue(cfg, "httpServer.host").asString(),
                provideConfigValue(cfg, "httpServer.port").asInt(),
                provideConfigValue(cfg, "httpServer.idleTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readHeaderTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.writeTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.accessLogsLevel").asString(),

                // mcp server config
                provideConfigValue(cfg, "mcpServer.name").asString(),
                provideConfigValue(cfg, "mcpServer.version").asString(),
                provideConfigValue(cfg, "mcpServer.httpHost").asString(),
                provideConfigValue(cfg, "mcpServer.httpPort").asInt(),

                // atlassian config
                provideConfigValue(cfg, "atlassian.bitbucket.baseUrl").asString(),
                provideConfigValue(cfg, "atlassian.jira.baseUrl").asString(),
                provideConfigValue(cfg, "atlassian.accountsFilePath").asString(),
        )
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="38">{
        for i, provider := range providers </span><span class="cov10" title="144">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="80">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="64">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="36">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="81">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="36">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov4" title="6">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov1" title="1">{
                var src TSource
                var tgt TTarget
                return target, fmt.Errorf("failed to cast %s to %s", reflect.TypeOf(src), reflect.TypeOf(tgt))
        }</span>
        <span class="cov3" title="5">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov8" title="1">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov5" title="17">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="10">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov8" title="244">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov8" title="132">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov4" title="12">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov8" title="132">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov10" title="523">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="431">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov3" title="5">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov3" title="5">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov8" title="209">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov3" title="5">{
        if outputFile == "" </span><span class="cov1" title="1">{
                return opts
        }</span>
        <span class="cov2" title="4">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="4">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov8" title="215">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov8" title="215">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov8" title="214"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov8" title="215">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">//go:build !release

// TODO: generated code should include "//go:build !release" tags
//go:generate mockgen -typed -package diag -destination mock_slog_handler_test.go log/slog Handler

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov5" title="15">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov5" title="15">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="208">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package services

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "os"

        "github.com/gemyago/atlacp/internal/app"
        "go.uber.org/dig"
)

// atlassianAccountsConfig represents the structure of the accounts configuration file.
type atlassianAccountsConfig struct {
        // List of Atlassian accounts
        Accounts []app.AtlassianAccount `json:"accounts"`
}

// atlassianAccountsRepository implements the app.AtlassianAccountsRepository interface.
type atlassianAccountsRepository struct {
        config *atlassianAccountsConfig
        logger *slog.Logger
}

// AtlassianAccountsRepositoryDeps contains dependencies for the accounts repository.
type AtlassianAccountsRepositoryDeps struct {
        dig.In

        RootLogger *slog.Logger
        ConfigPath string `name:"config.atlassian.accountsFilePath"`
}

// NewAtlassianAccountsRepository creates a new Atlassian accounts repository.
func NewAtlassianAccountsRepository(deps AtlassianAccountsRepositoryDeps) (app.AtlassianAccountsRepository, error) <span class="cov7" title="8">{
        logger := deps.RootLogger.WithGroup("atlassian-accounts")
        configPath := deps.ConfigPath

        // Use default path if not specified
        if configPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("accounts configuration path not specified")
        }</span>

        // Check if file exists
        <span class="cov7" title="8">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("accounts configuration file not found at %s", configPath)
        }</span>

        // Read and parse configuration
        <span class="cov6" title="7">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read accounts configuration: %w", err)
        }</span>

        <span class="cov6" title="6">var config atlassianAccountsConfig
        if unmarshalErr := json.Unmarshal(data, &amp;config); unmarshalErr != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse accounts configuration: %w", unmarshalErr)
        }</span>

        // Validate configuration
        <span class="cov5" title="5">if validateErr := validateAccountsConfig(&amp;config); validateErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid accounts configuration: %w", validateErr)
        }</span>

        <span class="cov5" title="5">return &amp;atlassianAccountsRepository{
                config: &amp;config,
                logger: logger,
        }, nil</span>
}

// GetDefaultAccount returns the default Atlassian account configuration.
func (r *atlassianAccountsRepository) GetDefaultAccount(_ context.Context) (*app.AtlassianAccount, error) <span class="cov3" title="2">{
        for i, account := range r.config.Accounts </span><span class="cov5" title="4">{
                if account.Default </span><span class="cov1" title="1">{
                        return &amp;r.config.Accounts[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, app.ErrNoDefaultAccount</span>
}

// GetAccountByName returns an account with the specified name.
func (r *atlassianAccountsRepository) GetAccountByName(_ context.Context, name string) (*app.AtlassianAccount, error) <span class="cov3" title="2">{
        for i, account := range r.config.Accounts </span><span class="cov6" title="6">{
                if account.Name == name </span><span class="cov1" title="1">{
                        return &amp;r.config.Accounts[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("%w: %s", app.ErrAccountNotFound, name)</span>
}

// validateAccountsConfig validates the accounts configuration.
func validateAccountsConfig(config *atlassianAccountsConfig) error <span class="cov7" title="9">{
        if len(config.Accounts) == 0 </span><span class="cov1" title="1">{
                return errors.New("no accounts configured")
        }</span>

        <span class="cov7" title="8">accountNames := make(map[string]bool)
        foundDefault := false

        for _, account := range config.Accounts </span><span class="cov9" title="19">{
                // Validate basic account properties
                if err := validateBasicAccountProperties(account, accountNames); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov9" title="18">accountNames[account.Name] = true

                // Validate service-specific configuration
                if err := validateServiceConfigs(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Track default account
                <span class="cov9" title="18">if account.Default </span><span class="cov6" title="7">{
                        if foundDefault </span><span class="cov1" title="1">{
                                return errors.New("multiple default accounts defined")
                        }</span>
                        <span class="cov6" title="6">foundDefault = true</span>
                }
        }

        // Ensure at least one default account exists
        <span class="cov6" title="6">if !foundDefault </span><span class="cov1" title="1">{
                return errors.New("no default account specified")
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// validateBasicAccountProperties validates non-service-specific account properties.
func validateBasicAccountProperties(account app.AtlassianAccount, existingNames map[string]bool) error <span class="cov10" title="21">{
        // Check for duplicate names
        if existingNames[account.Name] </span><span class="cov1" title="1">{
                return fmt.Errorf("duplicate account name: %s", account.Name)
        }</span>

        // Check that name is specified
        <span class="cov9" title="20">if account.Name == "" </span><span class="cov1" title="1">{
                return errors.New("account missing name")
        }</span>

        // Ensure at least one service is configured
        <span class="cov9" title="19">if account.Bitbucket == nil &amp;&amp; account.Jira == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s must have at least one service configured", account.Name)
        }</span>

        <span class="cov9" title="18">return nil</span>
}

// validateServiceConfigs validates Bitbucket and Jira configurations for an account.
func validateServiceConfigs(account app.AtlassianAccount) error <span class="cov9" title="18">{
        // Validate Bitbucket configuration if provided
        if account.Bitbucket != nil </span><span class="cov9" title="18">{
                if err := validateBitbucketConfig(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Validate Jira configuration if provided
        <span class="cov9" title="18">if account.Jira != nil </span><span class="cov8" title="14">{
                if err := validateJiraConfig(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="18">return nil</span>
}

// validateBitbucketConfig validates Bitbucket-specific configuration.
func validateBitbucketConfig(account app.AtlassianAccount) error <span class="cov9" title="20">{
        if account.Bitbucket.Value == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Bitbucket token value", account.Name)
        }</span>
        <span class="cov9" title="19">if account.Bitbucket.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Bitbucket token type", account.Name)
        }</span>
        <span class="cov9" title="18">return nil</span>
}

// validateJiraConfig validates Jira-specific configuration.
func validateJiraConfig(account app.AtlassianAccount) error <span class="cov9" title="16">{
        if account.Jira.Value == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Jira token value", account.Name)
        }</span>
        <span class="cov9" title="15">if account.Jira.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Jira token type", account.Name)
        }</span>
        <span class="cov8" title="14">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ApprovePRParams contains parameters for approving a pull request.
type ApprovePRParams struct {
        Username      string `json:"-"`
        RepoSlug      string `json:"-"`
        PullRequestID int    `json:"-"`
}

// ApprovePR approves a specific pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/approve.
func (c *Client) ApprovePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ApprovePRParams,
) (*Participant, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var participant Participant
        path := fmt.Sprintf(
                "/repositories/%s/%s/pullrequests/%d/approve",
                params.Username,
                params.RepoSlug,
                params.PullRequestID,
        )
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, Participant]{
                Method: "POST",
                URL:    c.baseURL + path,
                Target: &amp;participant,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("approve pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;participant, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package bitbucket

import (
        "context"
        "log/slog"
        "net/http"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

// TokenProvider provides authentication tokens for Bitbucket API requests.
type TokenProvider interface {
        GetToken(ctx context.Context) (middleware.Token, error)
}

// Client provides access to Bitbucket Cloud API operations.
type Client struct {
        httpClient *http.Client
        baseURL    string
        logger     *slog.Logger
}

// ClientDeps contains dependencies for the Bitbucket client.
type ClientDeps struct {
        dig.In

        ClientFactory *httpservices.ClientFactory
        RootLogger    *slog.Logger
        BaseURL       string `name:"config.atlassian.bitbucket.baseUrl"`
}

// NewClient creates a new Bitbucket API client.
func NewClient(deps ClientDeps) *Client <span class="cov10" title="38">{
        return &amp;Client{
                httpClient: deps.ClientFactory.CreateClient(),
                baseURL:    deps.BaseURL,
                logger:     deps.RootLogger.WithGroup("bitbucket-client"),
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// CreatePRParams contains parameters for creating a pull request.
type CreatePRParams struct {
        Username string       `json:"-"`
        RepoSlug string       `json:"-"`
        Request  *PullRequest `json:"-"`
}

// CreatePR creates a new pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests.
func (c *Client) CreatePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params CreatePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests", params.Username, params.RepoSlug)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[PullRequest, PullRequest]{
                Method: "POST",
                URL:    c.baseURL + path,
                Body:   params.Request,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("create pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// CreatePullRequestTaskParams contains parameters for creating a task on a pull request.
type CreatePullRequestTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int

        // Required body parameters
        Content string // The task content

        // Optional body parameters
        CommentID int64 // Optional comment ID to associate with the task
        Pending   *bool // Optional status of the task (nil = default based on API)
}

// CreateTaskPayload represents the request payload for creating a task.
type CreateTaskPayload struct {
        Content struct {
                Raw string `json:"raw"`
        } `json:"content"`
        Comment *CommentReference `json:"comment,omitempty"`
        Pending *bool             `json:"pending,omitempty"`
}

// CommentReference represents a reference to a comment.
type CommentReference struct {
        ID int64 `json:"id"`
}

// CreatePullRequestTask creates a new task on a pull request.
func (c *Client) CreatePullRequestTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params CreatePullRequestTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID)

        // Create request payload
        payload := CreateTaskPayload{}
        payload.Content.Raw = params.Content

        if params.CommentID &gt; 0 </span><span class="cov1" title="1">{
                payload.Comment = &amp;CommentReference{
                        ID: params.CommentID,
                }
        }</span>

        <span class="cov8" title="3">if params.Pending != nil </span><span class="cov1" title="1">{
                payload.Pending = params.Pending
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PullRequestCommentTask
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[CreateTaskPayload, PullRequestCommentTask]{
                Method: "POST",
                URL:    c.baseURL + path,
                Body:   &amp;payload,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("create pull request task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetPRParams contains parameters for getting a pull request.
type GetPRParams struct {
        Username      string `json:"-"`
        RepoSlug      string `json:"-"`
        PullRequestID int    `json:"-"`
}

// GetPR retrieves a specific pull request by ID.
// GET /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}.
func (c *Client) GetPR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetPRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d", params.Username, params.RepoSlug, params.PullRequestID)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, PullRequest]{
                Method: "GET",
                URL:    c.baseURL + path,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetTaskParams contains parameters for getting a specific task on a pull request.
type GetTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int
        TaskID    int
}

// GET /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}.
func (c *Client) GetTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks/%d",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
                params.TaskID)

        var task PullRequestCommentTask
        err = httpservices.SendRequest(
                ctxWithAuth,
                c.httpClient,
                httpservices.SendRequestParams[interface{}, PullRequestCommentTask]{
                        Method: "GET",
                        URL:    c.baseURL + path,
                        Target: &amp;task,
                },
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;task, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"
        "strconv"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ListPullRequestTasksParams contains parameters for listing tasks on a pull request.
type ListPullRequestTasksParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int

        // Optional query parameters
        Query   string
        Sort    string
        PageLen int
}

// ListPullRequestTasks returns a paginated list of tasks on a pull request.
func (c *Client) ListPullRequestTasks(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ListPullRequestTasksParams,
) (*PaginatedTasks, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL with query parameters
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID)

        query := url.Values{}
        if params.Query != "" </span><span class="cov1" title="1">{
                query.Add("q", params.Query)
        }</span>
        <span class="cov8" title="3">if params.Sort != "" </span><span class="cov1" title="1">{
                query.Add("sort", params.Sort)
        }</span>
        <span class="cov8" title="3">if params.PageLen &gt; 0 </span><span class="cov1" title="1">{
                query.Add("pagelen", strconv.Itoa(params.PageLen))
        }</span>

        <span class="cov8" title="3">requestURL := c.baseURL + path
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                requestURL += "?" + query.Encode()
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PaginatedTasks
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[interface{}, PaginatedTasks]{
                Method: "GET",
                URL:    requestURL,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("list pull request tasks failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// MergePRParams contains parameters for merging a pull request.
type MergePRParams struct {
        Username        string                      `json:"-"`
        RepoSlug        string                      `json:"-"`
        PullRequestID   int                         `json:"-"`
        MergeParameters *PullRequestMergeParameters `json:"-"`
}

// MergePR merges a pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/merge.
func (c *Client) MergePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params MergePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf(
                "/repositories/%s/%s/pullrequests/%d/merge",
                params.Username,
                params.RepoSlug,
                params.PullRequestID,
        )
        err = httpservices.SendRequest(
                ctxWithAuth,
                c.httpClient,
                httpservices.SendRequestParams[PullRequestMergeParameters, PullRequest]{
                        Method: "POST",
                        URL:    c.baseURL + path,
                        Body:   params.MergeParameters,
                        Target: &amp;pullRequest,
                },
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("merge pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">//go:build !release

package bitbucket

import "github.com/go-faker/faker/v4"

// PullRequestOpt is a function that configures a PullRequest.
type PullRequestOpt func(*PullRequest)

// WithPullRequestTitle sets the title of the pull request.
func WithPullRequestTitle(title string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Title = title
        }</span>
}

// WithPullRequestDescription sets the description of the pull request.
func WithPullRequestDescription(description string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Description = description
        }</span>
}

// WithPullRequestID sets the ID of the pull request.
func WithPullRequestID(id int) PullRequestOpt <span class="cov1" title="1">{
        return func(pr *PullRequest) </span><span class="cov1" title="1">{
                pr.ID = id
        }</span>
}

// WithPullRequestState sets the state of the pull request.
func WithPullRequestState(state string) PullRequestOpt <span class="cov4" title="3">{
        return func(pr *PullRequest) </span><span class="cov4" title="3">{
                pr.State = state
        }</span>
}

// WithPullRequestSourceBranch sets the source branch of the pull request.
func WithPullRequestSourceBranch(name string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Source.Branch.Name = name
        }</span>
}

// WithPullRequestDestinationBranch sets the destination branch of the pull request.
func WithPullRequestDestinationBranch(name string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                if pr.Destination == nil </span><span class="cov0" title="0">{
                        pr.Destination = &amp;PullRequestDestination{}
                }</span>
                <span class="cov0" title="0">pr.Destination.Branch.Name = name</span>
        }
}

// WithPullRequestCloseSourceBranch sets whether to close the source branch.
func WithPullRequestCloseSourceBranch(closeFlag bool) PullRequestOpt <span class="cov1" title="1">{
        return func(pr *PullRequest) </span><span class="cov1" title="1">{
                pr.CloseSourceBranch = closeFlag
        }</span>
}

// WithPullRequestAuthor sets the author of the pull request.
func WithPullRequestAuthor(author *PullRequestAuthor) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Author = author
        }</span>
}

// WithPullRequestReviewers sets the reviewers for the pull request.
func WithPullRequestReviewers(reviewers []PullRequestAuthor) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Reviewers = reviewers
        }</span>
}

// PullRequestAuthorOpt is a function that configures a PullRequestAuthor.
type PullRequestAuthorOpt func(*PullRequestAuthor)

// WithAuthorUsername sets the username of the author.
func WithAuthorUsername(username string) PullRequestAuthorOpt <span class="cov0" title="0">{
        return func(a *PullRequestAuthor) </span><span class="cov0" title="0">{
                a.Username = username
        }</span>
}

// WithAuthorDisplayName sets the display name of the author.
func WithAuthorDisplayName(displayName string) PullRequestAuthorOpt <span class="cov0" title="0">{
        return func(a *PullRequestAuthor) </span><span class="cov0" title="0">{
                a.DisplayName = displayName
        }</span>
}

// NewRandomPullRequest generates a random PullRequest for testing.
func NewRandomPullRequest(opts ...PullRequestOpt) *PullRequest <span class="cov9" title="14">{
        pr := &amp;PullRequest{
                ID:          int(faker.RandomUnixTime()),
                Title:       "PR-" + faker.Sentence(),
                Description: faker.Paragraph(),
                State:       "OPEN",
                Source: PullRequestSource{
                        Branch: PullRequestBranch{
                                Name: "feature/" + faker.Word(),
                        },
                },
                Destination: &amp;PullRequestDestination{
                        Branch: PullRequestBranch{
                                Name: "main",
                        },
                },
                CloseSourceBranch: true,
                Author:            NewRandomPullRequestAuthor(),
                Type:              "pullrequest",
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov6" title="5">{
                opt(pr)
        }</span>

        <span class="cov9" title="14">return pr</span>
}

// NewRandomPullRequestAuthor generates a random PullRequestAuthor for testing.
func NewRandomPullRequestAuthor(opts ...PullRequestAuthorOpt) *PullRequestAuthor <span class="cov10" title="16">{
        username := faker.Username()
        author := &amp;PullRequestAuthor{
                AccountID:   faker.UUIDHyphenated(),
                DisplayName: faker.Name(),
                Nickname:    username,
                Username:    username,
                UUID:        faker.UUIDHyphenated(),
                Type:        "user",
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(author)
        }</span>

        <span class="cov10" title="16">return author</span>
}

// NewRandomParticipant generates a random Participant for testing.
func NewRandomParticipant(approved bool) *Participant <span class="cov3" title="2">{
        state := "changes_requested"
        if approved </span><span class="cov3" title="2">{
                state = "approved"
        }</span>

        <span class="cov3" title="2">return &amp;Participant{
                User:     *NewRandomPullRequestAuthor(),
                Role:     "REVIEWER",
                Approved: approved,
                State:    state,
                Type:     "participant",
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// UpdatePRParams contains parameters for updating a pull request.
type UpdatePRParams struct {
        Username      string       `json:"-"`
        RepoSlug      string       `json:"-"`
        PullRequestID int          `json:"-"`
        Request       *PullRequest `json:"-"`
}

// UpdatePR updates a pull request.
// PUT /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}.
func (c *Client) UpdatePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params UpdatePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d", params.Username, params.RepoSlug, params.PullRequestID)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[PullRequest, PullRequest]{
                Method: "PUT",
                URL:    c.baseURL + path,
                Body:   params.Request,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("update pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// UpdateTaskParams contains parameters for updating a task on a pull request.
type UpdateTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int
        TaskID    int

        // Optional update parameters
        Content string // The updated task content
        State   string // The state of the task ("RESOLVED" or "UNRESOLVED")
}

// UpdateTaskPayload represents the request payload for updating a task.
type UpdateTaskPayload struct {
        Content *TaskContentUpdate `json:"content,omitempty"`
        State   string             `json:"state,omitempty"`
}

// TaskContentUpdate represents the content update for a task.
type TaskContentUpdate struct {
        Raw string `json:"raw"`
}

// PUT /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}.
func (c *Client) UpdateTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params UpdateTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks/%d",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
                params.TaskID)

        // Create request payload
        payload := UpdateTaskPayload{}

        if params.Content != "" </span><span class="cov1" title="1">{
                payload.Content = &amp;TaskContentUpdate{
                        Raw: params.Content,
                }
        }</span>

        <span class="cov8" title="3">if params.State != "" </span><span class="cov8" title="3">{
                payload.State = params.State
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PullRequestCommentTask
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[UpdateTaskPayload, PullRequestCommentTask]{
                Method: "PUT",
                URL:    c.baseURL + path,
                Body:   &amp;payload,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("update task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package http

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

const (
        // defaultClientTimeout is the default timeout for HTTP clients.
        defaultClientTimeout = 30 * time.Second
)

// ClientFactoryDeps contains dependencies for the client factory.
type ClientFactoryDeps struct {
        dig.In

        RootLogger *slog.Logger
}

// ClientOption configures HTTP client creation.
type ClientOption func(*clientConfig)

// clientConfig holds internal configuration for HTTP client creation.
type clientConfig struct {
        timeout             time.Duration
        enableAuth          bool
        enableLogging       bool
        enableErrorHandling bool
}

// WithTimeout sets the HTTP client timeout.
func WithTimeout(timeout time.Duration) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.timeout = timeout
        }</span>
}

// WithAuth sets whether authentication middleware is enabled.
func WithAuth(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableAuth = enabled
        }</span>
}

// WithLogging sets whether logging middleware is enabled.
func WithLogging(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableLogging = enabled
        }</span>
}

// WithErrorHandling sets whether error handling middleware is enabled.
func WithErrorHandling(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableErrorHandling = enabled
        }</span>
}

// ClientFactory is responsible for creating configured HTTP clients with middleware.
type ClientFactory struct {
        logger *slog.Logger
}

// NewClientFactory creates a new client factory.
func NewClientFactory(deps ClientFactoryDeps) *ClientFactory <span class="cov10" title="55">{
        return &amp;ClientFactory{
                logger: deps.RootLogger.WithGroup("http-client-factory"),
        }
}</span>

// CreateClient creates a new HTTP client with the specified options.
// Middleware is applied in the order: Logging -&gt; Auth -&gt; ErrorHandling -&gt; BaseTransport
// This ensures logging captures the full request lifecycle, auth adds headers, and error handling catches issues.
func (f *ClientFactory) CreateClient(options ...ClientOption) *http.Client <span class="cov10" title="55">{
        config := &amp;clientConfig{
                timeout:             defaultClientTimeout,
                enableAuth:          true, // Default: enabled
                enableLogging:       true, // Default: enabled
                enableErrorHandling: true, // Default: enabled
        }

        for _, option := range options </span><span class="cov4" title="4">{
                option(config)
        }</span>

        // Start with the base transport
        <span class="cov10" title="55">transport := http.DefaultTransport

        // Apply middleware in reverse order (innermost to outermost)
        // Error handling middleware is applied closest to the base transport
        if config.enableErrorHandling </span><span class="cov9" title="54">{
                transport = middleware.NewErrorHandlingMiddleware(transport, middleware.ErrorHandlingMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        // Auth middleware wraps error handling
        <span class="cov10" title="55">if config.enableAuth </span><span class="cov9" title="54">{
                transport = middleware.NewAuthenticationMiddleware(transport, middleware.AuthenticationMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        // Logging middleware is outermost to capture full request lifecycle
        <span class="cov10" title="55">if config.enableLogging </span><span class="cov9" title="54">{
                transport = middleware.NewLoggingMiddleware(transport, middleware.LoggingMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        <span class="cov10" title="55">return &amp;http.Client{
                Transport: transport,
                Timeout:   config.timeout,
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
)

// authTokenKey is the context key for storing authentication tokens.
type authTokenKey struct{}

// Token represents an authentication token with a type and value.
type Token struct {
        Type  string
        Value string
}

// WithAuthTokenV2 adds a Token struct to the context.
func WithAuthTokenV2(ctx context.Context, token Token) context.Context <span class="cov9" title="41">{
        return context.WithValue(ctx, authTokenKey{}, token)
}</span>

// WithAuthToken adds a Bearer authentication token to the context (legacy API).
func WithAuthToken(ctx context.Context, token string) context.Context <span class="cov6" title="12">{
        return WithAuthTokenV2(ctx, Token{Type: "Bearer", Value: token})
}</span>

// AuthTokenFromContext extracts the Token from the context.
func AuthTokenFromContext(ctx context.Context) (Token, bool) <span class="cov9" title="43">{
        token, ok := ctx.Value(authTokenKey{}).(Token)
        return token, ok
}</span>

// AuthenticationMiddlewareDeps contains dependencies for the authentication middleware.
type AuthenticationMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// AuthenticationMiddleware wraps an http.RoundTripper to add authentication headers.
type AuthenticationMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewAuthenticationMiddleware creates a new authentication middleware
// Tokens are injected via context using WithAuthToken.
func NewAuthenticationMiddleware(transport http.RoundTripper, deps AuthenticationMiddlewareDeps) http.RoundTripper <span class="cov10" title="58">{
        return &amp;AuthenticationMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-auth-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface
// Extracts token from context and adds Authorization header.
func (a *AuthenticationMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="42">{
        // Extract token from context
        token, hasToken := AuthTokenFromContext(req.Context())

        // If no token in context, log and pass request through unchanged
        if !hasToken || token.Value == "" </span><span class="cov2" title="2">{
                a.logger.DebugContext(req.Context(), "No authentication token found in context, passing request through unchanged")
                return a.transport.RoundTrip(req)
        }</span>

        // Clone the request to avoid modifying the original
        <span class="cov9" title="40">clonedReq := req.Clone(req.Context())

        // Add Authorization header
        clonedReq.Header.Set("Authorization", token.Type+" "+token.Value)

        // Pass the modified request to the next transport
        return a.transport.RoundTrip(clonedReq)</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "log/slog"
        "net/http"
)

const (
        // HTTP status code boundaries for error classification.
        httpStatusClientErrorMin = 400
        httpStatusServerErrorMin = 500
)

// HTTPError represents an HTTP-related error with context.
type HTTPError struct {
        StatusCode int
        Method     string
        URL        string
        Message    string
        Err        error
}

// Error implements the error interface.
func (e *HTTPError) Error() string <span class="cov8" title="28">{
        if e.Err != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov8" title="27">return e.Message</span>
}

// Unwrap implements error unwrapping for error chain support.
func (e *HTTPError) Unwrap() error <span class="cov2" title="2">{
        return e.Err
}</span>

// ErrorHandlingMiddlewareDeps contains dependencies for the error handling middleware.
type ErrorHandlingMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// ErrorHandlingMiddleware wraps an http.RoundTripper to add generic HTTP error handling.
type ErrorHandlingMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewErrorHandlingMiddleware creates a new error handling middleware.
func NewErrorHandlingMiddleware(transport http.RoundTripper, deps ErrorHandlingMiddlewareDeps) http.RoundTripper <span class="cov10" title="59">{
        return &amp;ErrorHandlingMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-error-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface.
// Handles HTTP errors by wrapping non-2xx responses and transport errors in HTTPError.
func (e *ErrorHandlingMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="43">{
        // Call next transport
        resp, err := e.transport.RoundTrip(req)

        // Handle transport errors (network issues, etc.)
        if err != nil </span><span class="cov1" title="1">{
                httpErr := &amp;HTTPError{
                        StatusCode: 0, // No status code for transport errors
                        Method:     req.Method,
                        URL:        req.URL.String(),
                        Message:    "HTTP transport error",
                        Err:        err,
                }
                e.logger.ErrorContext(req.Context(), "HTTP transport error",
                        "method", req.Method,
                        "url", req.URL.String(),
                        "error", err,
                )
                return nil, httpErr
        }</span>

        // Handle HTTP error status codes
        <span class="cov9" title="42">if resp.StatusCode &gt;= httpStatusClientErrorMin </span><span class="cov6" title="15">{
                var message string
                if resp.StatusCode &gt;= httpStatusServerErrorMin </span><span class="cov2" title="2">{
                        message = fmt.Sprintf("HTTP server error (%d %s)", resp.StatusCode, resp.Status)
                }</span> else<span class="cov6" title="13"> {
                        message = fmt.Sprintf("HTTP client error (%d %s)", resp.StatusCode, resp.Status)
                }</span>

                <span class="cov6" title="15">httpErr := &amp;HTTPError{
                        StatusCode: resp.StatusCode,
                        Method:     req.Method,
                        URL:        req.URL.String(),
                        Message:    message,
                        Err:        nil, // No underlying error for HTTP status errors
                }

                // Read response body for logging, but preserve it for downstream code
                var bodyBytes []byte
                if resp.Body != nil </span><span class="cov6" title="15">{
                        bodyBytes, _ = io.ReadAll(resp.Body)
                        // Close the original body to prevent resource leaks
                        resp.Body.Close()
                        // Replace with a new reader containing the same data
                        resp.Body = io.NopCloser(bytes.NewReader(bodyBytes))
                }</span>

                // Log the error with body content
                <span class="cov6" title="15">e.logger.WarnContext(req.Context(), "HTTP error response",
                        "method", req.Method,
                        "url", req.URL.String(),
                        "status_code", resp.StatusCode,
                        "status", resp.Status,
                        "response_body", string(bodyBytes),
                )

                // Return both the error and the response so downstream code can inspect the body
                return resp, httpErr</span>
        }

        // Success case - pass through unchanged
        <span class="cov8" title="27">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"
)

// LoggingMiddlewareDeps contains dependencies for the logging middleware.
type LoggingMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// LoggingMiddleware wraps an http.RoundTripper to add structured logging.
type LoggingMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewLoggingMiddleware creates a new logging middleware.
func NewLoggingMiddleware(transport http.RoundTripper, deps LoggingMiddlewareDeps) http.RoundTripper <span class="cov10" title="57">{
        return &amp;LoggingMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-logging-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface.
// Logs request and response details with structured logging.
func (l *LoggingMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="41">{
        start := time.Now()

        // Log request
        l.logger.DebugContext(req.Context(), "HTTP request started",
                slog.String("method", req.Method),
                slog.String("url", req.URL.String()),
                slog.String("host", req.Host),
        )

        // Call next transport
        resp, err := l.transport.RoundTrip(req)
        duration := time.Since(start)

        // Log response
        if err != nil </span><span class="cov6" title="14">{
                l.logger.ErrorContext(req.Context(), "HTTP request failed",
                        slog.String("method", req.Method),
                        slog.String("url", req.URL.String()),
                        slog.Duration("duration", duration),
                        slog.Any("error", err),
                )
                return nil, err
        }</span>

        <span class="cov8" title="27">l.logger.DebugContext(req.Context(), "HTTP request completed",
                slog.String("method", req.Method),
                slog.String("url", req.URL.String()),
                slog.Int("status_code", resp.StatusCode),
                slog.Duration("duration", duration),
        )

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
)

// Use interface{} if no body and or target are needed.
type SendRequestParams[TBody any, TTarget any] struct {
        // HTTP method (GET, POST, PUT, DELETE, etc.)
        Method string

        // Full URL for the request
        URL string

        // Request body to be JSON marshaled (can be nil for GET requests)
        Body *TBody

        // Target to unmarshal response into (can be nil if response not needed)
        Target *TTarget
}

// SendRequest performs an HTTP request with generic body and target types.
// This is a shared function that can be used by all API clients for consistent
// request handling, error processing, and response unmarshaling.
func SendRequest[TBody any, TTarget any](
        ctx context.Context,
        client *http.Client,
        params SendRequestParams[TBody, TTarget],
) error <span class="cov10" title="43">{
        var reqBody bytes.Buffer
        if params.Body != nil </span><span class="cov8" title="21">{
                if err := json.NewEncoder(&amp;reqBody).Encode(params.Body); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
        }

        <span class="cov9" title="42">req, err := http.NewRequestWithContext(ctx, params.Method, params.URL, &amp;reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov9" title="42">if params.Body != nil </span><span class="cov8" title="20">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov9" title="42">resp, err := client.Do(req)
        if err != nil </span><span class="cov7" title="14">{
                return fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov8" title="28">defer resp.Body.Close()

        if params.Target != nil </span><span class="cov8" title="23">{
                if err = json.NewDecoder(resp.Body).Decode(params.Target); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to unmarshal response into target: %w", err)
                }</span>
        }

        <span class="cov8" title="27">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package jira

import (
        "context"
        "log/slog"
        "net/http"
        "strings"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "go.uber.org/dig"
)

// TokenProvider provides authentication tokens for Jira API requests.
type TokenProvider interface {
        GetToken(ctx context.Context) (string, error)
}

// Client provides access to Jira Cloud API operations.
type Client struct {
        httpClient *http.Client
        baseURL    string
        logger     *slog.Logger
}

// ClientDeps contains dependencies for the Jira client.
type ClientDeps struct {
        dig.In

        ClientFactory *httpservices.ClientFactory
        RootLogger    *slog.Logger
        BaseURL       string `name:"config.atlassian.jira.baseUrl"`
}

// NewClient creates a new Jira API client.
func NewClient(deps ClientDeps) *Client <span class="cov10" title="14">{
        return &amp;Client{
                httpClient: deps.ClientFactory.CreateClient(),
                baseURL:    deps.BaseURL,
                logger:     deps.RootLogger.WithGroup("jira-client"),
        }
}</span>

// GetBaseURL returns the base URL with the domain replaced.
// The baseURL contains a placeholder {domain} that needs to be replaced with the actual domain.
func (c *Client) GetBaseURL(domain string) string <span class="cov9" title="11">{
        return strings.ReplaceAll(c.baseURL, "{domain}", domain)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package jira

import (
        "context"
        "fmt"
        "net/url"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetTicketParams contains parameters for retrieving a Jira ticket.
type GetTicketParams struct {
        Domain    string   `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey string   `json:"-"` // The ticket key (e.g., "PROJECT-123")
        Fields    []string `json:"-"` // Optional fields to include
        Expand    []string `json:"-"` // Optional expansions (e.g., "renderedFields", "transitions")
}

// GetTicket retrieves a Jira ticket by its key.
// GET /rest/api/3/issue/{issueIdOrKey}.
func (c *Client) GetTicket(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetTicketParams,
) (*Ticket, error) <span class="cov8" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov7" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s", params.TicketKey)

        // Add query parameters if provided
        requestURL, err := url.Parse(baseURL + path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        <span class="cov7" title="3">query := requestURL.Query()
        if len(params.Fields) &gt; 0 </span><span class="cov1" title="1">{
                query.Set("fields", joinStrings(params.Fields))
        }</span>
        <span class="cov7" title="3">if len(params.Expand) &gt; 0 </span><span class="cov1" title="1">{
                query.Set("expand", joinStrings(params.Expand))
        }</span>
        <span class="cov7" title="3">requestURL.RawQuery = query.Encode()

        var ticket Ticket
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, Ticket]{
                Method: "GET",
                URL:    requestURL.String(),
                Target: &amp;ticket,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get ticket failed: %w", err)
        }</span>

        <span class="cov4" title="2">return &amp;ticket, nil</span>
}

// joinStrings joins a slice of strings with commas.
func joinStrings(items []string) string <span class="cov4" title="2">{
        result := ""
        for i, item := range items </span><span class="cov10" title="5">{
                if i &gt; 0 </span><span class="cov7" title="3">{
                        result += ","
                }</span>
                <span class="cov10" title="5">result += item</span>
        }
        <span class="cov4" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package jira

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ManageLabelsParams contains parameters for managing labels on a Jira ticket.
type ManageLabelsParams struct {
        Domain       string   `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey    string   `json:"-"` // The ticket key (e.g., "PROJECT-123")
        AddLabels    []string `json:"-"` // Labels to add to the ticket
        RemoveLabels []string `json:"-"` // Labels to remove from the ticket
}

// ManageLabels adds and/or removes labels from a Jira ticket.
// PUT /rest/api/3/issue/{issueIdOrKey}.
func (c *Client) ManageLabels(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ManageLabelsParams,
) error <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s", params.TicketKey)

        // Create label update request
        request := LabelUpdateRequest{}
        request.Update.Labels = make([]LabelOperation, 0, len(params.AddLabels)+len(params.RemoveLabels))

        // Add labels
        for _, label := range params.AddLabels </span><span class="cov10" title="4">{
                request.Update.Labels = append(request.Update.Labels, LabelOperation{
                        Add: label,
                })
        }</span>

        // Remove labels
        <span class="cov8" title="3">for _, label := range params.RemoveLabels </span><span class="cov1" title="1">{
                request.Update.Labels = append(request.Update.Labels, LabelOperation{
                        Remove: label,
                })
        }</span>

        <span class="cov8" title="3">sendParams := httpservices.SendRequestParams[LabelUpdateRequest, interface{}]{
                Method: "PUT",
                URL:    baseURL + path,
                Body:   &amp;request,
                Target: nil, // No response body expected for successful update
        }
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, sendParams)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("manage labels failed: %w", err)
        }</span>

        <span class="cov5" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package jira

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// TransitionTicketParams contains parameters for transitioning a Jira ticket.
type TransitionTicketParams struct {
        Domain       string                 `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey    string                 `json:"-"` // The ticket key (e.g., "PROJECT-123")
        TransitionID string                 `json:"-"` // The ID of the transition to perform
        Fields       map[string]interface{} `json:"-"` // Optional fields to update during transition
        Update       map[string]interface{} `json:"-"` // Optional updates to perform during transition
}

// TransitionTicket transitions a Jira ticket to a new status.
// POST /rest/api/3/issue/{issueIdOrKey}/transitions.
func (c *Client) TransitionTicket(
        ctx context.Context,
        tokenProvider TokenProvider,
        params TransitionTicketParams,
) error <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s/transitions", params.TicketKey)

        // Create transition request
        request := TransitionRequest{
                Fields: params.Fields,
                Update: params.Update,
        }
        request.Transition.ID = params.TransitionID

        sendParams := httpservices.SendRequestParams[TransitionRequest, interface{}]{
                Method: "POST",
                URL:    baseURL + path,
                Body:   &amp;request,
                Target: nil, // No response body expected for successful transition
        }
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, sendParams)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("transition ticket failed: %w", err)
        }</span>

        <span class="cov5" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package services

import (
        "time"

        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/jira"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="4">{
        return di.ProvideAll(container,
                NewTimeProvider,
                di.ProvideValue(time.NewTicker),
                NewShutdownHooks,
                httpservices.NewClientFactory,
                bitbucket.NewClient,
                jira.NewClient,
                NewAtlassianAccountsRepository,
        )
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// ShutdownHooks are used to implement a graceful shutdown
// of the application. This may include closing database connections, flushing pending
// events to the queue, shutting down the http server, etc.

package services

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "time"

        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type shutdownHook struct {
        name       string
        shutdownFn func(ctx context.Context) error
}

type ShutdownHooks struct {
        logger *slog.Logger
        hooks  []shutdownHook
        deps   ShutdownHooksRegistryDeps
}

// HasHook checks if a shutdown hook with the given name is registered.
// Typical usage is in tests and must be carefully considered for production scenarios.
func (h *ShutdownHooks) HasHook(name string, method any) bool <span class="cov5" title="4">{
        for _, hook := range h.hooks </span><span class="cov4" title="3">{
                if hook.name == name </span><span class="cov3" title="2">{
                        return reflect.ValueOf(hook.shutdownFn).Pointer() == reflect.ValueOf(method).Pointer()
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

func (h *ShutdownHooks) Register(name string, shutdown func(ctx context.Context) error) <span class="cov10" title="13">{
        h.hooks = append(h.hooks, shutdownHook{name: name, shutdownFn: shutdown})
}</span>

func (h *ShutdownHooks) RegisterNoCtx(name string, shutdown func() error) <span class="cov4" title="3">{
        h.Register(name, func(_ context.Context) error </span><span class="cov4" title="3">{
                return shutdown()
        }</span>)
}

func (h *ShutdownHooks) PerformShutdown(ctx context.Context) error <span class="cov7" title="6">{
        ctx, cancel := context.WithTimeout(ctx, h.deps.GracefulShutdownTimeout)
        defer cancel()

        errGrp := errgroup.Group{}
        for _, hook := range h.hooks </span><span class="cov9" title="11">{
                errGrp.Go(func() error </span><span class="cov9" title="11">{
                        hookName := hook.name
                        h.logger.InfoContext(ctx, fmt.Sprintf("Shutting down %s", hookName))
                        if err := hook.shutdownFn(ctx); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to perform shutdown hook %s: %w", hookName, err)
                        }</span>
                        <span class="cov9" title="10">return nil</span>
                })
        }

        <span class="cov7" title="6">done := make(chan error)
        go func() </span><span class="cov7" title="6">{
                done &lt;- errGrp.Wait()
        }</span>()

        <span class="cov7" title="6">select </span>{
        case err := &lt;-done:<span class="cov7" title="6">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

type ShutdownHooksRegistryDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        GracefulShutdownTimeout time.Duration `name:"config.gracefulShutdownTimeout"`
}

func NewShutdownHooks(deps ShutdownHooksRegistryDeps) *ShutdownHooks <span class="cov10" title="13">{
        return &amp;ShutdownHooks{
                logger: deps.RootLogger.WithGroup("shutdown"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">//go:build !release

package services

import (
        "time"

        "github.com/gemyago/atlacp/internal/diag"
        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov0" title="0">{
        m.value = t
}</span>

func (m *MockNow) Now() time.Time <span class="cov0" title="0">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov0" title="0">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

const defaultTestShutdownTimeout = 30 * time.Second

func NewTestShutdownHooks() *ShutdownHooks <span class="cov10" title="6">{
        return NewShutdownHooks(ShutdownHooksRegistryDeps{
                RootLogger:              diag.RootTestLogger(),
                GracefulShutdownTimeout: defaultTestShutdownTimeout,
        })
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov8" title="1">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">//go:build !release

package mocks

import (
        "testing"
)

// GetMock is a helper function to get a mock from a given instance.
// Note: This should only be used internally in tests.
func GetMock[TOutput any](t *testing.T, input interface{}) TOutput <span class="cov10" title="83">{
        mock, ok := input.(TOutput)
        if !ok </span><span class="cov0" title="0">{
                t.Fatalf("input is not a %T", input)
        }</span>
        <span class="cov10" title="83">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
