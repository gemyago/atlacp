
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mcp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gemyago/atlacp/cmd/mcp/http.go (92.5%)</option>
				
				<option value="file1">github.com/gemyago/atlacp/cmd/mcp/main.go (57.1%)</option>
				
				<option value="file2">github.com/gemyago/atlacp/cmd/mcp/root.go (100.0%)</option>
				
				<option value="file3">github.com/gemyago/atlacp/cmd/mcp/stdio.go (90.6%)</option>
				
				<option value="file4">github.com/gemyago/atlacp/internal/api/http/middleware/chain.go (100.0%)</option>
				
				<option value="file5">github.com/gemyago/atlacp/internal/api/http/middleware/recover.go (100.0%)</option>
				
				<option value="file6">github.com/gemyago/atlacp/internal/api/http/middleware/tracing.go (100.0%)</option>
				
				<option value="file7">github.com/gemyago/atlacp/internal/api/http/server/router.go (100.0%)</option>
				
				<option value="file8">github.com/gemyago/atlacp/internal/api/http/server/server.go (92.0%)</option>
				
				<option value="file9">github.com/gemyago/atlacp/internal/api/mcp/controllers/bitbucket.go (92.4%)</option>
				
				<option value="file10">github.com/gemyago/atlacp/internal/api/mcp/controllers/mock_bitbucket_service.go (61.6%)</option>
				
				<option value="file11">github.com/gemyago/atlacp/internal/api/mcp/controllers/register.go (100.0%)</option>
				
				<option value="file12">github.com/gemyago/atlacp/internal/api/mcp/server/server.go (90.9%)</option>
				
				<option value="file13">github.com/gemyago/atlacp/internal/api/mcp/server/testing.go (90.9%)</option>
				
				<option value="file14">github.com/gemyago/atlacp/internal/app/accounts_testing.go (55.0%)</option>
				
				<option value="file15">github.com/gemyago/atlacp/internal/app/auth.go (100.0%)</option>
				
				<option value="file16">github.com/gemyago/atlacp/internal/app/bitbucket.go (96.1%)</option>
				
				<option value="file17">github.com/gemyago/atlacp/internal/app/bitbucket_auth.go (100.0%)</option>
				
				<option value="file18">github.com/gemyago/atlacp/internal/app/echo.go (100.0%)</option>
				
				<option value="file19">github.com/gemyago/atlacp/internal/app/mock_atlassian_accounts_repository.go (65.4%)</option>
				
				<option value="file20">github.com/gemyago/atlacp/internal/app/mock_bitbucket_auth_factory.go (69.6%)</option>
				
				<option value="file21">github.com/gemyago/atlacp/internal/app/mock_bitbucket_client.go (61.6%)</option>
				
				<option value="file22">github.com/gemyago/atlacp/internal/app/register.go (100.0%)</option>
				
				<option value="file23">github.com/gemyago/atlacp/internal/config/load.go (92.0%)</option>
				
				<option value="file24">github.com/gemyago/atlacp/internal/config/provide.go (100.0%)</option>
				
				<option value="file25">github.com/gemyago/atlacp/internal/di/dig.go (100.0%)</option>
				
				<option value="file26">github.com/gemyago/atlacp/internal/diag/attributes.go (100.0%)</option>
				
				<option value="file27">github.com/gemyago/atlacp/internal/diag/mock_slog_handler.go (34.7%)</option>
				
				<option value="file28">github.com/gemyago/atlacp/internal/diag/slog.go (96.6%)</option>
				
				<option value="file29">github.com/gemyago/atlacp/internal/diag/testing.go (75.0%)</option>
				
				<option value="file30">github.com/gemyago/atlacp/internal/services/atlassian_accounts.go (92.2%)</option>
				
				<option value="file31">github.com/gemyago/atlacp/internal/services/bitbucket/add_pr_comment.go (100.0%)</option>
				
				<option value="file32">github.com/gemyago/atlacp/internal/services/bitbucket/approve_pr.go (100.0%)</option>
				
				<option value="file33">github.com/gemyago/atlacp/internal/services/bitbucket/client.go (100.0%)</option>
				
				<option value="file34">github.com/gemyago/atlacp/internal/services/bitbucket/create_pr.go (100.0%)</option>
				
				<option value="file35">github.com/gemyago/atlacp/internal/services/bitbucket/create_task.go (100.0%)</option>
				
				<option value="file36">github.com/gemyago/atlacp/internal/services/bitbucket/get_diff.go (93.8%)</option>
				
				<option value="file37">github.com/gemyago/atlacp/internal/services/bitbucket/get_diffstat.go (100.0%)</option>
				
				<option value="file38">github.com/gemyago/atlacp/internal/services/bitbucket/get_file_content.go (92.9%)</option>
				
				<option value="file39">github.com/gemyago/atlacp/internal/services/bitbucket/get_pr.go (100.0%)</option>
				
				<option value="file40">github.com/gemyago/atlacp/internal/services/bitbucket/get_task.go (100.0%)</option>
				
				<option value="file41">github.com/gemyago/atlacp/internal/services/bitbucket/list_pr_comments.go (100.0%)</option>
				
				<option value="file42">github.com/gemyago/atlacp/internal/services/bitbucket/list_tasks.go (100.0%)</option>
				
				<option value="file43">github.com/gemyago/atlacp/internal/services/bitbucket/merge_pr.go (100.0%)</option>
				
				<option value="file44">github.com/gemyago/atlacp/internal/services/bitbucket/request_pr_changes.go (100.0%)</option>
				
				<option value="file45">github.com/gemyago/atlacp/internal/services/bitbucket/testing.go (48.6%)</option>
				
				<option value="file46">github.com/gemyago/atlacp/internal/services/bitbucket/update_pr.go (100.0%)</option>
				
				<option value="file47">github.com/gemyago/atlacp/internal/services/bitbucket/update_task.go (100.0%)</option>
				
				<option value="file48">github.com/gemyago/atlacp/internal/services/http/client_factory.go (100.0%)</option>
				
				<option value="file49">github.com/gemyago/atlacp/internal/services/http/middleware/auth.go (100.0%)</option>
				
				<option value="file50">github.com/gemyago/atlacp/internal/services/http/middleware/error_handling.go (100.0%)</option>
				
				<option value="file51">github.com/gemyago/atlacp/internal/services/http/middleware/logging.go (100.0%)</option>
				
				<option value="file52">github.com/gemyago/atlacp/internal/services/http/send_request.go (94.1%)</option>
				
				<option value="file53">github.com/gemyago/atlacp/internal/services/jira/client.go (100.0%)</option>
				
				<option value="file54">github.com/gemyago/atlacp/internal/services/jira/get_ticket.go (96.2%)</option>
				
				<option value="file55">github.com/gemyago/atlacp/internal/services/jira/manage_labels.go (100.0%)</option>
				
				<option value="file56">github.com/gemyago/atlacp/internal/services/jira/transition_ticket.go (100.0%)</option>
				
				<option value="file57">github.com/gemyago/atlacp/internal/services/register.go (100.0%)</option>
				
				<option value="file58">github.com/gemyago/atlacp/internal/services/shutdown.go (95.8%)</option>
				
				<option value="file59">github.com/gemyago/atlacp/internal/services/testing.go (12.5%)</option>
				
				<option value="file60">github.com/gemyago/atlacp/internal/services/time.go (100.0%)</option>
				
				<option value="file61">github.com/gemyago/atlacp/internal/testing/mocks/mocks.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os"
        "os/signal"
        "time"

        mcpserver "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type startHTTPServerParams struct {
        dig.In `ignore-unexported:"true"`

        noop bool

        RootLogger *slog.Logger

        MCPServer *mcpserver.MCPServer

        *services.ShutdownHooks
}

func watchForceSignal(
        rootCtx context.Context,
        rootLogger *slog.Logger,
        signals []os.Signal,
) <span class="cov1" title="1">{
        forceSignal := make(chan os.Signal, 1)
        signal.Notify(forceSignal, signals...)

        go func() </span><span class="cov1" title="1">{
                &lt;-forceSignal
                rootLogger.InfoContext(rootCtx, "Forcing shutdown")
                os.Exit(1)
        }</span>()
}

func startHTTPServer(rootCtx context.Context, params startHTTPServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger
        httpServer := params.MCPServer.NewHTTPServer()

        shutdownSignals := []os.Signal{unix.SIGINT, unix.SIGTERM}

        shutdown := func() error </span><span class="cov1" title="1">{
                watchForceSignal(rootCtx, rootLogger, shutdownSignals)
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, shutdownSignals...)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting http server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- httpServer.Start(signalCtx)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newHTTPCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        noop := false
        cmd := &amp;cobra.Command{
                Use:   "http",
                Short: "Start MCP server",
                Long:  "Start MCP server via HTTP transport",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                        return container.Invoke(func(p startHTTPServerParams) error </span><span class="cov1" title="1">{
                                p.noop = noop
                                return startHTTPServer(cmd.Context(), p)
                        }</span>)
                },
        }
        <span class="cov10" title="6">cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Run in noop mode. Useful for testing if setup is all working.",
        )
        return cmd</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "os"

        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func setupCommands() *cobra.Command <span class="cov10" title="6">{
        container := dig.New()
        rootCmd := newRootCmd(container)
        rootCmd.AddCommand(
                newStdioCmd(container),
                newHTTPCmd(container),
        )
        return rootCmd
}</span>

func main() <span class="cov0" title="0">{ // coverage-ignore
        rootCmd := setupCommands()
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // cobra will print error to stdout
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "errors"
        "fmt"
        "log/slog"

        "github.com/gemyago/atlacp/internal/api/mcp/controllers"
        "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/config"
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/samber/lo"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
)

func newRootCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        logsOutputFile := ""

        cmd := &amp;cobra.Command{
                Use:   "mcp",
                Short: "MCP (Model Context Protocol) server command",
                Long:  "Start MCP server with stdio or HTTP transport for providing tools to MCP clients",
        }
        cmd.SilenceUsage = true
        cmd.PersistentFlags().StringP("log-level", "l", "", "Produce logs with given level. Default is env specific.")
        cmd.PersistentFlags().StringVar(
                &amp;logsOutputFile,
                "logs-file",
                "",
                "Produce logs to file instead of stdout. Used for tests only.",
        )
        cmd.PersistentFlags().Bool(
                "json-logs",
                false,
                "Indicates if logs should be in JSON format or text (default)",
        )
        cmd.PersistentFlags().StringP(
                "env",
                "e",
                "",
                "Env that the process is running in.",
        )
        cmd.PersistentFlags().StringP(
                "atlassian-accounts-file",
                "a",
                "",
                "Path to the Atlassian accounts file.",
        )
        cfg := config.New()
        lo.Must0(cfg.BindPFlag("atlassian.accountsFilePath", cmd.PersistentFlags().Lookup("atlassian-accounts-file")))
        lo.Must0(cfg.BindPFlag("jsonLogs", cmd.PersistentFlags().Lookup("json-logs")))
        lo.Must0(cfg.BindPFlag("defaultLogLevel", cmd.PersistentFlags().Lookup("log-level")))
        lo.Must0(cfg.BindPFlag("env", cmd.PersistentFlags().Lookup("env")))
        cmd.PersistentPreRunE = func(_ *cobra.Command, _ []string) error </span><span class="cov10" title="6">{
                err := config.Load(cfg, config.NewLoadOpts().WithEnv(cfg.GetString("env")))
                if err != nil </span><span class="cov4" title="2">{
                        return err
                }</span>

                <span class="cov7" title="4">var logLevel slog.Level
                if err = logLevel.UnmarshalText([]byte(cfg.GetString("defaultLogLevel"))); err != nil </span><span class="cov4" title="2">{
                        return err
                }</span>

                <span class="cov4" title="2">rootLogger := diag.SetupRootLogger(
                        diag.NewRootLoggerOpts().
                                WithJSONLogs(cfg.GetBool("jsonLogs")).
                                WithLogLevel(logLevel).
                                WithOptionalOutputFile(logsOutputFile),
                )

                err = errors.Join(
                        config.Provide(container, cfg),

                        // app layer
                        app.Register(container),

                        // services
                        services.Register(container),

                        // mcp components
                        controllers.Register(container),
                        di.ProvideAll(container,
                                server.NewMCPServer,
                        ),

                        di.ProvideAll(container,
                                di.ProvideValue(rootLogger),
                        ),
                )

                return lo.
                        If(err != nil, fmt.Errorf("failed to inject dependencies: %w", err)).
                        Else(nil)</span>
        }
        <span class="cov10" title="6">return cmd</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "log/slog"
        "os"
        "os/signal"
        "time"

        mcpserver "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/spf13/cobra"
        "go.uber.org/dig"
        "golang.org/x/sys/unix"
)

type stdioServerParams struct {
        dig.In `ignore-unexported:"true"`

        noop bool

        RootLogger *slog.Logger

        MCPServer *mcpserver.MCPServer

        *services.ShutdownHooks
}

func startStdioServer(rootCtx context.Context, params stdioServerParams) error <span class="cov1" title="1">{
        rootLogger := params.RootLogger

        shutdown := func() error </span><span class="cov1" title="1">{
                rootLogger.InfoContext(rootCtx, "Trying to shut down gracefully")
                ts := time.Now()

                err := params.ShutdownHooks.PerformShutdown(rootCtx)
                if err != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Failed to shut down gracefully", diag.ErrAttr(err))
                }</span>

                <span class="cov1" title="1">rootLogger.InfoContext(rootCtx, "Service stopped",
                        slog.Duration("duration", time.Since(ts)),
                )
                return err</span>
        }

        <span class="cov1" title="1">signalCtx, cancel := signal.NotifyContext(rootCtx, unix.SIGINT, unix.SIGTERM)
        defer cancel()

        const startedComponents = 2
        startupErrors := make(chan error, startedComponents)
        go func() </span><span class="cov1" title="1">{
                if params.noop </span><span class="cov1" title="1">{
                        rootLogger.InfoContext(signalCtx, "NOOP: Starting stdio server")
                        startupErrors &lt;- nil
                        return
                }</span>
                <span class="cov0" title="0">startupErrors &lt;- params.MCPServer.ListenStdioServer(signalCtx, os.Stdin, os.Stdout)</span>
        }()

        <span class="cov1" title="1">var startupErr error
        select </span>{
        case startupErr = &lt;-startupErrors:<span class="cov1" title="1">
                if startupErr != nil </span><span class="cov0" title="0">{
                        rootLogger.ErrorContext(rootCtx, "Server startup failed", "err", startupErr)
                }</span>
        case &lt;-signalCtx.Done():<span class="cov0" title="0"></span> // coverage-ignore
                // We will attempt to shut down in both cases
                // so doing it once on a next line
        }
        <span class="cov1" title="1">return errors.Join(startupErr, shutdown())</span>
}

func newStdioCmd(container *dig.Container) *cobra.Command <span class="cov10" title="6">{
        cmd := &amp;cobra.Command{
                Use:   "stdio",
                Short: "Start MCP server with stdio transport",
                Long:  "Start MCP server using stdio transport for communication with MCP clients",
        }

        noop := false
        cmd.Flags().BoolVar(
                &amp;noop,
                "noop",
                false,
                "Run in noop mode. Useful for testing if setup is all working.",
        )
        cmd.RunE = func(_ *cobra.Command, _ []string) error </span><span class="cov1" title="1">{
                return container.Invoke(func(p stdioServerParams) error </span><span class="cov1" title="1">{
                        p.noop = noop
                        return startStdioServer(cmd.Context(), p)
                }</span>)
        }

        <span class="cov10" title="6">return cmd</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package middleware

import "net/http"

type Middleware func(http.Handler) http.Handler

func Chain(middlewares ...Middleware) func(http.Handler) http.Handler <span class="cov6" title="5">{
        return func(h http.Handler) http.Handler </span><span class="cov6" title="5">{
                for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov10" title="15">{
                        h = middlewares[i](h)
                }</span>
                <span class="cov6" title="5">return h</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "errors"
        "log/slog"
        "net/http"
        "runtime/debug"
)

// NewRecovererMiddleware creates a middleware that will handle panics
// log them and respond with 500 to client. This should be the last in a chain.
func NewRecovererMiddleware(rootLogger *slog.Logger) Middleware <span class="cov10" title="7">{
        return func(next http.Handler) http.Handler </span><span class="cov10" title="7">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov7" title="4">{
                        defer func() </span><span class="cov7" title="4">{
                                if rvr := recover(); rvr != nil </span><span class="cov4" title="2">{
                                        if err, ok := rvr.(error); ok &amp;&amp; errors.Is(err, http.ErrAbortHandler) </span><span class="cov1" title="1">{
                                                rootLogger.InfoContext(r.Context(), "Request aborted")
                                                return
                                        }</span>
                                        <span class="cov1" title="1">rootLogger.ErrorContext(
                                                r.Context(),
                                                "Unhandled panic",
                                                slog.Any("panic", rvr),
                                                slog.String("stack", string(debug.Stack())),
                                        )
                                        // TODO: Do not write header if already written
                                        w.WriteHeader(http.StatusInternalServerError)</span>
                                }
                        }()

                        <span class="cov7" title="4">next.ServeHTTP(w, r)</span>
                }

                <span class="cov10" title="7">return http.HandlerFunc(fn)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "log/slog"
        "net/http"

        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gofrs/uuid/v5"
)

type TracingMiddlewareCfg struct {
        generateUUID func() string
}

func NewTracingMiddlewareCfg() *TracingMiddlewareCfg <span class="cov10" title="6">{
        return &amp;TracingMiddlewareCfg{
                generateUUID: func() string </span><span class="cov4" title="2">{
                        return uuid.Must(uuid.NewV4()).String()
                }</span>,
        }
}

func NewTracingMiddleware(cfg *TracingMiddlewareCfg) Middleware <span class="cov10" title="6">{
        generateUUID := cfg.generateUUID
        return func(next http.Handler) http.Handler </span><span class="cov10" title="6">{
                return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov6" title="3">{
                        correlationID := req.Header.Get("x-correlation-id")
                        if correlationID == "" </span><span class="cov4" title="2">{
                                correlationID = generateUUID()
                        }</span>
                        <span class="cov6" title="3">logAttributes := diag.GetLogAttributesFromContext(req.Context())
                        logAttributes.CorrelationID = slog.StringValue(correlationID)
                        nextCtx := diag.SetLogAttributesToContext(req.Context(), logAttributes)
                        next.ServeHTTP(w, req.WithContext(nextCtx))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package server

import "net/http"

type HTTPRouter http.ServeMux

func (*HTTPRouter) PathValue(r *http.Request, paramName string) string <span class="cov8" title="1">{
        return r.PathValue(paramName)
}</span>

func (router *HTTPRouter) HandleRoute(method, pathPattern string, h http.Handler) <span class="cov8" title="1">{
        (*http.ServeMux)(router).Handle(method+" "+pathPattern, h)
}</span>

func (router *HTTPRouter) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        (*http.ServeMux)(router).ServeHTTP(w, r)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "time"

        "github.com/gemyago/atlacp/internal/api/http/middleware"
        "github.com/gemyago/atlacp/internal/services"
        sloghttp "github.com/samber/slog-http"
        "go.uber.org/dig"
)

type HTTPServerDeps struct {
        dig.In `ignore-unexported:"true"`

        RootLogger *slog.Logger

        // config
        Host              string        `name:"config.httpServer.host"`
        Port              int           `name:"config.httpServer.port"`
        IdleTimeout       time.Duration `name:"config.httpServer.idleTimeout"`
        ReadHeaderTimeout time.Duration `name:"config.httpServer.readHeaderTimeout"`
        ReadTimeout       time.Duration `name:"config.httpServer.readTimeout"`
        WriteTimeout      time.Duration `name:"config.httpServer.writeTimeout"`
        AccessLogsLevel   string        `name:"config.httpServer.accessLogsLevel"`

        // handler
        Handler http.Handler

        // services
        *services.ShutdownHooks

        // listeningSignal is an optional channel that Start will close when the server is listening.
        // Primarily for testing.
        listeningSignal chan&lt;- struct{}
}

type HTTPServer struct {
        httpSrv *http.Server
        deps    HTTPServerDeps
        logger  *slog.Logger
}

func (srv *HTTPServer) Start(ctx context.Context) error <span class="cov1" title="1">{
        listener, err := net.Listen("tcp", srv.httpSrv.Addr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on %s: %w", srv.httpSrv.Addr, err)
        }</span>

        <span class="cov1" title="1">actualAddr := listener.Addr().String()
        srv.logger.InfoContext(ctx, "Started http listener",
                slog.String("addr", actualAddr),
                slog.String("idleTimeout", srv.deps.IdleTimeout.String()),
                slog.String("readHeaderTimeout", srv.deps.ReadHeaderTimeout.String()),
                slog.String("readTimeout", srv.deps.ReadTimeout.String()),
                slog.String("writeTimeout", srv.deps.WriteTimeout.String()),
                slog.String("accessLogsLevel", srv.deps.AccessLogsLevel),
        )

        if srv.deps.listeningSignal != nil </span><span class="cov1" title="1">{
                close(srv.deps.listeningSignal)
        }</span>

        // http.Serve always returns a non-nil error.
        // It returns http.ErrServerClosed when Shutdown or Close is called.
        <span class="cov1" title="1">err = srv.httpSrv.Serve(listener)
        if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                return fmt.Errorf("http server Serve error: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func buildMiddlewareChain(deps HTTPServerDeps) http.Handler <span class="cov10" title="5">{
        defaultLogLevel := slog.LevelInfo
        clientErrorLevel := slog.LevelWarn
        serverErrorLevel := slog.LevelError

        if deps.AccessLogsLevel != "" </span><span class="cov4" title="2">{
                if err := defaultLogLevel.UnmarshalText([]byte(deps.AccessLogsLevel)); err != nil </span><span class="cov1" title="1">{
                        panic(fmt.Errorf("failed to unmarshal access logs level: %w", err))</span>
                }
                <span class="cov1" title="1">clientErrorLevel = defaultLogLevel
                serverErrorLevel = defaultLogLevel</span>
        }

        // Router wire-up
        <span class="cov8" title="4">chain := middleware.Chain(
                middleware.NewTracingMiddleware(middleware.NewTracingMiddlewareCfg()),
                sloghttp.NewWithConfig(deps.RootLogger, sloghttp.Config{
                        DefaultLevel:     defaultLogLevel,
                        ClientErrorLevel: clientErrorLevel,
                        ServerErrorLevel: serverErrorLevel,

                        WithUserAgent:      true,
                        WithRequestID:      false, // We handle it ourselves (tracing middleware)
                        WithRequestHeader:  true,
                        WithResponseHeader: true,
                        WithSpanID:         true,
                        WithTraceID:        true,
                }),
                middleware.NewRecovererMiddleware(deps.RootLogger),
        )
        return chain(deps.Handler)</span>
}

// NewHTTPServer constructor factory for general use *http.Server.
func NewHTTPServer(deps HTTPServerDeps) *HTTPServer <span class="cov4" title="2">{
        address := fmt.Sprintf("%s:%d", deps.Host, deps.Port)
        srv := &amp;http.Server{
                Addr:              address,
                IdleTimeout:       deps.IdleTimeout,
                ReadHeaderTimeout: deps.ReadHeaderTimeout,
                ReadTimeout:       deps.ReadTimeout,
                WriteTimeout:      deps.WriteTimeout,
                Handler:           buildMiddlewareChain(deps),
                ErrorLog:          slog.NewLogLogger(deps.RootLogger.Handler(), slog.LevelError),
        }

        deps.ShutdownHooks.Register("http-server", srv.Shutdown)

        return &amp;HTTPServer{
                deps:    deps,
                httpSrv: srv,
                logger:  deps.RootLogger.WithGroup("http-server"),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strconv"
        "strings"

        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
        "github.com/samber/lo"
        "go.uber.org/dig"
)

const (
        // TaskStateResolved represents a "RESOLVED" task state.
        TaskStateResolved = "RESOLVED"

        // TaskStateUnresolved represents an "UNRESOLVED" task state.
        TaskStateUnresolved = "UNRESOLVED"
)

// BitbucketControllerDeps contains dependencies for the Bitbucket MCP controller.
type BitbucketControllerDeps struct {
        dig.In

        RootLogger       *slog.Logger
        BitbucketService bitbucketService
}

// BitbucketController provides MCP Bitbucket tool functionality.
type BitbucketController struct {
        logger           *slog.Logger
        bitbucketService bitbucketService
}

// NewBitbucketController creates a new Bitbucket MCP controller.
func NewBitbucketController(deps BitbucketControllerDeps) *BitbucketController <span class="cov10" title="86">{
        return &amp;BitbucketController{
                logger:           deps.RootLogger.WithGroup("mcp.bitbucket-controller"),
                bitbucketService: deps.BitbucketService,
        }
}</span>

// newCreatePRServerTool returns a server tool for creating pull requests.
func (bc *BitbucketController) newCreatePRServerTool() server.ServerTool <span class="cov6" title="12">{
        tool := mcp.NewTool(
                "bitbucket_create_pr",
                mcp.WithDescription("Create a pull request in Bitbucket"),
                mcp.WithString("title",
                        mcp.Description("Pull request title"),
                        mcp.Required(),
                ),
                mcp.WithString("source_branch",
                        mcp.Description("Source branch name"),
                        mcp.Required(),
                ),
                mcp.WithString("target_branch",
                        mcp.Description("Target branch name"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("description",
                        mcp.Description("Pull request description"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
                mcp.WithBoolean("draft",
                        mcp.Description("Create as draft pull request (optional, defaults to false)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="8">{
                bc.logger.Debug("Received bitbucket_create_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                title, err := request.RequireString("title")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid title parameter", err), nil
                }</span>

                <span class="cov4" title="7">sourceBranch, err := request.RequireString("source_branch")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid source_branch parameter", err), nil
                }</span>

                <span class="cov4" title="6">targetBranch, err := request.RequireString("target_branch")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid target_branch parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">description := request.GetString("description", "")
                account := request.GetString("account", "")
                draft := request.GetBool("draft", false)

                // Create parameters for the service layer
                params := app.BitbucketCreatePRParams{
                        Title:        title,
                        SourceBranch: sourceBranch,
                        DestBranch:   targetBranch,
                        Description:  description,
                        AccountName:  account,
                        RepoOwner:    repoOwner,
                        RepoName:     repoName,
                        Draft:        lo.ToPtr(draft),
                }

                // Call the service to create the pull request
                pr, err := bc.bitbucketService.CreatePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to create pull request: %w", err)
                }</span>

                <span class="cov2" title="2">return mcp.NewToolResultText(fmt.Sprintf("Created pull request #%d: %s", pr.ID, pr.Title)), nil</span>
        }

        <span class="cov6" title="12">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newReadPRServerTool returns a server tool for reading pull request details.
func (bc *BitbucketController) newReadPRServerTool() server.ServerTool <span class="cov5" title="10">{
        tool := mcp.NewTool(
                "bitbucket_read_pr",
                mcp.WithDescription("Get pull request details from Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="6">{
                bc.logger.Debug("Received bitbucket_read_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketReadPRParams{
                        PullRequestID: prID,
                        AccountName:   account,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                }

                // Call the service to read the pull request
                pr, err := bc.bitbucketService.ReadPR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to read pull request: %w", err)
                }</span>

                // Convert PR to JSON for the resource
                <span class="cov2" title="2">prJSON, err := json.MarshalIndent(pr, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal pull request to JSON: %w", err)
                }</span>

                // Create a summary text for the PR
                <span class="cov2" title="2">summaryText := fmt.Sprintf("Pull request #%d: %s (Status: %s)", pr.ID, pr.Title, pr.State)

                // Return both a summary text and the full PR data as a resource
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },

                                // Sending json as text since some clients (Cursor)
                                // do not support resources (at least not yet)
                                mcp.NewTextContent(string(prJSON)),
                        },
                }, nil</span>
        }

        <span class="cov5" title="10">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newUpdatePRServerTool returns a server tool for updating pull requests.
func (bc *BitbucketController) newUpdatePRServerTool() server.ServerTool <span class="cov6" title="12">{
        tool := mcp.NewTool(
                "bitbucket_update_pr",
                mcp.WithDescription("Update a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("title",
                        mcp.Description("New pull request title"),
                ),
                mcp.WithString("description",
                        mcp.Description("New pull request description"),
                ),
                mcp.WithBoolean("draft",
                        mcp.Description("Update as draft pull request (optional)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="8">{
                bc.logger.Debug("Received bitbucket_update_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="7">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="6">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // At least one of title, description, or draft must be provided
                <span class="cov4" title="5">title := request.GetString("title", "")
                description := request.GetString("description", "")

                allArgs := request.GetArguments()
                _, hasTitle := allArgs["title"]
                _, hasDescription := allArgs["description"]
                _, hasDraft := allArgs["draft"]

                if !hasTitle &amp;&amp; !hasDescription &amp;&amp; !hasDraft </span><span class="cov1" title="1">{
                        return mcp.NewToolResultError("Missing attributes to update a PR"), nil
                }</span>

                <span class="cov3" title="4">var draft *bool
                if hasDraft </span><span class="cov1" title="1">{
                        draft = lo.ToPtr(request.GetBool("draft", false))
                }</span>

                // Optional parameters
                <span class="cov3" title="4">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketUpdatePRParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        Title:         title,
                        Description:   description,
                        Draft:         draft,
                        AccountName:   account,
                }

                // Call the service to update the pull request
                pr, err := bc.bitbucketService.UpdatePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to update pull request: %w", err)
                }</span>

                <span class="cov3" title="3">return mcp.NewToolResultText(fmt.Sprintf("Updated pull request #%d: %s", pr.ID, pr.Title)), nil</span>
        }

        <span class="cov6" title="12">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newApprovePRServerTool returns a server tool for approving pull requests.
func (bc *BitbucketController) newApprovePRServerTool() server.ServerTool <span class="cov5" title="9">{
        tool := mcp.NewTool(
                "bitbucket_approve_pr",
                mcp.WithDescription("Approve a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="5">{
                bc.logger.Debug("Received bitbucket_approve_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov3" title="4">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov2" title="2">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketApprovePRParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                // Call the service to approve the pull request
                participant, err := bc.bitbucketService.ApprovePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to approve pull request: %w", err)
                }</span>

                // Create a response with the approval details
                <span class="cov1" title="1">return mcp.NewToolResultText(fmt.Sprintf("Pull request #%d approved by %s",
                        prID, participant.User.DisplayName)), nil</span>
        }

        <span class="cov5" title="9">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newMergePRServerTool returns a server tool for merging pull requests.
func (bc *BitbucketController) newMergePRServerTool() server.ServerTool <span class="cov5" title="9">{
        tool := mcp.NewTool(
                "bitbucket_merge_pr",
                mcp.WithDescription("Merge a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("merge_strategy",
                        mcp.Description("Merge strategy (merge_commit, squash, fast_forward)"),
                ),
                mcp.WithString("commit_message",
                        mcp.Description("Custom commit message for the merge (optional)"),
                ),
                mcp.WithString("close_source_branch",
                        mcp.Description("Whether to close the source branch after merge (true/false)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="5">{
                bc.logger.Debug("Received bitbucket_merge_pr request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="5">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">mergeStrategy := request.GetString("merge_strategy", "")
                commitMessage := request.GetString("commit_message", "")
                closeSourceBranch := request.GetBool("close_source_branch", false)
                account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketMergePRParams{
                        PullRequestID:     prID,
                        RepoOwner:         repoOwner,
                        RepoName:          repoName,
                        MergeStrategy:     mergeStrategy,
                        Message:           commitMessage,
                        CloseSourceBranch: closeSourceBranch,
                        AccountName:       account,
                }

                // Call the service to merge the pull request
                pr, err := bc.bitbucketService.MergePR(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to merge pull request: %w", err)
                }</span>

                // Create a response with the merge details
                <span class="cov2" title="2">var strategyText string
                if mergeStrategy != "" </span><span class="cov2" title="2">{
                        strategyText = fmt.Sprintf(" using %s strategy", mergeStrategy)
                }</span>

                <span class="cov2" title="2">var closeBranchText string
                if closeSourceBranch </span><span class="cov1" title="1">{
                        closeBranchText = " and source branch was closed"
                }</span>

                <span class="cov2" title="2">return mcp.NewToolResultText(fmt.Sprintf("Pull request #%d successfully merged%s%s",
                        pr.ID, strategyText, closeBranchText)), nil</span>
        }

        <span class="cov5" title="9">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newListPRTasksServerTool returns a server tool for listing tasks on a pull request.
func (bc *BitbucketController) newListPRTasksServerTool() server.ServerTool <span class="cov6" title="12">{
        tool := mcp.NewTool(
                "bitbucket_list_pr_tasks",
                mcp.WithDescription("List tasks on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="8">{
                bc.logger.Debug("Received bitbucket_list_pr_tasks request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov4" title="7">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov4" title="6">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov4" title="5">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketListTasksParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                // Call the service to list tasks
                tasks, err := bc.bitbucketService.ListTasks(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to list tasks: %w", err)
                }</span>

                // Create a response with the tasks details
                <span class="cov3" title="4">var responseText string
                if tasks.Size == 0 </span><span class="cov1" title="1">{
                        responseText = "No tasks found for this pull request"
                }</span> else<span class="cov3" title="3"> {
                        responseText = fmt.Sprintf("Found %d tasks", tasks.Size)
                        for _, task := range tasks.Values </span><span class="cov4" title="6">{
                                // Get creator display name, handling nil Creator
                                var creatorName string
                                if task.Creator != nil &amp;&amp; task.Creator.DisplayName != "" </span><span class="cov3" title="4">{
                                        creatorName = task.Creator.DisplayName
                                }</span> else<span class="cov2" title="2"> {
                                        creatorName = "unknown user"
                                }</span>

                                <span class="cov4" title="6">responseText += fmt.Sprintf("\nTask #%d: [%s] %s (by %s)",
                                        task.ID,
                                        task.State,
                                        task.Content.Raw,
                                        creatorName)</span>
                        }
                }

                <span class="cov3" title="4">return mcp.NewToolResultText(responseText), nil</span>
        }

        <span class="cov6" title="12">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newUpdatePRTaskServerTool returns a server tool for updating a task on a pull request.
func (bc *BitbucketController) newUpdatePRTaskServerTool() server.ServerTool <span class="cov6" title="13">{
        tool := mcp.NewTool(
                "bitbucket_update_pr_task",
                mcp.WithDescription("Update a task on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithNumber("task_id",
                        mcp.Description("Task ID to update"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("content",
                        mcp.Description("New content for the task (optional if state is provided)"),
                ),
                mcp.WithString("state",
                        mcp.Description("New state for the task: RESOLVED or UNRESOLVED (optional if content is provided)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := bc.makeUpdatePRTaskHandler()

        return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }
}</span>

// makeUpdatePRTaskHandler creates a handler function for the update PR task tool.
// This is split out to reduce the overall function length.
func (bc *BitbucketController) makeUpdatePRTaskHandler() func(
        ctx context.Context,
        request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) <span class="cov6" title="13">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov5" title="9">{
                bc.logger.Debug("Received bitbucket_update_pr_task request", "params", request.Params)

                // Extract parameters and validate
                params, errResult := bc.validateUpdateTaskParams(request)
                if errResult != nil </span><span class="cov4" title="6">{
                        return errResult, nil // This returns a tool result error
                }</span>

                // Call the service to update the task
                <span class="cov3" title="3">task, err := bc.bitbucketService.UpdateTask(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to update task: %w", err)
                }</span>

                // Build response text
                <span class="cov2" title="2">responseText := bc.formatUpdateTaskResponse(task, params.TaskID, params.Content, params.State)
                return mcp.NewToolResultText(responseText), nil</span>
        }
}

// validateUpdateTaskParams extracts and validates parameters for the update task request.
func (bc *BitbucketController) validateUpdateTaskParams(
        request mcp.CallToolRequest,
) (app.BitbucketUpdateTaskParams, *mcp.CallToolResult) <span class="cov5" title="9">{
        // Extract required parameters
        prID, err := request.RequireInt("pr_id")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err)
        }</span>

        <span class="cov5" title="8">taskID, err := request.RequireInt("task_id")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid task_id parameter", err)
        }</span>

        <span class="cov4" title="7">repoOwner, err := request.RequireString("repo_owner")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err)
        }</span>

        <span class="cov4" title="6">repoName, err := request.RequireString("repo_name")
        if err != nil </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err)
        }</span>

        // Optional parameters
        <span class="cov4" title="5">content := request.GetString("content", "")
        state := request.GetString("state", "")
        account := request.GetString("account", "")

        // Either content or state must be provided
        if content == "" &amp;&amp; state == "" </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultError("Either content or state must be provided")
        }</span>

        // Validate state if provided
        <span class="cov3" title="4">if state != "" &amp;&amp; state != TaskStateResolved &amp;&amp; state != TaskStateUnresolved </span><span class="cov1" title="1">{
                return app.BitbucketUpdateTaskParams{}, mcp.NewToolResultError("State must be either RESOLVED or UNRESOLVED")
        }</span>

        // Create and return parameters for the service layer
        <span class="cov3" title="3">return app.BitbucketUpdateTaskParams{
                PullRequestID: prID,
                TaskID:        taskID,
                RepoOwner:     repoOwner,
                RepoName:      repoName,
                AccountName:   account,
                Content:       content,
                State:         state,
        }, nil</span>
}

// formatUpdateTaskResponse creates an appropriate response message based on what was updated.
func (bc *BitbucketController) formatUpdateTaskResponse(
        task *bitbucket.PullRequestCommentTask,
        taskID int,
        content,
        state string,
) string <span class="cov2" title="2">{
        switch </span>{
        case content != "" &amp;&amp; state != "":<span class="cov1" title="1">
                return fmt.Sprintf("Updated task #%d content and marked as %s", taskID, task.State)</span>
        case content != "":<span class="cov0" title="0">
                return fmt.Sprintf("Updated task #%d content", taskID)</span>
        default:<span class="cov1" title="1">
                return fmt.Sprintf("Updated task #%d state to %s", taskID, task.State)</span>
        }
}

// newCreatePRTaskServerTool returns a server tool for creating tasks on a pull request.
func (bc *BitbucketController) newCreatePRTaskServerTool() server.ServerTool <span class="cov4" title="7">{
        tool := mcp.NewTool(
                "bitbucket_create_pr_task",
                mcp.WithDescription("Create a task on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("content",
                        mcp.Description("Task content"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithNumber("comment_id",
                        mcp.Description("Comment ID to associate with the task (optional)"),
                ),
                mcp.WithString("state",
                        mcp.Description("Initial state for the task: RESOLVED or UNRESOLVED (optional, defaults to UNRESOLVED)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := bc.makeCreatePRTaskHandler()

        return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }
}</span>

// makeCreatePRTaskHandler creates a handler function for the create PR task tool.
// This is split out to reduce the overall function length.
func (bc *BitbucketController) makeCreatePRTaskHandler() func(
        ctx context.Context,
        request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) <span class="cov4" title="7">{
        return func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov3" title="3">{
                bc.logger.Debug("Received bitbucket_create_pr_task request", "params", request.Params)

                // Extract required parameters
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov3" title="3">content, err := request.RequireString("content")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid content parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">account := request.GetString("account", "")
                state := request.GetString("state", "")
                commentIDStr := request.GetString("comment_id", "")

                // Parse comment_id if provided
                var commentID int64
                if commentIDStr != "" </span><span class="cov1" title="1">{
                        // Try to convert the string to int64
                        var commentIDFloat float64
                        commentIDFloat, parseErr := strconv.ParseFloat(commentIDStr, 64)
                        if parseErr != nil </span><span class="cov1" title="1">{
                                return mcp.NewToolResultErrorFromErr("Invalid comment_id parameter", parseErr), nil
                        }</span>
                        <span class="cov0" title="0">commentID = int64(commentIDFloat)</span>
                }

                // Validate state if provided
                <span class="cov2" title="2">if state != "" &amp;&amp; state != TaskStateResolved &amp;&amp; state != TaskStateUnresolved </span><span class="cov1" title="1">{
                        return mcp.NewToolResultError("State must be either RESOLVED or UNRESOLVED"), nil
                }</span>

                // Create parameters for the service layer
                <span class="cov1" title="1">params := app.BitbucketCreateTaskParams{
                        PullRequestID: prID,
                        Content:       content,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                        State:         state,
                        CommentID:     commentID,
                }

                // Call the service to create the task
                task, err := bc.bitbucketService.CreateTask(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create task: %w", err)
                }</span>

                // Format response text
                <span class="cov1" title="1">var responseText string
                if task.Comment != nil </span><span class="cov0" title="0">{
                        responseText = fmt.Sprintf("Created task on PR #%d: %s (on comment #%d)",
                                prID, task.Content.Raw, task.Comment.ID)
                }</span> else<span class="cov1" title="1"> {
                        responseText = fmt.Sprintf("Created task on PR #%d: %s", prID, task.Content.Raw)
                }</span>

                <span class="cov1" title="1">return mcp.NewToolResultText(responseText), nil</span>
        }
}

// NewTools returns the tools for this controller.
func (bc *BitbucketController) NewTools() []server.ServerTool <span class="cov3" title="3">{
        return []server.ServerTool{
                bc.newCreatePRServerTool(),
                bc.newReadPRServerTool(),
                bc.newUpdatePRServerTool(),
                bc.newApprovePRServerTool(),
                bc.newMergePRServerTool(),
                bc.newListPRTasksServerTool(),
                bc.newUpdatePRTaskServerTool(),
                bc.newCreatePRTaskServerTool(),
                bc.newGetPRDiffstatServerTool(),
                bc.newGetPRDiffServerTool(),
                bc.newAddPRCommentServerTool(),
                bc.newGetFileContentServerTool(),
                bc.newRequestPRChangesServerTool(),
                bc.newListPRCommentsServerTool(),
        }
}</span>

// newGetPRDiffstatServerTool returns a server tool for getting PR diffstat.
func (bc *BitbucketController) newGetPRDiffstatServerTool() server.ServerTool <span class="cov5" title="9">{
        tool := mcp.NewTool(
                "bitbucket_get_pr_diffstat",
                mcp.WithDescription("Get the diffstat for a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov4" title="5">{
                bc.logger.Debug("Received bitbucket_get_pr_diffstat request", "params", request.Params)

                // Extract required parameters
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>
                <span class="cov3" title="4">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>
                <span class="cov3" title="4">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>
                <span class="cov3" title="4">account := request.GetString("account", "")

                // Build params for service layer
                params := app.BitbucketGetPRDiffStatParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                // Call the service
                result, err := bc.bitbucketService.GetPRDiffStat(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get diffstat: %w", err)
                }</span>

                // Marshal result to JSON
                <span class="cov3" title="3">resultJSON, err := json.MarshalIndent(result, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal diffstat to JSON: %w", err)
                }</span>

                // Create summary text
                <span class="cov3" title="3">summaryText := fmt.Sprintf("Diffstat for PR #%d: %d files changed", prID, result.Size)

                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },
                                mcp.NewTextContent(string(resultJSON)),
                        },
                }, nil</span>
        }

        <span class="cov5" title="9">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

/*
 * newGetPRDiffServerTool returns a server tool for getting PR diff.
 */
func (bc *BitbucketController) newGetPRDiffServerTool() server.ServerTool <span class="cov5" title="8">{
        tool := mcp.NewTool(
                "bitbucket_get_pr_diff",
                mcp.WithDescription("Get the diff for a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
                mcp.WithString("file_paths",
                        mcp.Description("List of file paths to filter the diff (optional, multiple comma-separated values are possible)"),
                ),
                mcp.WithNumber("context_lines",
                        mcp.Description("Number of context lines to include in the diff (optional)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov3" title="4">{
                bc.logger.Debug("Received bitbucket_get_pr_diff request", "params", request.Params)

                // Extract required parameters
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>
                <span class="cov3" title="3">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>
                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>
                <span class="cov3" title="3">account := request.GetString("account", "")

                // Extract optional file_paths and context_lines using idiomatic helpers
                filePathsStr := request.GetString("file_paths", "")
                var filePaths []string
                if filePathsStr != "" </span><span class="cov1" title="1">{
                        parts := strings.Split(filePathsStr, ",")
                        for _, s := range parts </span><span class="cov2" title="2">{
                                s = strings.TrimSpace(s)
                                if s != "" </span><span class="cov2" title="2">{
                                        filePaths = append(filePaths, s)
                                }</span>
                        }
                }
                <span class="cov3" title="3">var contextLines *int
                if cl := request.GetInt("context_lines", 0); cl != 0 </span><span class="cov1" title="1">{
                        contextLines = &amp;cl
                }</span>

                // Build params for service layer
                <span class="cov3" title="3">params := app.BitbucketGetPRDiffParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                        FilePaths:     filePaths,
                        ContextLines:  contextLines,
                }

                // Call the service
                diff, err := bc.bitbucketService.GetPRDiff(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get diff: %w", err)
                }</span>

                // Create summary text
                <span class="cov2" title="2">summaryText := fmt.Sprintf("Diff for PR #%d in %s/%s", prID, repoOwner, repoName)

                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },
                                mcp.NewTextContent(diff),
                        },
                }, nil</span>
        }

        <span class="cov5" title="8">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newGetFileContentServerTool returns a server tool for getting file content from a Bitbucket repository.
func (bc *BitbucketController) newGetFileContentServerTool() server.ServerTool <span class="cov5" title="8">{
        tool := mcp.NewTool(
                "bitbucket_get_file_content",
                mcp.WithDescription("Get the content of a file in a Bitbucket repository"),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("file_path",
                        mcp.Description("Path to the file in the repository"),
                        mcp.Required(),
                ),
                mcp.WithString("commit_hash",
                        mcp.Description("The SHA hash to fetch file content from. Only commit hashes are supported."),
                        mcp.Required(),
                ),
        )
        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov3" title="4">{
                bc.logger.Debug("Received bitbucket_get_file_content request", "params", request.Params)

                repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>
                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>
                <span class="cov3" title="3">filePath := request.GetString("file_path", "")
                if filePath == "" </span><span class="cov3" title="3">{
                        filePath = request.GetString("path", "")
                }</span>
                <span class="cov3" title="3">if filePath == "" </span><span class="cov0" title="0">{
                        return mcp.NewToolResultError(
                                "Missing or invalid file_path parameter: required argument \"file_path\" not found",
                        ), nil
                }</span>
                <span class="cov3" title="3">commitHash, err := request.RequireString("commit_hash")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid commit_hash parameter", err), nil
                }</span>
                <span class="cov2" title="2">account := request.GetString("account", "")

                params := app.BitbucketGetFileContentParams{
                        AccountName: account,
                        RepoOwner:   repoOwner,
                        RepoName:    repoName,
                        Commit:      commitHash,
                        Path:        filePath,
                }

                result, err := bc.bitbucketService.GetFileContent(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get file content: %w", err)
                }</span>

                // Compose summary
                <span class="cov1" title="1">summaryText := fmt.Sprintf("File content for %s at %s/%s", filePath, repoOwner, repoName)

                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },
                                mcp.NewTextContent(result.Content),
                        },
                }, nil</span>
        }
        <span class="cov5" title="8">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newAddPRCommentServerTool returns a server tool for adding a comment to a pull request.
func (bc *BitbucketController) newAddPRCommentServerTool() server.ServerTool <span class="cov3" title="4">{
        tool := mcp.NewTool(
                "bitbucket_add_pr_comment",
                mcp.WithDescription("Add a comment to a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("comment_text",
                        mcp.Description("The comment content"),
                        mcp.Required(),
                ),
                mcp.WithString("file_path",
                        mcp.Description("Path to the file for inline comments (optional)"),
                ),
                mcp.WithNumber("line_number_from",
                        mcp.Description("Anchor line in the old version of the file (optional)"),
                ),
                mcp.WithNumber("line_number_to",
                        mcp.Description("Anchor line in the new version of the file (optional)"),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
                mcp.WithBoolean("pending",
                        mcp.Description("Create as a pending comment (optional, defaults to false)"),
                ),
        )
        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov1" title="1">{
                bc.logger.Debug("Received bitbucket_add_pr_comment request", "params", request.Params)

                // Required parameters
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>
                <span class="cov1" title="1">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>
                <span class="cov1" title="1">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>
                <span class="cov1" title="1">account := request.GetString("account", "")
                commentText, err := request.RequireString("comment_text")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid comment_text parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov1" title="1">filePath := request.GetString("file_path", "")
                lineFrom := request.GetInt("line_number_from", 0)
                lineTo := request.GetInt("line_number_to", 0)
                pending := request.GetBool("pending", false)

                params := app.BitbucketAddPRCommentParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                        Content:       commentText,
                        FilePath:      filePath,
                        LineFrom:      lineFrom,
                        LineTo:        lineTo,
                        Pending:       pending,
                }

                commentID, content, err := bc.bitbucketService.AddPRComment(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add PR comment: %w", err)
                }</span>

                <span class="cov1" title="1">resultText := fmt.Sprintf("Added comment #%d: %s", commentID, content)
                return mcp.NewToolResultText(resultText), nil</span>
        }
        <span class="cov3" title="4">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newRequestPRChangesServerTool returns a server tool for requesting changes on a pull request.

func (bc *BitbucketController) newRequestPRChangesServerTool() server.ServerTool <span class="cov3" title="4">{
        tool := mcp.NewTool(
                "bitbucket_request_pr_changes",
                mcp.WithDescription("Request changes on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )
        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov1" title="1">{
                bc.logger.Debug("Received bitbucket_request_pr_changes request", "params", request.Params)

                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>
                <span class="cov1" title="1">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>
                <span class="cov1" title="1">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>
                <span class="cov1" title="1">account := request.GetString("account", "")

                params := app.BitbucketRequestPRChangesParams{
                        PullRequestID: prID,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                        AccountName:   account,
                }

                status, timestamp, err := bc.bitbucketService.RequestPRChanges(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to request PR changes: %w", err)
                }</span>

                <span class="cov1" title="1">return mcp.NewToolResultText(
                        fmt.Sprintf("Requested changes for pull request #%d: %s at %v", prID, status, timestamp),
                ), nil</span>
        }
        <span class="cov3" title="4">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}

// newListPRCommentsServerTool returns a server tool for listing comments on a pull request.
func (bc *BitbucketController) newListPRCommentsServerTool() server.ServerTool <span class="cov4" title="7">{
        tool := mcp.NewTool(
                "bitbucket_list_pr_comments",
                mcp.WithDescription("List all comments on a pull request in Bitbucket"),
                mcp.WithNumber("pr_id",
                        mcp.Description("Pull request ID"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_owner",
                        mcp.Description("Repository owner (username/workspace)"),
                        mcp.Required(),
                ),
                mcp.WithString("repo_name",
                        mcp.Description("Repository name (slug)"),
                        mcp.Required(),
                ),
                mcp.WithString("account",
                        mcp.Description("Atlassian account name to use (optional, uses default if not specified)"),
                ),
        )

        handler := func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov3" title="4">{
                bc.logger.Debug("Received bitbucket_list_pr_comments request", "params", request.Params)

                // Extract required parameters using RequireXXX methods
                prID, err := request.RequireInt("pr_id")
                if err != nil </span><span class="cov1" title="1">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid pr_id parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoOwner, err := request.RequireString("repo_owner")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_owner parameter", err), nil
                }</span>

                <span class="cov3" title="3">repoName, err := request.RequireString("repo_name")
                if err != nil </span><span class="cov0" title="0">{
                        return mcp.NewToolResultErrorFromErr("Missing or invalid repo_name parameter", err), nil
                }</span>

                // Optional parameters
                <span class="cov3" title="3">account := request.GetString("account", "")

                // Create parameters for the service layer
                params := app.BitbucketListPRCommentsParams{
                        PullRequestID: prID,
                        AccountName:   account,
                        RepoOwner:     repoOwner,
                        RepoName:      repoName,
                }

                // Call the service to list PR comments
                comments, err := bc.bitbucketService.ListPRComments(ctx, params)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to list PR comments: %w", err)
                }</span>

                // Convert comments to JSON for the resource
                <span class="cov2" title="2">commentsJSON, err := json.MarshalIndent(comments, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal PR comments to JSON: %w", err)
                }</span>

                // Create a summary text for the comments
                <span class="cov2" title="2">summaryText := fmt.Sprintf("Found %d comments on pull request #%d", len(comments.Values), prID)

                // Return both a summary text and the full comments data as a resource
                return &amp;mcp.CallToolResult{
                        Content: []mcp.Content{
                                mcp.TextContent{
                                        Type: "text",
                                        Text: summaryText,
                                },

                                // Sending json as text since some clients (Cursor)
                                // do not support resources (at least not yet)
                                mcp.NewTextContent(string(commentsJSON)),
                        },
                }, nil</span>
        }

        <span class="cov4" title="7">return server.ServerTool{
                Tool:    tool,
                Handler: handler,
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package controllers

import (
        context "context"

        app "github.com/gemyago/atlacp/internal/app"
        bitbucket "github.com/gemyago/atlacp/internal/services/bitbucket"

        mock "github.com/stretchr/testify/mock"

        time "time"
)

// MockbitbucketService is an autogenerated mock type for the bitbucketService type
type MockbitbucketService struct {
        mock.Mock
}

type MockbitbucketService_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketService) EXPECT() *MockbitbucketService_Expecter <span class="cov8" title="38">{
        return &amp;MockbitbucketService_Expecter{mock: &amp;_m.Mock}
}</span>

// AddPRComment provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) AddPRComment(ctx context.Context, params app.BitbucketAddPRCommentParams) (int64, string, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddPRComment")</span>
        }

        <span class="cov1" title="1">var r0 int64
        var r1 string
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketAddPRCommentParams) (int64, string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketAddPRCommentParams) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketAddPRCommentParams) string); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Get(1).(string)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(2).(func(context.Context, app.BitbucketAddPRCommentParams) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov1" title="1">return r0, r1, r2</span>
}

// MockbitbucketService_AddPRComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPRComment'
type MockbitbucketService_AddPRComment_Call struct {
        *mock.Call
}

// AddPRComment is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketAddPRCommentParams
func (_e *MockbitbucketService_Expecter) AddPRComment(ctx interface{}, params interface{}) *MockbitbucketService_AddPRComment_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketService_AddPRComment_Call{Call: _e.mock.On("AddPRComment", ctx, params)}
}</span>

func (_c *MockbitbucketService_AddPRComment_Call) Run(run func(ctx context.Context, params app.BitbucketAddPRCommentParams)) *MockbitbucketService_AddPRComment_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketAddPRCommentParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_AddPRComment_Call) Return(_a0 int64, _a1 string, _a2 error) *MockbitbucketService_AddPRComment_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockbitbucketService_AddPRComment_Call) RunAndReturn(run func(context.Context, app.BitbucketAddPRCommentParams) (int64, string, error)) *MockbitbucketService_AddPRComment_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ApprovePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ApprovePR(ctx context.Context, params app.BitbucketApprovePRParams) (*bitbucket.Participant, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ApprovePR")</span>
        }

        <span class="cov2" title="2">var r0 *bitbucket.Participant
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketApprovePRParams) (*bitbucket.Participant, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketApprovePRParams) *bitbucket.Participant); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                if ret.Get(0) != nil </span><span class="cov2" title="2">{
                        r0 = ret.Get(0).(*bitbucket.Participant)
                }</span>
        }

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketApprovePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockbitbucketService_ApprovePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApprovePR'
type MockbitbucketService_ApprovePR_Call struct {
        *mock.Call
}

// ApprovePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketApprovePRParams
func (_e *MockbitbucketService_Expecter) ApprovePR(ctx interface{}, params interface{}) *MockbitbucketService_ApprovePR_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketService_ApprovePR_Call{Call: _e.mock.On("ApprovePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_ApprovePR_Call) Run(run func(ctx context.Context, params app.BitbucketApprovePRParams)) *MockbitbucketService_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketApprovePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ApprovePR_Call) Return(_a0 *bitbucket.Participant, _a1 error) *MockbitbucketService_ApprovePR_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ApprovePR_Call) RunAndReturn(run func(context.Context, app.BitbucketApprovePRParams) (*bitbucket.Participant, error)) *MockbitbucketService_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) CreatePR(ctx context.Context, params app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketCreatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_CreatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePR'
type MockbitbucketService_CreatePR_Call struct {
        *mock.Call
}

// CreatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketCreatePRParams
func (_e *MockbitbucketService_Expecter) CreatePR(ctx interface{}, params interface{}) *MockbitbucketService_CreatePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_CreatePR_Call{Call: _e.mock.On("CreatePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_CreatePR_Call) Run(run func(ctx context.Context, params app.BitbucketCreatePRParams)) *MockbitbucketService_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketCreatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_CreatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_CreatePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_CreatePR_Call) RunAndReturn(run func(context.Context, app.BitbucketCreatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateTask provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) CreateTask(ctx context.Context, params app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateTask")</span>
        }

        <span class="cov1" title="1">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketCreateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketCreateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockbitbucketService_CreateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTask'
type MockbitbucketService_CreateTask_Call struct {
        *mock.Call
}

// CreateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketCreateTaskParams
func (_e *MockbitbucketService_Expecter) CreateTask(ctx interface{}, params interface{}) *MockbitbucketService_CreateTask_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketService_CreateTask_Call{Call: _e.mock.On("CreateTask", ctx, params)}
}</span>

func (_c *MockbitbucketService_CreateTask_Call) Run(run func(ctx context.Context, params app.BitbucketCreateTaskParams)) *MockbitbucketService_CreateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketCreateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_CreateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketService_CreateTask_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_CreateTask_Call) RunAndReturn(run func(context.Context, app.BitbucketCreateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketService_CreateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetFileContent provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) GetFileContent(ctx context.Context, params app.BitbucketGetFileContentParams) (*bitbucket.FileContentResult, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetFileContent")</span>
        }

        <span class="cov2" title="2">var r0 *bitbucket.FileContentResult
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetFileContentParams) (*bitbucket.FileContentResult, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetFileContentParams) *bitbucket.FileContentResult); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                if ret.Get(0) != nil </span><span class="cov2" title="2">{
                        r0 = ret.Get(0).(*bitbucket.FileContentResult)
                }</span>
        }

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketGetFileContentParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockbitbucketService_GetFileContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileContent'
type MockbitbucketService_GetFileContent_Call struct {
        *mock.Call
}

// GetFileContent is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketGetFileContentParams
func (_e *MockbitbucketService_Expecter) GetFileContent(ctx interface{}, params interface{}) *MockbitbucketService_GetFileContent_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketService_GetFileContent_Call{Call: _e.mock.On("GetFileContent", ctx, params)}
}</span>

func (_c *MockbitbucketService_GetFileContent_Call) Run(run func(ctx context.Context, params app.BitbucketGetFileContentParams)) *MockbitbucketService_GetFileContent_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketGetFileContentParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_GetFileContent_Call) Return(_a0 *bitbucket.FileContentResult, _a1 error) *MockbitbucketService_GetFileContent_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_GetFileContent_Call) RunAndReturn(run func(context.Context, app.BitbucketGetFileContentParams) (*bitbucket.FileContentResult, error)) *MockbitbucketService_GetFileContent_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPRDiff provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) GetPRDiff(ctx context.Context, params app.BitbucketGetPRDiffParams) (string, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPRDiff")</span>
        }

        <span class="cov3" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetPRDiffParams) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetPRDiffParams) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketGetPRDiffParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_GetPRDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPRDiff'
type MockbitbucketService_GetPRDiff_Call struct {
        *mock.Call
}

// GetPRDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketGetPRDiffParams
func (_e *MockbitbucketService_Expecter) GetPRDiff(ctx interface{}, params interface{}) *MockbitbucketService_GetPRDiff_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_GetPRDiff_Call{Call: _e.mock.On("GetPRDiff", ctx, params)}
}</span>

func (_c *MockbitbucketService_GetPRDiff_Call) Run(run func(ctx context.Context, params app.BitbucketGetPRDiffParams)) *MockbitbucketService_GetPRDiff_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketGetPRDiffParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_GetPRDiff_Call) Return(_a0 string, _a1 error) *MockbitbucketService_GetPRDiff_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_GetPRDiff_Call) RunAndReturn(run func(context.Context, app.BitbucketGetPRDiffParams) (string, error)) *MockbitbucketService_GetPRDiff_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPRDiffStat provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) GetPRDiffStat(ctx context.Context, params app.BitbucketGetPRDiffStatParams) (*app.PaginatedDiffStat, error) <span class="cov3" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPRDiffStat")</span>
        }

        <span class="cov3" title="4">var r0 *app.PaginatedDiffStat
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetPRDiffStatParams) (*app.PaginatedDiffStat, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="4">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketGetPRDiffStatParams) *app.PaginatedDiffStat); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="4"> {
                if ret.Get(0) != nil </span><span class="cov3" title="4">{
                        r0 = ret.Get(0).(*app.PaginatedDiffStat)
                }</span>
        }

        <span class="cov3" title="4">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketGetPRDiffStatParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="4">return r0, r1</span>
}

// MockbitbucketService_GetPRDiffStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPRDiffStat'
type MockbitbucketService_GetPRDiffStat_Call struct {
        *mock.Call
}

// GetPRDiffStat is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketGetPRDiffStatParams
func (_e *MockbitbucketService_Expecter) GetPRDiffStat(ctx interface{}, params interface{}) *MockbitbucketService_GetPRDiffStat_Call <span class="cov3" title="4">{
        return &amp;MockbitbucketService_GetPRDiffStat_Call{Call: _e.mock.On("GetPRDiffStat", ctx, params)}
}</span>

func (_c *MockbitbucketService_GetPRDiffStat_Call) Run(run func(ctx context.Context, params app.BitbucketGetPRDiffStatParams)) *MockbitbucketService_GetPRDiffStat_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketGetPRDiffStatParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_GetPRDiffStat_Call) Return(_a0 *app.PaginatedDiffStat, _a1 error) *MockbitbucketService_GetPRDiffStat_Call <span class="cov3" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_GetPRDiffStat_Call) RunAndReturn(run func(context.Context, app.BitbucketGetPRDiffStatParams) (*app.PaginatedDiffStat, error)) *MockbitbucketService_GetPRDiffStat_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListPRComments provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ListPRComments(ctx context.Context, params app.BitbucketListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListPRComments")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.ListPRCommentsResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListPRCommentsParams) *bitbucket.ListPRCommentsResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.ListPRCommentsResponse)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketListPRCommentsParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_ListPRComments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPRComments'
type MockbitbucketService_ListPRComments_Call struct {
        *mock.Call
}

// ListPRComments is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketListPRCommentsParams
func (_e *MockbitbucketService_Expecter) ListPRComments(ctx interface{}, params interface{}) *MockbitbucketService_ListPRComments_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_ListPRComments_Call{Call: _e.mock.On("ListPRComments", ctx, params)}
}</span>

func (_c *MockbitbucketService_ListPRComments_Call) Run(run func(ctx context.Context, params app.BitbucketListPRCommentsParams)) *MockbitbucketService_ListPRComments_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketListPRCommentsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ListPRComments_Call) Return(_a0 *bitbucket.ListPRCommentsResponse, _a1 error) *MockbitbucketService_ListPRComments_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ListPRComments_Call) RunAndReturn(run func(context.Context, app.BitbucketListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error)) *MockbitbucketService_ListPRComments_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListTasks provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ListTasks(ctx context.Context, params app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListTasks")</span>
        }

        <span class="cov4" title="5">var r0 *bitbucket.PaginatedTasks
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketListTasksParams) *bitbucket.PaginatedTasks); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov4" title="5"> {
                if ret.Get(0) != nil </span><span class="cov4" title="5">{
                        r0 = ret.Get(0).(*bitbucket.PaginatedTasks)
                }</span>
        }

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketListTasksParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockbitbucketService_ListTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTasks'
type MockbitbucketService_ListTasks_Call struct {
        *mock.Call
}

// ListTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketListTasksParams
func (_e *MockbitbucketService_Expecter) ListTasks(ctx interface{}, params interface{}) *MockbitbucketService_ListTasks_Call <span class="cov4" title="5">{
        return &amp;MockbitbucketService_ListTasks_Call{Call: _e.mock.On("ListTasks", ctx, params)}
}</span>

func (_c *MockbitbucketService_ListTasks_Call) Run(run func(ctx context.Context, params app.BitbucketListTasksParams)) *MockbitbucketService_ListTasks_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketListTasksParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ListTasks_Call) Return(_a0 *bitbucket.PaginatedTasks, _a1 error) *MockbitbucketService_ListTasks_Call <span class="cov4" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ListTasks_Call) RunAndReturn(run func(context.Context, app.BitbucketListTasksParams) (*bitbucket.PaginatedTasks, error)) *MockbitbucketService_ListTasks_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MergePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) MergePR(ctx context.Context, params app.BitbucketMergePRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MergePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketMergePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketMergePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketMergePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_MergePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergePR'
type MockbitbucketService_MergePR_Call struct {
        *mock.Call
}

// MergePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketMergePRParams
func (_e *MockbitbucketService_Expecter) MergePR(ctx interface{}, params interface{}) *MockbitbucketService_MergePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_MergePR_Call{Call: _e.mock.On("MergePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_MergePR_Call) Run(run func(ctx context.Context, params app.BitbucketMergePRParams)) *MockbitbucketService_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketMergePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_MergePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_MergePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_MergePR_Call) RunAndReturn(run func(context.Context, app.BitbucketMergePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ReadPR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) ReadPR(ctx context.Context, params app.BitbucketReadPRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ReadPR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketReadPRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketReadPRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketReadPRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_ReadPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadPR'
type MockbitbucketService_ReadPR_Call struct {
        *mock.Call
}

// ReadPR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketReadPRParams
func (_e *MockbitbucketService_Expecter) ReadPR(ctx interface{}, params interface{}) *MockbitbucketService_ReadPR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_ReadPR_Call{Call: _e.mock.On("ReadPR", ctx, params)}
}</span>

func (_c *MockbitbucketService_ReadPR_Call) Run(run func(ctx context.Context, params app.BitbucketReadPRParams)) *MockbitbucketService_ReadPR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketReadPRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_ReadPR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_ReadPR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_ReadPR_Call) RunAndReturn(run func(context.Context, app.BitbucketReadPRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_ReadPR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RequestPRChanges provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) RequestPRChanges(ctx context.Context, params app.BitbucketRequestPRChangesParams) (string, time.Time, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RequestPRChanges")</span>
        }

        <span class="cov1" title="1">var r0 string
        var r1 time.Time
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketRequestPRChangesParams) (string, time.Time, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketRequestPRChangesParams) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketRequestPRChangesParams) time.Time); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Get(1).(time.Time)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(2).(func(context.Context, app.BitbucketRequestPRChangesParams) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, params)
        }</span> else<span class="cov1" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov1" title="1">return r0, r1, r2</span>
}

// MockbitbucketService_RequestPRChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestPRChanges'
type MockbitbucketService_RequestPRChanges_Call struct {
        *mock.Call
}

// RequestPRChanges is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketRequestPRChangesParams
func (_e *MockbitbucketService_Expecter) RequestPRChanges(ctx interface{}, params interface{}) *MockbitbucketService_RequestPRChanges_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketService_RequestPRChanges_Call{Call: _e.mock.On("RequestPRChanges", ctx, params)}
}</span>

func (_c *MockbitbucketService_RequestPRChanges_Call) Run(run func(ctx context.Context, params app.BitbucketRequestPRChangesParams)) *MockbitbucketService_RequestPRChanges_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketRequestPRChangesParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_RequestPRChanges_Call) Return(_a0 string, _a1 time.Time, _a2 error) *MockbitbucketService_RequestPRChanges_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockbitbucketService_RequestPRChanges_Call) RunAndReturn(run func(context.Context, app.BitbucketRequestPRChangesParams) (string, time.Time, error)) *MockbitbucketService_RequestPRChanges_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdatePR provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) UpdatePR(ctx context.Context, params app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="4">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePR")</span>
        }

        <span class="cov3" title="4">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="4">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="4"> {
                if ret.Get(0) != nil </span><span class="cov3" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="4">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketUpdatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="4">return r0, r1</span>
}

// MockbitbucketService_UpdatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePR'
type MockbitbucketService_UpdatePR_Call struct {
        *mock.Call
}

// UpdatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketUpdatePRParams
func (_e *MockbitbucketService_Expecter) UpdatePR(ctx interface{}, params interface{}) *MockbitbucketService_UpdatePR_Call <span class="cov3" title="4">{
        return &amp;MockbitbucketService_UpdatePR_Call{Call: _e.mock.On("UpdatePR", ctx, params)}
}</span>

func (_c *MockbitbucketService_UpdatePR_Call) Run(run func(ctx context.Context, params app.BitbucketUpdatePRParams)) *MockbitbucketService_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketUpdatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_UpdatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketService_UpdatePR_Call <span class="cov3" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_UpdatePR_Call) RunAndReturn(run func(context.Context, app.BitbucketUpdatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketService_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateTask provides a mock function with given fields: ctx, params
func (_m *MockbitbucketService) UpdateTask(ctx context.Context, params app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateTask")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, app.BitbucketUpdateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, app.BitbucketUpdateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketService_UpdateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTask'
type MockbitbucketService_UpdateTask_Call struct {
        *mock.Call
}

// UpdateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - params app.BitbucketUpdateTaskParams
func (_e *MockbitbucketService_Expecter) UpdateTask(ctx interface{}, params interface{}) *MockbitbucketService_UpdateTask_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketService_UpdateTask_Call{Call: _e.mock.On("UpdateTask", ctx, params)}
}</span>

func (_c *MockbitbucketService_UpdateTask_Call) Run(run func(ctx context.Context, params app.BitbucketUpdateTaskParams)) *MockbitbucketService_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(app.BitbucketUpdateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketService_UpdateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketService_UpdateTask_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketService_UpdateTask_Call) RunAndReturn(run func(context.Context, app.BitbucketUpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketService_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketService creates a new instance of MockbitbucketService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketService(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketService <span class="cov10" title="84">{
        mock := &amp;MockbitbucketService{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="84">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="84">return mock</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "github.com/gemyago/atlacp/internal/api/mcp/server"
        "github.com/gemyago/atlacp/internal/app"
        "github.com/gemyago/atlacp/internal/di"
        "go.uber.org/dig"
)

type controllerResult struct {
        dig.Out

        Controller server.ToolsFactory `group:"mcp-controllers"`
}

func newToolsFactory[T server.ToolsFactory](controller T) controllerResult <span class="cov10" title="2">{
        return controllerResult{
                Controller: controller,
        }
}</span>

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewBitbucketController,
                newToolsFactory[*BitbucketController],
                di.ProvideAs[*app.BitbucketService, bitbucketService],
        )
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "time"

        httpserver "github.com/gemyago/atlacp/internal/api/http/server"
        "github.com/gemyago/atlacp/internal/diag"
        "github.com/gemyago/atlacp/internal/services"
        "github.com/gofrs/uuid/v5"
        "github.com/mark3labs/mcp-go/mcp"
        mcpserver "github.com/mark3labs/mcp-go/server"
        "go.uber.org/dig"
)

// Constants for server configuration.
const (
        httpReadTimeout  = 5 * time.Second
        httpWriteTimeout = 0 // no timeout, for SSE transport best not to have it
        httpIdleTimeout  = 0 // no timeout, for SSE transport best not to have it
)

type ToolsFactory interface {
        NewTools() []mcpserver.ServerTool
}

type ToolsFactoryFunc func() []mcpserver.ServerTool

func (f ToolsFactoryFunc) NewTools() []mcpserver.ServerTool <span class="cov8" title="5">{
        return f()
}</span>

// MCPServerDeps contains dependencies for creating the MCP server.
type MCPServerDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        Name     string `name:"config.mcpServer.name"`
        Version  string `name:"config.mcpServer.version"`
        HTTPHost string `name:"config.mcpServer.httpHost"`
        HTTPPort int    `name:"config.mcpServer.httpPort"`

        // services
        *services.ShutdownHooks

        // controllers
        Controllers []ToolsFactory `group:"mcp-controllers"`
}

// ToolInfo contains information about a registered tool.
type ToolInfo struct {
        Tool    mcp.Tool
        Handler mcpserver.ToolHandlerFunc
}

// MCPServer wraps the mcp-go server with additional functionality.
type MCPServer struct {
        mcpServer     *mcpserver.MCPServer
        deps          MCPServerDeps
        logger        *slog.Logger
        shutdownHooks *services.ShutdownHooks
}

// NewMCPServer creates a new MCP server instance.
func NewMCPServer(deps MCPServerDeps) *MCPServer <span class="cov10" title="7">{
        logger := deps.RootLogger.WithGroup("mcp-server")

        mcpServer := mcpserver.NewMCPServer(
                deps.Name,
                deps.Version,
                mcpserver.WithToolCapabilities(true),
                mcpserver.WithToolHandlerMiddleware(
                        func(next mcpserver.ToolHandlerFunc) mcpserver.ToolHandlerFunc </span><span class="cov8" title="5">{
                                return func(ctx context.Context, req mcp.CallToolRequest) (*mcp.CallToolResult, error) </span><span class="cov8" title="5">{
                                        nextCtx := ctx
                                        diagCtx := diag.GetLogAttributesFromContext(nextCtx)

                                        // We may need to revisit this. It may be so that the diag context is always set
                                        // for the stdio transport at least.
                                        if diagCtx.CorrelationID.Kind() != slog.KindString </span><span class="cov6" title="3">{
                                                diagCtx.CorrelationID = slog.StringValue(uuid.Must(uuid.NewV4()).String())
                                                nextCtx = diag.SetLogAttributesToContext(nextCtx, diagCtx)
                                        }</span>

                                        // It may be quite verbose and we may want to log just the "processed" part.
                                        <span class="cov8" title="5">logger.InfoContext(nextCtx, "Processing tool call",
                                                slog.String("tool", req.Params.Name),
                                                slog.Any("params", req.Params),
                                                slog.Any("meta", req.Params.Meta),
                                        )

                                        res, err := next(nextCtx, req)
                                        if err != nil </span><span class="cov4" title="2">{
                                                diagCtx = diag.GetLogAttributesFromContext(nextCtx)
                                                correlationID := diagCtx.CorrelationID.String()

                                                logger.ErrorContext(nextCtx, "Error processing tool call",
                                                        slog.String("tool", req.Params.Name),
                                                        slog.Any("error", err),
                                                )

                                                errorMessage := fmt.Sprintf("Error details: %s; CorrelationID: %s", err.Error(), correlationID)
                                                return mcp.NewToolResultError(errorMessage), nil
                                        }</span>

                                        <span class="cov6" title="3">logger.InfoContext(nextCtx, "Tool call processed",
                                                slog.String("tool", req.Params.Name),
                                        )
                                        return res, nil</span>
                                }
                        },
                ),
                mcpserver.WithRecovery(),
        )

        <span class="cov10" title="7">mcpSrv := &amp;MCPServer{
                deps:          deps,
                mcpServer:     mcpServer,
                logger:        deps.RootLogger.WithGroup("mcp-server"),
                shutdownHooks: deps.ShutdownHooks,
        }

        for _, controller := range deps.Controllers </span><span class="cov10" title="7">{
                tools := controller.NewTools()
                mcpSrv.mcpServer.AddTools(tools...)
        }</span>

        <span class="cov10" title="7">return mcpSrv</span>
}

// ListenStdioServer starts the MCP server with stdio transport.
func (s *MCPServer) ListenStdioServer(
        ctx context.Context,
        stdin io.Reader,
        stdout io.Writer,
) error <span class="cov0" title="0">{ // coverage-ignore -- Challenging to test this
        stdioSrv := mcpserver.NewStdioServer(s.mcpServer)
        s.logger.InfoContext(ctx, "Starting MCP server with stdio transport",
                slog.String("name", s.deps.Name),
                slog.String("version", s.deps.Version))

        return stdioSrv.Listen(ctx, stdin, stdout)
}</span>

// NewHTTPServer creates a new HTTP server with streamable and SSE handlers.
func (s *MCPServer) NewHTTPServer() *httpserver.HTTPServer <span class="cov1" title="1">{
        rootHandler := http.NewServeMux()

        rootHandler.Handle("/", mcpserver.NewStreamableHTTPServer(
                s.mcpServer,
                mcpserver.WithStateLess(true),
        ))

        sseServer := mcpserver.NewSSEServer(
                s.mcpServer,
                mcpserver.WithSSEEndpoint("/sse/"),
                mcpserver.WithMessageEndpoint("/sse/message"),
        )
        rootHandler.Handle("/sse", sseServer.SSEHandler())
        rootHandler.Handle("/sse/message", sseServer.MessageHandler())

        return httpserver.NewHTTPServer(httpserver.HTTPServerDeps{
                RootLogger: s.logger,

                Host:              s.deps.HTTPHost,
                Port:              s.deps.HTTPPort,
                IdleTimeout:       httpIdleTimeout,
                ReadHeaderTimeout: httpReadTimeout,
                ReadTimeout:       httpReadTimeout,
                WriteTimeout:      httpWriteTimeout,

                ShutdownHooks: s.shutdownHooks,
                Handler:       rootHandler,
        })
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">//go:build !release

package server

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "sync"

        "github.com/mark3labs/mcp-go/client"
        "github.com/mark3labs/mcp-go/client/transport"
        "github.com/mark3labs/mcp-go/mcp"
        mcpserver "github.com/mark3labs/mcp-go/server"
)

// testMCPServer encapsulates an MCP server and manages resources like pipes and context.
type testMCPServer struct {
        serverReader *io.PipeReader
        serverWriter *io.PipeWriter
        clientReader *io.PipeReader
        clientWriter *io.PipeWriter

        logBuffer bytes.Buffer

        transport transport.Interface
        client    *client.Client

        wg sync.WaitGroup
}

// newTestMCPServer creates a new MCP server instance with the given name, but does not start the server.
// Useful for tests where you need to add tools before starting the server.
func newTestMCPServer() *testMCPServer <span class="cov10" title="5">{
        server := &amp;testMCPServer{}

        // Set up pipes for client-server communication
        server.serverReader, server.clientWriter = io.Pipe()
        server.clientReader, server.serverWriter = io.Pipe()

        // Return the configured server
        return server
}</span>

// Start starts the server in a goroutine. Make sure to defer Close() after Start().
// When using NewServer(), the returned server is already started.
func (s *testMCPServer) Start(
        ctx context.Context,
        mcpServer *mcpserver.MCPServer,
) error <span class="cov10" title="5">{
        s.wg.Add(1)

        go func() </span><span class="cov10" title="5">{
                defer s.wg.Done()

                logger := log.New(&amp;s.logBuffer, "", 0)

                stdioServer := mcpserver.NewStdioServer(mcpServer)
                stdioServer.SetErrorLogger(logger)

                if err := stdioServer.Listen(ctx, s.serverReader, s.serverWriter); err != nil </span><span class="cov10" title="5">{
                        logger.Println("StdioServer.Listen failed:", err)
                }</span>
        }()

        <span class="cov10" title="5">s.transport = transport.NewIO(s.clientReader, s.clientWriter, io.NopCloser(&amp;s.logBuffer))
        if err := s.transport.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transport.Start(): %w", err)
        }</span>

        <span class="cov10" title="5">s.client = client.NewClient(s.transport)

        var initReq mcp.InitializeRequest
        initReq.Params.ProtocolVersion = mcp.LATEST_PROTOCOL_VERSION
        if _, err := s.client.Initialize(ctx, initReq); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client.Initialize(): %w", err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

// Client returns an MCP client connected to the server.
// The client is already initialized, i.e. you do _not_ need to call Client.Initialize().
func (s *testMCPServer) Client() *client.Client <span class="cov10" title="5">{
        return s.client
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">//go:build !release

package app

import (
        "github.com/go-faker/faker/v4"
)

// AtlassianAccountOpt is a function that configures an AtlassianAccount.
type AtlassianAccountOpt func(*AtlassianAccount)

// WithAtlassianAccountDefault sets the account as default.
func WithAtlassianAccountDefault(isDefault bool) AtlassianAccountOpt <span class="cov4" title="5">{
        return func(a *AtlassianAccount) </span><span class="cov4" title="5">{
                a.Default = isDefault
        }</span>
}

// WithAtlassianAccountName sets the account name.
func WithAtlassianAccountName(name string) AtlassianAccountOpt <span class="cov6" title="9">{
        return func(a *AtlassianAccount) </span><span class="cov6" title="9">{
                a.Name = name
        }</span>
}

// WithAtlassianAccountBitbucket adds a Bitbucket configuration to the account.
func WithAtlassianAccountBitbucket(opts ...AtlassianTokenOpt) AtlassianAccountOpt <span class="cov0" title="0">{
        return func(a *AtlassianAccount) </span><span class="cov0" title="0">{
                a.Bitbucket = NewRandomAtlassianToken(opts...)
        }</span>
}

// WithAtlassianAccountJira adds a Jira configuration to the account.
func WithAtlassianAccountJira(opts ...AtlassianTokenOpt) AtlassianAccountOpt <span class="cov0" title="0">{
        return func(a *AtlassianAccount) </span><span class="cov0" title="0">{
                a.Jira = NewRandomAtlassianToken(opts...)
        }</span>
}

// BitbucketAccountOpt is a function that configures a BitbucketAccount.
type AtlassianTokenOpt func(*AtlassianToken)

// WithBitbucketAccountToken sets the Bitbucket token.
func WithBitbucketAccountToken(token string) AtlassianTokenOpt <span class="cov0" title="0">{
        return func(b *AtlassianToken) </span><span class="cov0" title="0">{
                b.Value = token
        }</span>
}

// WithBitbucketAccountTokenType sets the Bitbucket token type.
func WithBitbucketAccountTokenType(tokenType string) AtlassianTokenOpt <span class="cov0" title="0">{
        return func(b *AtlassianToken) </span><span class="cov0" title="0">{
                b.Type = tokenType
        }</span>
}

// NewRandomAtlassianAccount generates a random AtlassianAccount for testing.
// Options can be used to customize the account.
func NewRandomAtlassianAccount(opts ...AtlassianAccountOpt) AtlassianAccount <span class="cov8" title="23">{
        account := AtlassianAccount{
                Name:      faker.Name(),
                Bitbucket: NewRandomAtlassianToken(),
                Jira:      NewRandomAtlassianToken(),
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov7" title="14">{
                opt(&amp;account)
        }</span>

        <span class="cov8" title="23">return account</span>
}

// NewRandomBitbucketAccount generates a random BitbucketAccount for testing.
func NewRandomAtlassianToken(opts ...AtlassianTokenOpt) *AtlassianToken <span class="cov10" title="46">{
        account := &amp;AtlassianToken{
                Type:  faker.Word(),
                Value: faker.UUIDHyphenated(),
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(account)
        }</span>

        <span class="cov10" title="46">return account</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "context"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// staticTokenProvider provides a static token for authentication.
type staticTokenProvider struct {
        token string
}

// newStaticTokenProvider creates a new provider that returns a static token.
func newStaticTokenProvider(token string) *staticTokenProvider <span class="cov10" title="43">{
        return &amp;staticTokenProvider{token: token}
}</span>

// GetToken returns the static token.
func (p *staticTokenProvider) GetToken(_ context.Context) (middleware.Token, error) <span class="cov3" title="3">{
        return middleware.Token{Type: "Bearer", Value: p.token}, nil
}</span>

type tokenProviderFunc func(ctx context.Context) (middleware.Token, error)

func (f tokenProviderFunc) GetToken(ctx context.Context) (middleware.Token, error) <span class="cov5" title="7">{
        return f(ctx)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package app

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "go.uber.org/dig"
)

// Task states.
const (
        // TaskStateResolved is the state value for a resolved task.
        TaskStateResolved = "RESOLVED"

        // TaskStateUnresolved is the state value for an unresolved task.
        TaskStateUnresolved = "UNRESOLVED"
)

// BitbucketService provides business logic for Bitbucket operations.
type BitbucketService struct {
        client      bitbucketClient
        authFactory bitbucketAuthFactory
        logger      *slog.Logger
}

// BitbucketServiceDeps contains dependencies for the Bitbucket service.
type BitbucketServiceDeps struct {
        dig.In

        Client      bitbucketClient
        AuthFactory bitbucketAuthFactory
        RootLogger  *slog.Logger
}

// NewBitbucketService creates a new Bitbucket service.
func NewBitbucketService(deps BitbucketServiceDeps) *BitbucketService <span class="cov10" title="54">{
        return &amp;BitbucketService{
                client:      deps.Client,
                authFactory: deps.AuthFactory,
                logger:      deps.RootLogger.WithGroup("app.bitbucket-service"),
        }
}</span>

// BitbucketCreatePRParams contains parameters for creating a pull request.
type BitbucketCreatePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Title of the pull request
        Title string `json:"title"`

        // Description of the pull request
        Description string `json:"description"`

        // Source branch name
        SourceBranch string `json:"source_branch"`

        // Destination branch name
        DestBranch string `json:"dest_branch"`

        // Whether to close the source branch after merging
        CloseSourceBranch bool `json:"close_source_branch"`

        // Reviewer usernames (optional)
        Reviewers []string `json:"reviewers,omitempty"`

        // Whether to create the pull request as a draft
        Draft *bool `json:"draft,omitempty"`
}

// BitbucketReadPRParams contains parameters for retrieving a pull request.
type BitbucketReadPRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

// BitbucketUpdatePRParams contains parameters for updating a pull request.
type BitbucketUpdatePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Updated title (optional)
        Title string `json:"title,omitempty"`

        // Updated description (optional)
        Description string `json:"description,omitempty"`

        // Whether to update the pull request as a draft
        Draft *bool `json:"draft,omitempty"`
}

// BitbucketApprovePRParams contains parameters for approving a pull request.
type BitbucketApprovePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

type BitbucketRequestPRChangesParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

// BitbucketMergePRParams contains parameters for merging a pull request.
type BitbucketMergePRParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Merge commit message (optional)
        Message string `json:"message,omitempty"`

        // Whether to close the source branch after merging
        CloseSourceBranch bool `json:"close_source_branch"`

        // Merge strategy (merge_commit, squash, fast_forward)
        MergeStrategy string `json:"merge_strategy,omitempty"`
}

// BitbucketListTasksParams contains parameters for listing tasks on a pull request.
type BitbucketListTasksParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Optional query to filter tasks (optional)
        Query string `json:"query,omitempty"`

        // Sort order for tasks (optional)
        Sort string `json:"sort,omitempty"`

        // Maximum number of tasks to return per page (optional)
        PageLen int `json:"page_len,omitempty"`
}

// BitbucketUpdateTaskParams contains parameters for updating a task on a pull request.
type BitbucketUpdateTaskParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Task ID to update
        TaskID int `json:"task_id"`

        // Updated task content (optional)
        Content string `json:"content,omitempty"`

        // Updated task state: "RESOLVED" or "UNRESOLVED" (optional)
        State string `json:"state,omitempty"`
}

// BitbucketCreateTaskParams contains parameters for creating a task on a pull request.
type BitbucketCreateTaskParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`

        // Task content
        Content string `json:"content"`

        // Comment ID to associate with the task (optional)
        CommentID int64 `json:"comment_id,omitempty"`

        // Task state: "RESOLVED" or "UNRESOLVED" (optional)
        // If not provided, defaults to "UNRESOLVED"
        State string `json:"state,omitempty"`
}

// BitbucketListPRCommentsParams contains parameters for listing comments on a pull request.
type BitbucketListPRCommentsParams struct {
        // Account name to use for authentication (optional, uses default if empty)
        AccountName string `json:"account_name,omitempty"`

        // Repository owner (username/workspace)
        RepoOwner string `json:"repo_owner"`

        // Repository name (slug)
        RepoName string `json:"repo_name"`

        // Pull request ID
        PullRequestID int `json:"pull_request_id"`
}

// CreatePR creates a new pull request.
func (s *BitbucketService) CreatePR(
        ctx context.Context,
        params BitbucketCreatePRParams,
) (*bitbucket.PullRequest, error) <span class="cov5" title="9">{
        s.logger.InfoContext(ctx, "Creating pull request",
                slog.String("repo", params.RepoName),
                slog.String("source", params.SourceBranch),
                slog.String("dest", params.DestBranch))

        // Validate required parameters
        if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="8">if params.Title == "" </span><span class="cov1" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov5" title="7">if params.SourceBranch == "" </span><span class="cov1" title="1">{
                return nil, errors.New("source branch is required")
        }</span>
        <span class="cov5" title="6">if params.DestBranch == "" </span><span class="cov1" title="1">{
                return nil, errors.New("destination branch is required")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="5">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Build pull request object
        prRequest := &amp;bitbucket.PullRequest{
                Title:             params.Title,
                Description:       params.Description,
                CloseSourceBranch: params.CloseSourceBranch,
                Source: bitbucket.PullRequestSource{
                        Branch: bitbucket.PullRequestBranch{
                                Name: params.SourceBranch,
                        },
                },
                Destination: &amp;bitbucket.PullRequestDestination{
                        Branch: bitbucket.PullRequestBranch{
                                Name: params.DestBranch,
                        },
                },
                Draft: params.Draft,
        }

        // Add reviewers if specified
        if len(params.Reviewers) &gt; 0 </span><span class="cov1" title="1">{
                prRequest.Reviewers = make([]bitbucket.PullRequestAuthor, len(params.Reviewers))
                for i, reviewer := range params.Reviewers </span><span class="cov2" title="2">{
                        prRequest.Reviewers[i] = bitbucket.PullRequestAuthor{
                                Username: reviewer,
                        }
                }</span>
        }

        // Call the client to create the pull request
        <span class="cov4" title="5">return s.client.CreatePR(ctx, tokenProvider, bitbucket.CreatePRParams{
                Username: params.RepoOwner,
                RepoSlug: params.RepoName,
                Request:  prRequest,
        })</span>
}

// ReadPR retrieves a specific pull request.
func (s *BitbucketService) ReadPR(ctx context.Context, params BitbucketReadPRParams) (*bitbucket.PullRequest, error) <span class="cov5" title="6">{
        s.logger.InfoContext(ctx, "Reading pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="5">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="4">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov3" title="3">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to get the pull request
        pr, err := s.client.GetPR(ctx, tokenProvider, bitbucket.GetPRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get pull request: %w", err)
        }</span>

        <span class="cov2" title="2">return pr, nil</span>
}

// UpdatePR updates an existing pull request.
func (s *BitbucketService) UpdatePR(
        ctx context.Context,
        params BitbucketUpdatePRParams,
) (*bitbucket.PullRequest, error) <span class="cov5" title="9">{
        s.logger.InfoContext(ctx, "Updating pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="8">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="7">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov5" title="6">if params.Title == "" &amp;&amp; params.Description == "" &amp;&amp; params.Draft == nil </span><span class="cov1" title="1">{
                return nil, errors.New("either title, description or draft must be provided")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="5">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Create update request with provided fields
        updateRequest := &amp;bitbucket.PullRequest{
                Title:       params.Title,
                Description: params.Description,
                Draft:       params.Draft,
        }

        // Call the client to update the pull request
        pr, err := s.client.UpdatePR(ctx, tokenProvider, bitbucket.UpdatePRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
                Request:       updateRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update pull request: %w", err)
        }</span>

        <span class="cov4" title="4">return pr, nil</span>
}

// ApprovePR approves a pull request.
func (s *BitbucketService) ApprovePR(
        ctx context.Context,
        params BitbucketApprovePRParams,
) (*bitbucket.Participant, error) <span class="cov5" title="6">{
        s.logger.InfoContext(ctx, "Approving pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="5">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="4">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov3" title="3">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to approve the pull request
        participant, err := s.client.ApprovePR(ctx, tokenProvider, bitbucket.ApprovePRParams{
                Username:      params.RepoOwner,
                RepoSlug:      params.RepoName,
                PullRequestID: params.PullRequestID,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to approve pull request: %w", err)
        }</span>

        <span class="cov2" title="2">return participant, nil</span>
}

// RequestPRChanges requests changes on a pull request.
func (s *BitbucketService) RequestPRChanges(
        ctx context.Context,
        params BitbucketRequestPRChangesParams,
) (string, time.Time, error) <span class="cov4" title="4">{
        s.logger.InfoContext(ctx, "Requesting changes on pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID),
        )

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return "", time.Time{}, errors.New("repository owner is required")
        }</span>
        <span class="cov3" title="3">if params.RepoName == "" </span><span class="cov1" title="1">{
                return "", time.Time{}, errors.New("repository name is required")
        }</span>
        <span class="cov2" title="2">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return "", time.Time{}, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov1" title="1">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to request PR changes
        status, ts, err := s.client.RequestPRChanges(ctx, tokenProvider, bitbucket.RequestPRChangesParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", time.Time{}, err
        }</span>
        <span class="cov1" title="1">return status, ts, nil</span>
}

// MergePR merges a pull request.
func (s *BitbucketService) MergePR(ctx context.Context, params BitbucketMergePRParams) (*bitbucket.PullRequest, error) <span class="cov5" title="8">{
        s.logger.InfoContext(ctx, "Merging pull request",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID),
                slog.String("strategy", params.MergeStrategy))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="6">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Validate merge strategy if provided
        <span class="cov4" title="5">if params.MergeStrategy != "" &amp;&amp; !isValidMergeStrategy(params.MergeStrategy) </span><span class="cov1" title="1">{
                return nil, errors.New("invalid merge strategy: must be one of merge_commit, squash, or fast_forward")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Create merge parameters
        mergeParams := &amp;bitbucket.PullRequestMergeParameters{
                CloseSourceBranch: params.CloseSourceBranch,
                Message:           params.Message,
        }

        // Only add merge strategy if specified
        if params.MergeStrategy != "" </span><span class="cov3" title="3">{
                mergeParams.MergeStrategy = params.MergeStrategy
        }</span>

        // Call the client to merge the pull request
        <span class="cov4" title="4">pr, err := s.client.MergePR(ctx, tokenProvider, bitbucket.MergePRParams{
                Username:        params.RepoOwner,
                RepoSlug:        params.RepoName,
                PullRequestID:   params.PullRequestID,
                MergeParameters: mergeParams,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to merge pull request: %w", err)
        }</span>

        <span class="cov3" title="3">return pr, nil</span>
}

// isValidMergeStrategy checks if the provided merge strategy is valid.
func isValidMergeStrategy(strategy string) bool <span class="cov4" title="4">{
        validStrategies := map[string]bool{
                "merge_commit": true,
                "squash":       true,
                "fast_forward": true,
                "":             true, // Empty is valid, will use repo default
        }
        return validStrategies[strategy]
}</span>

// ListTasks retrieves a list of tasks for a specific pull request.
func (s *BitbucketService) ListTasks(
        ctx context.Context,
        params BitbucketListTasksParams,
) (*bitbucket.PaginatedTasks, error) <span class="cov5" title="7">{
        s.logger.InfoContext(ctx, "Listing pull request tasks",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="6">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov4" title="5">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to list tasks
        tasks, err := s.client.ListPullRequestTasks(ctx, tokenProvider, bitbucket.ListPullRequestTasksParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                Query:     params.Query,
                Sort:      params.Sort,
                PageLen:   params.PageLen,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to list pull request tasks: %w", err)
        }</span>

        <span class="cov3" title="3">return tasks, nil</span>
}

// UpdateTask updates a task on a pull request.
func (s *BitbucketService) UpdateTask(
        ctx context.Context,
        params BitbucketUpdateTaskParams,
) (*bitbucket.PullRequestCommentTask, error) <span class="cov5" title="9">{
        s.logger.InfoContext(ctx, "Updating pull request task",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID),
                slog.Int("task_id", params.TaskID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="8">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="7">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov5" title="6">if params.TaskID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("task ID must be positive")
        }</span>
        <span class="cov4" title="5">if params.Content == "" &amp;&amp; params.State == "" </span><span class="cov1" title="1">{
                return nil, errors.New("either content or state must be provided")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to update the task
        task, err := s.client.UpdateTask(ctx, tokenProvider, bitbucket.UpdateTaskParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                TaskID:    params.TaskID,
                Content:   params.Content,
                State:     params.State,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to update task: %w", err)
        }</span>

        <span class="cov3" title="3">return task, nil</span>
}

// CreateTask creates a new task on a pull request.
func (s *BitbucketService) CreateTask(
        ctx context.Context,
        params BitbucketCreateTaskParams,
) (*bitbucket.PullRequestCommentTask, error) <span class="cov5" title="8">{
        s.logger.InfoContext(ctx, "Creating task on pull request",
                slog.String("repo", params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov5" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov5" title="6">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>
        <span class="cov4" title="5">if params.Content == "" </span><span class="cov1" title="1">{
                return nil, errors.New("content is required")
        }</span>

        // Get token provider from auth factory
        <span class="cov4" title="4">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Prepare the client parameters
        clientParams := bitbucket.CreatePullRequestTaskParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PullReqID: params.PullRequestID,
                Content:   params.Content,
                CommentID: params.CommentID,
        }

        // Handle optional state parameter
        if params.State != "" </span><span class="cov0" title="0">{
                // Convert state to pending flag (RESOLVED -&gt; false, UNRESOLVED -&gt; true)
                pending := params.State != TaskStateResolved
                clientParams.Pending = &amp;pending
        }</span>

        // Call the client to create the task
        <span class="cov4" title="4">task, err := s.client.CreatePullRequestTask(ctx, tokenProvider, clientParams)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create task: %w", err)
        }</span>

        <span class="cov3" title="3">return task, nil</span>
}

type PaginatedDiffStat struct {
        Size    int                  `json:"size,omitempty"`
        Page    int                  `json:"page,omitempty"`
        PageLen int                  `json:"pagelen,omitempty"`
        Values  []bitbucket.DiffStat `json:"values"`
}

type BitbucketGetPRDiffStatParams struct {
        AccountName   string
        RepoOwner     string
        RepoName      string
        PullRequestID int
}

func (s *BitbucketService) GetPRDiffStat(
        ctx context.Context,
        params BitbucketGetPRDiffStatParams,
) (*PaginatedDiffStat, error) <span class="cov1" title="1">{
        tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)
        clientResult, err := s.client.GetPRDiffStat(
                ctx,
                tokenProvider,
                bitbucket.GetPRDiffStatParams{
                        RepoOwner: params.RepoOwner,
                        RepoName:  params.RepoName,
                        PRID:      params.PullRequestID,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;PaginatedDiffStat{
                Size:    clientResult.Size,
                Page:    clientResult.Page,
                PageLen: clientResult.PageLen,
                Values:  clientResult.Values,
        }, nil</span>
}

type BitbucketGetPRDiffParams struct {
        AccountName   string
        RepoOwner     string
        RepoName      string
        PullRequestID int
        FilePaths     []string
        ContextLines  *int
}

func (s *BitbucketService) GetPRDiff(
        ctx context.Context,
        params BitbucketGetPRDiffParams,
) (string, error) <span class="cov4" title="5">{
        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return "", errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="4">if params.RepoName == "" </span><span class="cov1" title="1">{
                return "", errors.New("repository name is required")
        }</span>
        <span class="cov3" title="3">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return "", errors.New("pull request ID must be positive")
        }</span>

        <span class="cov2" title="2">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)
        clientParams := bitbucket.GetPRDiffParams{
                RepoOwner: params.RepoOwner,
                RepoName:  params.RepoName,
                PRID:      params.PullRequestID,
                FilePaths: params.FilePaths,
                Context:   params.ContextLines,
        }
        diffResult, err := s.client.GetPRDiff(ctx, tokenProvider, clientParams)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov2" title="2">if diffResult == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov2" title="2">return diffResult, nil</span>
}

type BitbucketGetFileContentParams struct {
        AccountName string
        RepoOwner   string
        RepoName    string
        Commit      string
        Path        string
}

func (s *BitbucketService) GetFileContent(
        ctx context.Context,
        params BitbucketGetFileContentParams,
) (*bitbucket.FileContentResult, error) <span class="cov1" title="1">{
        tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)
        clientParams := bitbucket.GetFileContentParams{
                RepoOwner:  params.RepoOwner,
                RepoName:   params.RepoName,
                CommitHash: params.Commit,
                FilePath:   params.Path,
        }
        fileContent, err := s.client.GetFileContent(ctx, tokenProvider, clientParams)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Minimal stub: meta fields are hardcoded for now
        <span class="cov1" title="1">return &amp;bitbucket.FileContentResult{
                Content: fileContent.Content,
                Meta: bitbucket.FileContentMeta{
                        Size:     len(fileContent.Content),
                        Type:     "file",
                        Encoding: "utf-8",
                },
        }, nil</span>
}

type BitbucketAddPRCommentParams struct {
        AccountName   string
        RepoOwner     string
        RepoName      string
        PullRequestID int
        Content       string
        FilePath      string
        LineFrom      int
        LineTo        int
        Pending       bool
}

// AddPRComment adds a comment to a pull request (general or inline).
func (s *BitbucketService) AddPRComment(
        ctx context.Context,
        params BitbucketAddPRCommentParams,
) (int64, string, error) <span class="cov5" title="6">{
        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return 0, "", errors.New("repository owner is required")
        }</span>
        <span class="cov4" title="5">if params.RepoName == "" </span><span class="cov1" title="1">{
                return 0, "", errors.New("repository name is required")
        }</span>
        <span class="cov4" title="4">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return 0, "", errors.New("pull request ID must be positive")
        }</span>
        <span class="cov3" title="3">if params.Content == "" </span><span class="cov1" title="1">{
                return 0, "", errors.New("comment content is required")
        }</span>

        <span class="cov2" title="2">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)
        clientParams := bitbucket.AddPRCommentParams{
                Workspace:   params.RepoOwner,
                RepoSlug:    params.RepoName,
                PullReqID:   params.PullRequestID,
                CommentText: params.Content,
                FilePath:    params.FilePath,
                LineFrom:    params.LineFrom,
                LineTo:      params.LineTo,
                Account:     params.AccountName,
                Pending:     params.Pending,
        }
        return s.client.AddPRComment(ctx, tokenProvider, clientParams)</span>
}

// ListPRComments retrieves all comments for a specific pull request.
func (s *BitbucketService) ListPRComments(
        ctx context.Context,
        params BitbucketListPRCommentsParams,
) (*bitbucket.ListPRCommentsResponse, error) <span class="cov4" title="4">{
        s.logger.InfoContext(ctx, "Listing pull request comments",
                slog.String("repo", params.RepoOwner+"/"+params.RepoName),
                slog.Int("pr_id", params.PullRequestID))

        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository owner is required")
        }</span>
        <span class="cov3" title="3">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("repository name is required")
        }</span>
        <span class="cov2" title="2">if params.PullRequestID &lt;= 0 </span><span class="cov1" title="1">{
                return nil, errors.New("pull request ID must be positive")
        }</span>

        // Get token provider from auth factory
        <span class="cov1" title="1">tokenProvider := s.authFactory.getTokenProvider(ctx, params.AccountName)

        // Call the client to list PR comments
        return s.client.ListPRComments(ctx, tokenProvider, bitbucket.ListPRCommentsParams{
                Workspace: params.RepoOwner,
                RepoSlug:  params.RepoName,
                PRID:      int64(params.PullRequestID),
        })</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package app

import (
        "context"
        "errors"
        "log/slog"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

// bitbucketAuthFactory is a factory for creating bitbucketAuth implementations.
type bitbucketAuthFactory interface {
        // getTokenProvider returns a TokenProvider for the specified account name.
        // If accountName is empty, uses the default account.
        getTokenProvider(ctx context.Context, accountName string) TokenProvider
}

// bitbucketAuthFactoryImpl provides authentication for Bitbucket operations by resolving
// account information and providing tokens for API requests.
type bitbucketAuthFactoryImpl struct {
        accountsRepo AtlassianAccountsRepository
        logger       *slog.Logger
}

// BitbucketAuthFactoryDeps contains dependencies for the Bitbucket account auth.
type BitbucketAuthFactoryDeps struct {
        dig.In

        AccountsRepo AtlassianAccountsRepository
        RootLogger   *slog.Logger
}

// newBitbucketAuthFactory creates a new Bitbucket account auth component.
func newBitbucketAuthFactory(deps BitbucketAuthFactoryDeps) bitbucketAuthFactory <span class="cov10" title="8">{
        return &amp;bitbucketAuthFactoryImpl{
                accountsRepo: deps.AccountsRepo,
                logger:       deps.RootLogger.WithGroup("app.bitbucket-account-auth"),
        }
}</span>

// getTokenProvider returns a TokenProvider for the specified account name.
// If accountName is empty, uses the default account.
func (a *bitbucketAuthFactoryImpl) getTokenProvider(_ context.Context, accountName string) TokenProvider <span class="cov8" title="6">{
        return tokenProviderFunc(func(ctx context.Context) (middleware.Token, error) </span><span class="cov8" title="6">{
                var account *AtlassianAccount
                var err error

                if accountName == "" </span><span class="cov7" title="4">{
                        account, err = a.accountsRepo.GetDefaultAccount(ctx)
                        if err != nil </span><span class="cov4" title="2">{
                                return middleware.Token{}, err
                        }</span>
                } else<span class="cov4" title="2"> {
                        account, err = a.accountsRepo.GetAccountByName(ctx, accountName)
                        if err != nil </span><span class="cov1" title="1">{
                                return middleware.Token{}, err
                        }</span>
                }

                // Validate account has Bitbucket configuration
                <span class="cov5" title="3">if account.Bitbucket == nil </span><span class="cov1" title="1">{
                        return middleware.Token{}, errors.New("bitbucket configuration not found for account: " + account.Name)
                }</span>

                <span class="cov4" title="2">return middleware.Token{
                        Type:  account.Bitbucket.Type,
                        Value: account.Bitbucket.Value,
                }, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package app

import (
        "context"
        "log/slog"

        "go.uber.org/dig"
)

// Minimalistic application layer service example.

type EchoData struct {
        Message string
}

type EchoServiceDeps struct {
        dig.In

        RootLogger *slog.Logger
}

type EchoService struct {
        logger *slog.Logger
}

func (svc *EchoService) SendEcho(ctx context.Context, data *EchoData) (*EchoData, error) <span class="cov8" title="1">{
        svc.logger.InfoContext(ctx, "Going to echo data", slog.String("message", data.Message))
        return &amp;EchoData{
                Message: data.Message,
        }, nil
}</span>

func NewEchoService(deps EchoServiceDeps) *EchoService <span class="cov8" title="1">{
        return &amp;EchoService{
                logger: deps.RootLogger.WithGroup("app.echo-service"),
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockAtlassianAccountsRepository is an autogenerated mock type for the AtlassianAccountsRepository type
type MockAtlassianAccountsRepository struct {
        mock.Mock
}

type MockAtlassianAccountsRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockAtlassianAccountsRepository) EXPECT() *MockAtlassianAccountsRepository_Expecter <span class="cov10" title="6">{
        return &amp;MockAtlassianAccountsRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// GetAccountByName provides a mock function with given fields: ctx, name
func (_m *MockAtlassianAccountsRepository) GetAccountByName(ctx context.Context, name string) (*AtlassianAccount, error) <span class="cov4" title="2">{
        ret := _m.Called(ctx, name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAccountByName")</span>
        }

        <span class="cov4" title="2">var r0 *AtlassianAccount
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*AtlassianAccount, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, name)
        }</span>
        <span class="cov4" title="2">if rf, ok := ret.Get(0).(func(context.Context, string) *AtlassianAccount); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, name)
        }</span> else<span class="cov4" title="2"> {
                if ret.Get(0) != nil </span><span class="cov4" title="2">{
                        r0 = ret.Get(0).(*AtlassianAccount)
                }</span>
        }

        <span class="cov4" title="2">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, name)
        }</span> else<span class="cov4" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="2">return r0, r1</span>
}

// MockAtlassianAccountsRepository_GetAccountByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountByName'
type MockAtlassianAccountsRepository_GetAccountByName_Call struct {
        *mock.Call
}

// GetAccountByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockAtlassianAccountsRepository_Expecter) GetAccountByName(ctx interface{}, name interface{}) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov4" title="2">{
        return &amp;MockAtlassianAccountsRepository_GetAccountByName_Call{Call: _e.mock.On("GetAccountByName", ctx, name)}
}</span>

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) Run(run func(ctx context.Context, name string)) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) Return(_a0 *AtlassianAccount, _a1 error) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov4" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAtlassianAccountsRepository_GetAccountByName_Call) RunAndReturn(run func(context.Context, string) (*AtlassianAccount, error)) *MockAtlassianAccountsRepository_GetAccountByName_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetDefaultAccount provides a mock function with given fields: ctx
func (_m *MockAtlassianAccountsRepository) GetDefaultAccount(ctx context.Context) (*AtlassianAccount, error) <span class="cov7" title="4">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetDefaultAccount")</span>
        }

        <span class="cov7" title="4">var r0 *AtlassianAccount
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (*AtlassianAccount, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov7" title="4">if rf, ok := ret.Get(0).(func(context.Context) *AtlassianAccount); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov7" title="4"> {
                if ret.Get(0) != nil </span><span class="cov7" title="4">{
                        r0 = ret.Get(0).(*AtlassianAccount)
                }</span>
        }

        <span class="cov7" title="4">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov7" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov7" title="4">return r0, r1</span>
}

// MockAtlassianAccountsRepository_GetDefaultAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDefaultAccount'
type MockAtlassianAccountsRepository_GetDefaultAccount_Call struct {
        *mock.Call
}

// GetDefaultAccount is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAtlassianAccountsRepository_Expecter) GetDefaultAccount(ctx interface{}) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov7" title="4">{
        return &amp;MockAtlassianAccountsRepository_GetDefaultAccount_Call{Call: _e.mock.On("GetDefaultAccount", ctx)}
}</span>

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) Run(run func(ctx context.Context)) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) Return(_a0 *AtlassianAccount, _a1 error) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov7" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockAtlassianAccountsRepository_GetDefaultAccount_Call) RunAndReturn(run func(context.Context) (*AtlassianAccount, error)) *MockAtlassianAccountsRepository_GetDefaultAccount_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockAtlassianAccountsRepository creates a new instance of MockAtlassianAccountsRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAtlassianAccountsRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockAtlassianAccountsRepository <span class="cov10" title="6">{
        mock := &amp;MockAtlassianAccountsRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="6">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="6">return mock</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockbitbucketAuthFactory is an autogenerated mock type for the bitbucketAuthFactory type
type MockbitbucketAuthFactory struct {
        mock.Mock
}

type MockbitbucketAuthFactory_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketAuthFactory) EXPECT() *MockbitbucketAuthFactory_Expecter <span class="cov9" title="40">{
        return &amp;MockbitbucketAuthFactory_Expecter{mock: &amp;_m.Mock}
}</span>

// getTokenProvider provides a mock function with given fields: ctx, accountName
func (_m *MockbitbucketAuthFactory) getTokenProvider(ctx context.Context, accountName string) TokenProvider <span class="cov9" title="40">{
        ret := _m.Called(ctx, accountName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for getTokenProvider")</span>
        }

        <span class="cov9" title="40">var r0 TokenProvider
        if rf, ok := ret.Get(0).(func(context.Context, string) TokenProvider); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, accountName)
        }</span> else<span class="cov9" title="40"> {
                if ret.Get(0) != nil </span><span class="cov9" title="40">{
                        r0 = ret.Get(0).(TokenProvider)
                }</span>
        }

        <span class="cov9" title="40">return r0</span>
}

// MockbitbucketAuthFactory_getTokenProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'getTokenProvider'
type MockbitbucketAuthFactory_getTokenProvider_Call struct {
        *mock.Call
}

// getTokenProvider is a helper method to define mock.On call
//   - ctx context.Context
//   - accountName string
func (_e *MockbitbucketAuthFactory_Expecter) getTokenProvider(ctx interface{}, accountName interface{}) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov9" title="40">{
        return &amp;MockbitbucketAuthFactory_getTokenProvider_Call{Call: _e.mock.On("getTokenProvider", ctx, accountName)}
}</span>

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) Run(run func(ctx context.Context, accountName string)) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) Return(_a0 TokenProvider) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov9" title="40">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockbitbucketAuthFactory_getTokenProvider_Call) RunAndReturn(run func(context.Context, string) TokenProvider) *MockbitbucketAuthFactory_getTokenProvider_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketAuthFactory creates a new instance of MockbitbucketAuthFactory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketAuthFactory(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketAuthFactory <span class="cov10" title="52">{
        mock := &amp;MockbitbucketAuthFactory{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="52">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="52">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package app

import (
        context "context"

        bitbucket "github.com/gemyago/atlacp/internal/services/bitbucket"

        mock "github.com/stretchr/testify/mock"

        time "time"
)

// MockbitbucketClient is an autogenerated mock type for the bitbucketClient type
type MockbitbucketClient struct {
        mock.Mock
}

type MockbitbucketClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockbitbucketClient) EXPECT() *MockbitbucketClient_Expecter <span class="cov9" title="40">{
        return &amp;MockbitbucketClient_Expecter{mock: &amp;_m.Mock}
}</span>

// AddPRComment provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) AddPRComment(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.AddPRCommentParams) (int64, string, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddPRComment")</span>
        }

        <span class="cov2" title="2">var r0 int64
        var r1 string
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.AddPRCommentParams) (int64, string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.AddPRCommentParams) int64); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(int64)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.AddPRCommentParams) string); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Get(1).(string)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(2).(func(context.Context, bitbucket.TokenProvider, bitbucket.AddPRCommentParams) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov2" title="2"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov2" title="2">return r0, r1, r2</span>
}

// MockbitbucketClient_AddPRComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPRComment'
type MockbitbucketClient_AddPRComment_Call struct {
        *mock.Call
}

// AddPRComment is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.AddPRCommentParams
func (_e *MockbitbucketClient_Expecter) AddPRComment(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_AddPRComment_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketClient_AddPRComment_Call{Call: _e.mock.On("AddPRComment", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_AddPRComment_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.AddPRCommentParams)) *MockbitbucketClient_AddPRComment_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.AddPRCommentParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_AddPRComment_Call) Return(_a0 int64, _a1 string, _a2 error) *MockbitbucketClient_AddPRComment_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockbitbucketClient_AddPRComment_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.AddPRCommentParams) (int64, string, error)) *MockbitbucketClient_AddPRComment_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ApprovePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) ApprovePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ApprovePRParams) (*bitbucket.Participant, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ApprovePR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.Participant
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) (*bitbucket.Participant, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) *bitbucket.Participant); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.Participant)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketClient_ApprovePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApprovePR'
type MockbitbucketClient_ApprovePR_Call struct {
        *mock.Call
}

// ApprovePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.ApprovePRParams
func (_e *MockbitbucketClient_Expecter) ApprovePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_ApprovePR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketClient_ApprovePR_Call{Call: _e.mock.On("ApprovePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_ApprovePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ApprovePRParams)) *MockbitbucketClient_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.ApprovePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_ApprovePR_Call) Return(_a0 *bitbucket.Participant, _a1 error) *MockbitbucketClient_ApprovePR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_ApprovePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.ApprovePRParams) (*bitbucket.Participant, error)) *MockbitbucketClient_ApprovePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) CreatePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePR")</span>
        }

        <span class="cov4" title="5">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                if ret.Get(0) != nil </span><span class="cov4" title="5">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockbitbucketClient_CreatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePR'
type MockbitbucketClient_CreatePR_Call struct {
        *mock.Call
}

// CreatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.CreatePRParams
func (_e *MockbitbucketClient_Expecter) CreatePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_CreatePR_Call <span class="cov4" title="5">{
        return &amp;MockbitbucketClient_CreatePR_Call{Call: _e.mock.On("CreatePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_CreatePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePRParams)) *MockbitbucketClient_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.CreatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_CreatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_CreatePR_Call <span class="cov4" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_CreatePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_CreatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreatePullRequestTask provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) CreatePullRequestTask(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreatePullRequestTask")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_CreatePullRequestTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePullRequestTask'
type MockbitbucketClient_CreatePullRequestTask_Call struct {
        *mock.Call
}

// CreatePullRequestTask is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.CreatePullRequestTaskParams
func (_e *MockbitbucketClient_Expecter) CreatePullRequestTask(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_CreatePullRequestTask_Call{Call: _e.mock.On("CreatePullRequestTask", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.CreatePullRequestTaskParams)) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.CreatePullRequestTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_CreatePullRequestTask_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.CreatePullRequestTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketClient_CreatePullRequestTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetFileContent provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) GetFileContent(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetFileContentParams) (*bitbucket.FileContent, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetFileContent")</span>
        }

        <span class="cov1" title="1">var r0 *bitbucket.FileContent
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetFileContentParams) (*bitbucket.FileContent, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetFileContentParams) *bitbucket.FileContent); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(*bitbucket.FileContent)
                }</span>
        }

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetFileContentParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockbitbucketClient_GetFileContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileContent'
type MockbitbucketClient_GetFileContent_Call struct {
        *mock.Call
}

// GetFileContent is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.GetFileContentParams
func (_e *MockbitbucketClient_Expecter) GetFileContent(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_GetFileContent_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketClient_GetFileContent_Call{Call: _e.mock.On("GetFileContent", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_GetFileContent_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetFileContentParams)) *MockbitbucketClient_GetFileContent_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.GetFileContentParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_GetFileContent_Call) Return(_a0 *bitbucket.FileContent, _a1 error) *MockbitbucketClient_GetFileContent_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_GetFileContent_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.GetFileContentParams) (*bitbucket.FileContent, error)) *MockbitbucketClient_GetFileContent_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) GetPR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRParams) (*bitbucket.PullRequest, error) <span class="cov3" title="3">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPR")</span>
        }

        <span class="cov3" title="3">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov3" title="3">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                if ret.Get(0) != nil </span><span class="cov3" title="3">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov3" title="3">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov3" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov3" title="3">return r0, r1</span>
}

// MockbitbucketClient_GetPR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPR'
type MockbitbucketClient_GetPR_Call struct {
        *mock.Call
}

// GetPR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.GetPRParams
func (_e *MockbitbucketClient_Expecter) GetPR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_GetPR_Call <span class="cov3" title="3">{
        return &amp;MockbitbucketClient_GetPR_Call{Call: _e.mock.On("GetPR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_GetPR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRParams)) *MockbitbucketClient_GetPR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.GetPRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_GetPR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_GetPR_Call <span class="cov3" title="3">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_GetPR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_GetPR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPRDiff provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) GetPRDiff(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRDiffParams) (string, error) <span class="cov2" title="2">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPRDiff")</span>
        }

        <span class="cov2" title="2">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffParams) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov2" title="2">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffParams) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov2" title="2"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov2" title="2">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov2" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov2" title="2">return r0, r1</span>
}

// MockbitbucketClient_GetPRDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPRDiff'
type MockbitbucketClient_GetPRDiff_Call struct {
        *mock.Call
}

// GetPRDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.GetPRDiffParams
func (_e *MockbitbucketClient_Expecter) GetPRDiff(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_GetPRDiff_Call <span class="cov2" title="2">{
        return &amp;MockbitbucketClient_GetPRDiff_Call{Call: _e.mock.On("GetPRDiff", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_GetPRDiff_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRDiffParams)) *MockbitbucketClient_GetPRDiff_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.GetPRDiffParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_GetPRDiff_Call) Return(_a0 string, _a1 error) *MockbitbucketClient_GetPRDiff_Call <span class="cov2" title="2">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_GetPRDiff_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffParams) (string, error)) *MockbitbucketClient_GetPRDiff_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetPRDiffStat provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) GetPRDiffStat(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRDiffStatParams) (*struct {
        Size    int                  `json:"size,omitempty"`
        Page    int                  `json:"page,omitempty"`
        PageLen int                  `json:"pagelen,omitempty"`
        Values  []bitbucket.DiffStat `json:"values"`
}, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPRDiffStat")</span>
        }

        <span class="cov1" title="1">var r0 *struct {
                Size    int                  `json:"size,omitempty"`
                Page    int                  `json:"page,omitempty"`
                PageLen int                  `json:"pagelen,omitempty"`
                Values  []bitbucket.DiffStat `json:"values"`
        }
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffStatParams) (*struct {
                Size    int                  `json:"size,omitempty"`
                Page    int                  `json:"page,omitempty"`
                PageLen int                  `json:"pagelen,omitempty"`
                Values  []bitbucket.DiffStat `json:"values"`
        }, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffStatParams) *struct {
                Size    int                  `json:"size,omitempty"`
                Page    int                  `json:"page,omitempty"`
                PageLen int                  `json:"pagelen,omitempty"`
                Values  []bitbucket.DiffStat `json:"values"`
        }); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(*struct {
                                Size    int                  `json:"size,omitempty"`
                                Page    int                  `json:"page,omitempty"`
                                PageLen int                  `json:"pagelen,omitempty"`
                                Values  []bitbucket.DiffStat `json:"values"`
                        })
                }</span>
        }

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffStatParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockbitbucketClient_GetPRDiffStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPRDiffStat'
type MockbitbucketClient_GetPRDiffStat_Call struct {
        *mock.Call
}

// GetPRDiffStat is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.GetPRDiffStatParams
func (_e *MockbitbucketClient_Expecter) GetPRDiffStat(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_GetPRDiffStat_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketClient_GetPRDiffStat_Call{Call: _e.mock.On("GetPRDiffStat", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_GetPRDiffStat_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.GetPRDiffStatParams)) *MockbitbucketClient_GetPRDiffStat_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.GetPRDiffStatParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_GetPRDiffStat_Call) Return(_a0 *struct {
        Size    int                  `json:"size,omitempty"`
        Page    int                  `json:"page,omitempty"`
        PageLen int                  `json:"pagelen,omitempty"`
        Values  []bitbucket.DiffStat `json:"values"`
}, _a1 error) *MockbitbucketClient_GetPRDiffStat_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_GetPRDiffStat_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.GetPRDiffStatParams) (*struct {
        Size    int                  `json:"size,omitempty"`
        Page    int                  `json:"page,omitempty"`
        PageLen int                  `json:"pagelen,omitempty"`
        Values  []bitbucket.DiffStat `json:"values"`
}, error)) *MockbitbucketClient_GetPRDiffStat_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListPRComments provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) ListPRComments(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListPRComments")</span>
        }

        <span class="cov1" title="1">var r0 *bitbucket.ListPRCommentsResponse
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPRCommentsParams) *bitbucket.ListPRCommentsResponse); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(*bitbucket.ListPRCommentsResponse)
                }</span>
        }

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPRCommentsParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov1" title="1">return r0, r1</span>
}

// MockbitbucketClient_ListPRComments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPRComments'
type MockbitbucketClient_ListPRComments_Call struct {
        *mock.Call
}

// ListPRComments is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.ListPRCommentsParams
func (_e *MockbitbucketClient_Expecter) ListPRComments(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_ListPRComments_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketClient_ListPRComments_Call{Call: _e.mock.On("ListPRComments", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_ListPRComments_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPRCommentsParams)) *MockbitbucketClient_ListPRComments_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.ListPRCommentsParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_ListPRComments_Call) Return(_a0 *bitbucket.ListPRCommentsResponse, _a1 error) *MockbitbucketClient_ListPRComments_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_ListPRComments_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.ListPRCommentsParams) (*bitbucket.ListPRCommentsResponse, error)) *MockbitbucketClient_ListPRComments_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ListPullRequestTasks provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) ListPullRequestTasks(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ListPullRequestTasks")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PaginatedTasks
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) *bitbucket.PaginatedTasks); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PaginatedTasks)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_ListPullRequestTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPullRequestTasks'
type MockbitbucketClient_ListPullRequestTasks_Call struct {
        *mock.Call
}

// ListPullRequestTasks is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.ListPullRequestTasksParams
func (_e *MockbitbucketClient_Expecter) ListPullRequestTasks(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_ListPullRequestTasks_Call{Call: _e.mock.On("ListPullRequestTasks", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.ListPullRequestTasksParams)) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.ListPullRequestTasksParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) Return(_a0 *bitbucket.PaginatedTasks, _a1 error) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_ListPullRequestTasks_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.ListPullRequestTasksParams) (*bitbucket.PaginatedTasks, error)) *MockbitbucketClient_ListPullRequestTasks_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MergePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) MergePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.MergePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MergePR")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_MergePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergePR'
type MockbitbucketClient_MergePR_Call struct {
        *mock.Call
}

// MergePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.MergePRParams
func (_e *MockbitbucketClient_Expecter) MergePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_MergePR_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_MergePR_Call{Call: _e.mock.On("MergePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_MergePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.MergePRParams)) *MockbitbucketClient_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.MergePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_MergePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_MergePR_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_MergePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.MergePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_MergePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RequestPRChanges provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) RequestPRChanges(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.RequestPRChangesParams) (string, time.Time, error) <span class="cov1" title="1">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RequestPRChanges")</span>
        }

        <span class="cov1" title="1">var r0 string
        var r1 time.Time
        var r2 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.RequestPRChangesParams) (string, time.Time, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov1" title="1">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.RequestPRChangesParams) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.RequestPRChangesParams) time.Time); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r1 = ret.Get(1).(time.Time)
        }</span>

        <span class="cov1" title="1">if rf, ok := ret.Get(2).(func(context.Context, bitbucket.TokenProvider, bitbucket.RequestPRChangesParams) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov1" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov1" title="1">return r0, r1, r2</span>
}

// MockbitbucketClient_RequestPRChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RequestPRChanges'
type MockbitbucketClient_RequestPRChanges_Call struct {
        *mock.Call
}

// RequestPRChanges is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.RequestPRChangesParams
func (_e *MockbitbucketClient_Expecter) RequestPRChanges(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_RequestPRChanges_Call <span class="cov1" title="1">{
        return &amp;MockbitbucketClient_RequestPRChanges_Call{Call: _e.mock.On("RequestPRChanges", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_RequestPRChanges_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.RequestPRChangesParams)) *MockbitbucketClient_RequestPRChanges_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.RequestPRChangesParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_RequestPRChanges_Call) Return(_a0 string, _a1 time.Time, _a2 error) *MockbitbucketClient_RequestPRChanges_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockbitbucketClient_RequestPRChanges_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.RequestPRChangesParams) (string, time.Time, error)) *MockbitbucketClient_RequestPRChanges_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdatePR provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) UpdatePR(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error) <span class="cov4" title="5">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePR")</span>
        }

        <span class="cov4" title="5">var r0 *bitbucket.PullRequest
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="5">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) *bitbucket.PullRequest); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                if ret.Get(0) != nil </span><span class="cov4" title="5">{
                        r0 = ret.Get(0).(*bitbucket.PullRequest)
                }</span>
        }

        <span class="cov4" title="5">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="5"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="5">return r0, r1</span>
}

// MockbitbucketClient_UpdatePR_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePR'
type MockbitbucketClient_UpdatePR_Call struct {
        *mock.Call
}

// UpdatePR is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.UpdatePRParams
func (_e *MockbitbucketClient_Expecter) UpdatePR(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_UpdatePR_Call <span class="cov4" title="5">{
        return &amp;MockbitbucketClient_UpdatePR_Call{Call: _e.mock.On("UpdatePR", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_UpdatePR_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdatePRParams)) *MockbitbucketClient_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.UpdatePRParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_UpdatePR_Call) Return(_a0 *bitbucket.PullRequest, _a1 error) *MockbitbucketClient_UpdatePR_Call <span class="cov4" title="5">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_UpdatePR_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.UpdatePRParams) (*bitbucket.PullRequest, error)) *MockbitbucketClient_UpdatePR_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateTask provides a mock function with given fields: ctx, tokenProvider, params
func (_m *MockbitbucketClient) UpdateTask(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error) <span class="cov4" title="4">{
        ret := _m.Called(ctx, tokenProvider, params)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateTask")</span>
        }

        <span class="cov4" title="4">var r0 *bitbucket.PullRequestCommentTask
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, tokenProvider, params)
        }</span>
        <span class="cov4" title="4">if rf, ok := ret.Get(0).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) *bitbucket.PullRequestCommentTask); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                if ret.Get(0) != nil </span><span class="cov4" title="4">{
                        r0 = ret.Get(0).(*bitbucket.PullRequestCommentTask)
                }</span>
        }

        <span class="cov4" title="4">if rf, ok := ret.Get(1).(func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, tokenProvider, params)
        }</span> else<span class="cov4" title="4"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov4" title="4">return r0, r1</span>
}

// MockbitbucketClient_UpdateTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTask'
type MockbitbucketClient_UpdateTask_Call struct {
        *mock.Call
}

// UpdateTask is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenProvider bitbucket.TokenProvider
//   - params bitbucket.UpdateTaskParams
func (_e *MockbitbucketClient_Expecter) UpdateTask(ctx interface{}, tokenProvider interface{}, params interface{}) *MockbitbucketClient_UpdateTask_Call <span class="cov4" title="4">{
        return &amp;MockbitbucketClient_UpdateTask_Call{Call: _e.mock.On("UpdateTask", ctx, tokenProvider, params)}
}</span>

func (_c *MockbitbucketClient_UpdateTask_Call) Run(run func(ctx context.Context, tokenProvider bitbucket.TokenProvider, params bitbucket.UpdateTaskParams)) *MockbitbucketClient_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(bitbucket.TokenProvider), args[2].(bitbucket.UpdateTaskParams))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockbitbucketClient_UpdateTask_Call) Return(_a0 *bitbucket.PullRequestCommentTask, _a1 error) *MockbitbucketClient_UpdateTask_Call <span class="cov4" title="4">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockbitbucketClient_UpdateTask_Call) RunAndReturn(run func(context.Context, bitbucket.TokenProvider, bitbucket.UpdateTaskParams) (*bitbucket.PullRequestCommentTask, error)) *MockbitbucketClient_UpdateTask_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockbitbucketClient creates a new instance of MockbitbucketClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockbitbucketClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockbitbucketClient <span class="cov10" title="52">{
        mock := &amp;MockbitbucketClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="52">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="52">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package app

import (
        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewEchoService,
                NewBitbucketService,
                newBitbucketAuthFactory,
                di.ProvideAs[*bitbucket.Client, bitbucketClient],
        )
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package config

import (
        "embed"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/viper"
)

//go:embed *.json
var resources embed.FS

func mergeResourceCfg(cfg *viper.Viper, resourceName string) error <span class="cov10" title="25">{
        resourceStream, err := resources.Open(resourceName)
        if err != nil </span><span class="cov7" title="10">{
                return fmt.Errorf("failed to read config %v: %w", resourceName, err)
        }</span>
        <span class="cov8" title="15">defer resourceStream.Close()

        if err = cfg.MergeConfig(resourceStream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config %v: %w", resourceName, err)
        }</span>
        <span class="cov8" title="15">return nil</span>
}

type LoadOpts struct {
        env                   string
        defaultConfigFileName string
}

func (opts *LoadOpts) WithEnv(val string) *LoadOpts <span class="cov6" title="8">{
        if val != "" </span><span class="cov4" title="4">{
                opts.env = val
        }</span>
        <span class="cov6" title="8">return opts</span>
}

func NewLoadOpts() *LoadOpts <span class="cov7" title="10">{
        return &amp;LoadOpts{
                env:                   "local",
                defaultConfigFileName: "default.json",
        }
}</span>

func New() *viper.Viper <span class="cov7" title="10">{
        v := viper.New()
        v.SetEnvPrefix("APP")
        v.SetConfigType("json")
        v.SetEnvKeyReplacer(
                strings.NewReplacer("-", "_", ".", "_"),
        )
        v.AutomaticEnv()
        return v
}</span>

func Load(cfg *viper.Viper, opts *LoadOpts) error <span class="cov7" title="10">{
        if err := mergeResourceCfg(cfg, opts.defaultConfigFileName); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov7" title="9">if err := mergeResourceCfg(cfg, opts.env+".json"); err != nil </span><span class="cov4" title="3">{
                return err
        }</span>

        // load env user if exists
        <span class="cov6" title="6">if err := mergeResourceCfg(cfg, opts.env+"-user.json"); err != nil </span><span class="cov6" title="6">{
                if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov6" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package config

import (
        "fmt"

        "github.com/gemyago/atlacp/internal/di"
        "github.com/spf13/viper"
        "go.uber.org/dig"
)

type configValueProvider struct {
        cfg        *viper.Viper
        configPath string
        diPath     string
}

func provideConfigValue(cfg *viper.Viper, path string) configValueProvider <span class="cov10" title="36">{
        if !cfg.IsSet(path) </span><span class="cov1" title="1">{
                panic(fmt.Errorf("config key not found: %s", path))</span>
        }
        <span class="cov9" title="35">return configValueProvider{cfg, path, "config." + path}</span>
}

func (p configValueProvider) asInt() di.ConstructorWithOpts <span class="cov5" title="5">{
        return di.ProvideValue(p.cfg.GetInt(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asInt32() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetInt32(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asString() di.ConstructorWithOpts <span class="cov8" title="17">{
        return di.ProvideValue(p.cfg.GetString(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asBool() di.ConstructorWithOpts <span class="cov1" title="1">{
        return di.ProvideValue(p.cfg.GetBool(p.configPath), dig.Name(p.diPath))
}</span>

func (p configValueProvider) asDuration() di.ConstructorWithOpts <span class="cov7" title="11">{
        return di.ProvideValue(p.cfg.GetDuration(p.configPath), dig.Name(p.diPath))
}</span>

func Provide(container *dig.Container, cfg *viper.Viper) error <span class="cov2" title="2">{
        return di.ProvideAll(container,
                provideConfigValue(cfg, "gracefulShutdownTimeout").asDuration(),

                // http server config
                provideConfigValue(cfg, "httpServer.host").asString(),
                provideConfigValue(cfg, "httpServer.port").asInt(),
                provideConfigValue(cfg, "httpServer.idleTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readHeaderTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.readTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.writeTimeout").asDuration(),
                provideConfigValue(cfg, "httpServer.accessLogsLevel").asString(),

                // mcp server config
                provideConfigValue(cfg, "mcpServer.name").asString(),
                provideConfigValue(cfg, "mcpServer.version").asString(),
                provideConfigValue(cfg, "mcpServer.httpHost").asString(),
                provideConfigValue(cfg, "mcpServer.httpPort").asInt(),

                // atlassian config
                provideConfigValue(cfg, "atlassian.bitbucket.baseUrl").asString(),
                provideConfigValue(cfg, "atlassian.jira.baseUrl").asString(),
                provideConfigValue(cfg, "atlassian.accountsFilePath").asString(),
        )
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package di

import (
        "fmt"
        "reflect"

        "go.uber.org/dig"
)

// Dig is used as DI toolkit https://pkg.go.dev/go.uber.org/dig
// we are not creating any abstraction over it, but we do have a set of tools to make it easier to use

type ConstructorWithOpts struct {
        Constructor interface{}
        Options     []dig.ProvideOption
}

func ProvideAll(container *dig.Container, providers ...interface{}) error <span class="cov7" title="24">{
        for i, provider := range providers </span><span class="cov10" title="82">{
                switch p := provider.(type) </span>{
                case ConstructorWithOpts:<span class="cov8" title="44">
                        if err := container.Provide(p.Constructor, p.Options...); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                default:<span class="cov8" title="38">
                        if err := container.Provide(provider); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to provide %d-th dependency: %w", i, err)
                        }</span>
                }
        }
        <span class="cov7" title="22">return nil</span>
}

// ProvideValue will create a constructor (e.g func) from a given value.
func ProvideValue[T any](val T, opts ...dig.ProvideOption) ConstructorWithOpts <span class="cov8" title="45">{
        return ConstructorWithOpts{
                Constructor: func() T </span><span class="cov7" title="25">{ return val }</span>,
                Options:     opts,
        }
}

// ProvideWithArg will create a constructor with a first arg explicitly provided
// supposed return no error.
func ProvideWithArg[
        TArg any,
        TConstructorArg any,
        TRes any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) TRes,
) func(TConstructorArg) TRes <span class="cov1" title="1">{
        return func(cArg TConstructorArg) TRes </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideWithArgErr will create a constructor with a first arg explicitly provided
// supposed return an error.
func ProvideWithArgErr[
        TArg any,
        TConstructorArg any,
        TDep any,
](
        arg TArg,
        constructor func(arg TArg, cArg TConstructorArg) (TDep, error),
) func(TConstructorArg) (TDep, error) <span class="cov1" title="1">{
        return func(cArg TConstructorArg) (TDep, error) </span><span class="cov1" title="1">{
                return constructor(arg, cArg)
        }</span>
}

// ProvideAs is used to provide one type as another, typically
// used to provide implementation struct as particular interface.
func ProvideAs[TSource any, TTarget any](source TSource) (TTarget, error) <span class="cov4" title="6">{
        target, ok := any(source).(TTarget)
        if !ok </span><span class="cov1" title="1">{
                var src TSource
                var tgt TTarget
                return target, fmt.Errorf("failed to cast %s to %s", reflect.TypeOf(src), reflect.TypeOf(tgt))
        }</span>
        <span class="cov4" title="5">return target, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package diag

import "log/slog"

func ErrAttr(err error) slog.Attr <span class="cov8" title="1">{
        return slog.Any("err", err)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by mockery. DO NOT EDIT.

//go:build !release

package diag

import (
        context "context"
        slog "log/slog"

        mock "github.com/stretchr/testify/mock"
)

// MockSlogHandler is an autogenerated mock type for the Handler type
type MockSlogHandler struct {
        mock.Mock
}

type MockSlogHandler_Expecter struct {
        mock *mock.Mock
}

func (_m *MockSlogHandler) EXPECT() *MockSlogHandler_Expecter <span class="cov8" title="3">{
        return &amp;MockSlogHandler_Expecter{mock: &amp;_m.Mock}
}</span>

// Enabled provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Enabled(_a0 context.Context, _a1 slog.Level) bool <span class="cov0" title="0">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Enabled")</span>
        }

        <span class="cov0" title="0">var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context, slog.Level) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_Enabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enabled'
type MockSlogHandler_Enabled_Call struct {
        *mock.Call
}

// Enabled is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Level
func (_e *MockSlogHandler_Expecter) Enabled(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_Enabled_Call{Call: _e.mock.On("Enabled", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Enabled_Call) Run(run func(_a0 context.Context, _a1 slog.Level)) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Level))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Enabled_Call) Return(_a0 bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Enabled_Call) RunAndReturn(run func(context.Context, slog.Level) bool) *MockSlogHandler_Enabled_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Handle provides a mock function with given fields: _a0, _a1
func (_m *MockSlogHandler) Handle(_a0 context.Context, _a1 slog.Record) error <span class="cov5" title="2">{
        ret := _m.Called(_a0, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Handle")</span>
        }

        <span class="cov5" title="2">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, slog.Record) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov5" title="2"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov5" title="2">return r0</span>
}

// MockSlogHandler_Handle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Handle'
type MockSlogHandler_Handle_Call struct {
        *mock.Call
}

// Handle is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 slog.Record
func (_e *MockSlogHandler_Expecter) Handle(_a0 interface{}, _a1 interface{}) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        return &amp;MockSlogHandler_Handle_Call{Call: _e.mock.On("Handle", _a0, _a1)}
}</span>

func (_c *MockSlogHandler_Handle_Call) Run(run func(_a0 context.Context, _a1 slog.Record)) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(slog.Record))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_Handle_Call) Return(_a0 error) *MockSlogHandler_Handle_Call <span class="cov5" title="2">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_Handle_Call) RunAndReturn(run func(context.Context, slog.Record) error) *MockSlogHandler_Handle_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithAttrs provides a mock function with given fields: attrs
func (_m *MockSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov1" title="1">{
        ret := _m.Called(attrs)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithAttrs")</span>
        }

        <span class="cov1" title="1">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func([]slog.Attr) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(attrs)
        }</span> else<span class="cov1" title="1"> {
                if ret.Get(0) != nil </span><span class="cov1" title="1">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov1" title="1">return r0</span>
}

// MockSlogHandler_WithAttrs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithAttrs'
type MockSlogHandler_WithAttrs_Call struct {
        *mock.Call
}

// WithAttrs is a helper method to define mock.On call
//   - attrs []slog.Attr
func (_e *MockSlogHandler_Expecter) WithAttrs(attrs interface{}) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        return &amp;MockSlogHandler_WithAttrs_Call{Call: _e.mock.On("WithAttrs", attrs)}
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) Run(run func(attrs []slog.Attr)) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].([]slog.Attr))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithAttrs_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov1" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithAttrs_Call) RunAndReturn(run func([]slog.Attr) slog.Handler) *MockSlogHandler_WithAttrs_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// WithGroup provides a mock function with given fields: name
func (_m *MockSlogHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        ret := _m.Called(name)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for WithGroup")</span>
        }

        <span class="cov0" title="0">var r0 slog.Handler
        if rf, ok := ret.Get(0).(func(string) slog.Handler); ok </span><span class="cov0" title="0">{
                r0 = rf(name)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(slog.Handler)
                }</span>
        }

        <span class="cov0" title="0">return r0</span>
}

// MockSlogHandler_WithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithGroup'
type MockSlogHandler_WithGroup_Call struct {
        *mock.Call
}

// WithGroup is a helper method to define mock.On call
//   - name string
func (_e *MockSlogHandler_Expecter) WithGroup(name interface{}) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        return &amp;MockSlogHandler_WithGroup_Call{Call: _e.mock.On("WithGroup", name)}
}</span>

func (_c *MockSlogHandler_WithGroup_Call) Run(run func(name string)) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockSlogHandler_WithGroup_Call) Return(_a0 slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockSlogHandler_WithGroup_Call) RunAndReturn(run func(string) slog.Handler) *MockSlogHandler_WithGroup_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockSlogHandler creates a new instance of MockSlogHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSlogHandler(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockSlogHandler <span class="cov10" title="4">{
        mock := &amp;MockSlogHandler{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package diag

import (
        "context"
        "io"
        "log/slog"
        "os"
)

type contextKey string

const (
        contextDiagAttrs = contextKey("diag.context-key.log-attribs")
)

type LogAttributes struct {
        CorrelationID slog.Value
}

func GetLogAttributesFromContext(ctx context.Context) LogAttributes <span class="cov4" title="17">{
        res, _ := ctx.Value(contextDiagAttrs).(LogAttributes)
        return res
}</span>

func SetLogAttributesToContext(ctx context.Context, attributes LogAttributes) context.Context <span class="cov4" title="10">{
        return context.WithValue(ctx, contextDiagAttrs, attributes)
}</span>

type diagLogHandler struct {
        target slog.Handler
}

func (h *diagLogHandler) Enabled(ctx context.Context, lvl slog.Level) bool <span class="cov8" title="325">{
        return h.target.Enabled(ctx, lvl)
}</span>

func (h *diagLogHandler) Handle(ctx context.Context, rec slog.Record) error <span class="cov7" title="146">{
        if diagAttributes, ok := ctx.Value(contextDiagAttrs).(LogAttributes); ok </span><span class="cov4" title="12">{
                rec.AddAttrs(
                        slog.Attr{Key: "correlationId", Value: diagAttributes.CorrelationID},
                )
        }</span>

        <span class="cov7" title="146">return h.target.Handle(ctx, rec)</span>
}

func (h *diagLogHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov10" title="762">{
        return &amp;diagLogHandler{target: h.target.WithAttrs(attrs)}
}</span>

func (h *diagLogHandler) WithGroup(name string) slog.Handler <span class="cov9" title="612">{
        // Using WithAttrs here since group will nest all the attributes
        // inside of it (including correlationId), which makes it harder to
        // filter logs by the correlationId.
        // Consumers can use slog.Group if some attributes needs to be grouped
        return h.WithAttrs([]slog.Attr{slog.String("group", name)})
}</span>

var _ slog.Handler = &amp;diagLogHandler{}

type RootLoggerOpts struct {
        output io.Writer

        jsonLogs bool

        // Info is default (zero)
        logLevel slog.Level
}

func (opts *RootLoggerOpts) WithJSONLogs(value bool) *RootLoggerOpts <span class="cov2" title="3">{
        opts.jsonLogs = value
        return opts
}</span>

func (opts *RootLoggerOpts) WithLogLevel(logLevel slog.Level) *RootLoggerOpts <span class="cov2" title="3">{
        opts.logLevel = logLevel
        return opts
}</span>

func (opts *RootLoggerOpts) WithOutput(output io.Writer) *RootLoggerOpts <span class="cov8" title="279">{
        opts.output = output
        return opts
}</span>

func (opts *RootLoggerOpts) WithOptionalOutputFile(outputFile string) *RootLoggerOpts <span class="cov2" title="3">{
        if outputFile == "" </span><span class="cov1" title="1">{
                return opts
        }</span>
        <span class="cov1" title="2">f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="2">opts.output = f
        return opts</span>
}

func NewRootLoggerOpts() *RootLoggerOpts <span class="cov8" title="283">{
        return &amp;RootLoggerOpts{
                output: os.Stdout,
        }
}</span>

func SetupRootLogger(opts *RootLoggerOpts) *slog.Logger <span class="cov8" title="283">{
        logHandlerOpts := &amp;slog.HandlerOptions{Level: opts.logLevel}
        var logHandler slog.Handler
        if opts.jsonLogs </span><span class="cov1" title="1">{
                logHandler = slog.NewJSONHandler(opts.output, logHandlerOpts)
        }</span> else<span class="cov8" title="282"> {
                logHandler = slog.NewTextHandler(opts.output, logHandlerOpts)
        }</span>
        <span class="cov8" title="283">return slog.New(&amp;diagLogHandler{target: logHandler})</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:build !release

// TODO: generated code should include "//go:build !release" tags
//go:generate mockgen -typed -package diag -destination mock_slog_handler_test.go log/slog Handler

package diag

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
)

// openTestLogFile will open a log file in a project root directory.
func openTestLogFile() *os.File <span class="cov4" title="12">{
        _, filename, _, _ := runtime.Caller(0) // Will be current file
        testFilePath := filepath.Join(filename, "..", "..", "..", "test.log")
        f, err := os.OpenFile(testFilePath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o666)
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("fail to open log file %q for test logging: %w", testFilePath, err)
                panic(err)</span>
        }
        <span class="cov4" title="12">return f</span>
}

var testOutput = openTestLogFile() //nolint:gochecknoglobals //it's ok for tests

func RootTestLogger() *slog.Logger <span class="cov10" title="278">{
        return SetupRootLogger(
                NewRootLoggerOpts().WithOutput(testOutput),
        )
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "os"

        "github.com/gemyago/atlacp/internal/app"
        "go.uber.org/dig"
)

// atlassianAccountsConfig represents the structure of the accounts configuration file.
type atlassianAccountsConfig struct {
        // List of Atlassian accounts
        Accounts []app.AtlassianAccount `json:"accounts"`
}

// atlassianAccountsRepository implements the app.AtlassianAccountsRepository interface.
type atlassianAccountsRepository struct {
        config *atlassianAccountsConfig
        logger *slog.Logger
}

// AtlassianAccountsRepositoryDeps contains dependencies for the accounts repository.
type AtlassianAccountsRepositoryDeps struct {
        dig.In

        RootLogger *slog.Logger
        ConfigPath string `name:"config.atlassian.accountsFilePath"`
}

// NewAtlassianAccountsRepository creates a new Atlassian accounts repository.
func NewAtlassianAccountsRepository(deps AtlassianAccountsRepositoryDeps) (app.AtlassianAccountsRepository, error) <span class="cov7" title="8">{
        logger := deps.RootLogger.WithGroup("atlassian-accounts")
        configPath := deps.ConfigPath

        // Use default path if not specified
        if configPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("accounts configuration path not specified")
        }</span>

        // Check if file exists
        <span class="cov7" title="8">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("accounts configuration file not found at %s", configPath)
        }</span>

        // Read and parse configuration
        <span class="cov6" title="7">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read accounts configuration: %w", err)
        }</span>

        <span class="cov6" title="6">var config atlassianAccountsConfig
        if unmarshalErr := json.Unmarshal(data, &amp;config); unmarshalErr != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse accounts configuration: %w", unmarshalErr)
        }</span>

        // Validate configuration
        <span class="cov5" title="5">if validateErr := validateAccountsConfig(&amp;config); validateErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid accounts configuration: %w", validateErr)
        }</span>

        <span class="cov5" title="5">return &amp;atlassianAccountsRepository{
                config: &amp;config,
                logger: logger,
        }, nil</span>
}

// GetDefaultAccount returns the default Atlassian account configuration.
func (r *atlassianAccountsRepository) GetDefaultAccount(_ context.Context) (*app.AtlassianAccount, error) <span class="cov3" title="2">{
        for i, account := range r.config.Accounts </span><span class="cov5" title="4">{
                if account.Default </span><span class="cov1" title="1">{
                        return &amp;r.config.Accounts[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, app.ErrNoDefaultAccount</span>
}

// GetAccountByName returns an account with the specified name.
func (r *atlassianAccountsRepository) GetAccountByName(_ context.Context, name string) (*app.AtlassianAccount, error) <span class="cov3" title="2">{
        for i, account := range r.config.Accounts </span><span class="cov6" title="6">{
                if account.Name == name </span><span class="cov1" title="1">{
                        return &amp;r.config.Accounts[i], nil
                }</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("%w: %s", app.ErrAccountNotFound, name)</span>
}

// validateAccountsConfig validates the accounts configuration.
func validateAccountsConfig(config *atlassianAccountsConfig) error <span class="cov7" title="9">{
        if len(config.Accounts) == 0 </span><span class="cov1" title="1">{
                return errors.New("no accounts configured")
        }</span>

        <span class="cov7" title="8">accountNames := make(map[string]bool)
        foundDefault := false

        for _, account := range config.Accounts </span><span class="cov9" title="19">{
                // Validate basic account properties
                if err := validateBasicAccountProperties(account, accountNames); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov9" title="18">accountNames[account.Name] = true

                // Validate service-specific configuration
                if err := validateServiceConfigs(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Track default account
                <span class="cov9" title="18">if account.Default </span><span class="cov6" title="7">{
                        if foundDefault </span><span class="cov1" title="1">{
                                return errors.New("multiple default accounts defined")
                        }</span>
                        <span class="cov6" title="6">foundDefault = true</span>
                }
        }

        // Ensure at least one default account exists
        <span class="cov6" title="6">if !foundDefault </span><span class="cov1" title="1">{
                return errors.New("no default account specified")
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// validateBasicAccountProperties validates non-service-specific account properties.
func validateBasicAccountProperties(account app.AtlassianAccount, existingNames map[string]bool) error <span class="cov10" title="21">{
        // Check for duplicate names
        if existingNames[account.Name] </span><span class="cov1" title="1">{
                return fmt.Errorf("duplicate account name: %s", account.Name)
        }</span>

        // Check that name is specified
        <span class="cov9" title="20">if account.Name == "" </span><span class="cov1" title="1">{
                return errors.New("account missing name")
        }</span>

        // Ensure at least one service is configured
        <span class="cov9" title="19">if account.Bitbucket == nil &amp;&amp; account.Jira == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s must have at least one service configured", account.Name)
        }</span>

        <span class="cov9" title="18">return nil</span>
}

// validateServiceConfigs validates Bitbucket and Jira configurations for an account.
func validateServiceConfigs(account app.AtlassianAccount) error <span class="cov9" title="18">{
        // Validate Bitbucket configuration if provided
        if account.Bitbucket != nil </span><span class="cov9" title="18">{
                if err := validateBitbucketConfig(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Validate Jira configuration if provided
        <span class="cov9" title="18">if account.Jira != nil </span><span class="cov8" title="14">{
                if err := validateJiraConfig(account); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov9" title="18">return nil</span>
}

// validateBitbucketConfig validates Bitbucket-specific configuration.
func validateBitbucketConfig(account app.AtlassianAccount) error <span class="cov9" title="20">{
        if account.Bitbucket.Value == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Bitbucket token value", account.Name)
        }</span>
        <span class="cov9" title="19">if account.Bitbucket.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Bitbucket token type", account.Name)
        }</span>
        <span class="cov9" title="18">return nil</span>
}

// validateJiraConfig validates Jira-specific configuration.
func validateJiraConfig(account app.AtlassianAccount) error <span class="cov9" title="16">{
        if account.Jira.Value == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Jira token value", account.Name)
        }</span>
        <span class="cov9" title="15">if account.Jira.Type == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("account %s is missing Jira token type", account.Name)
        }</span>
        <span class="cov8" title="14">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

const addPRCommentStatusSuccess = "success"

// AddPRCommentParams contains parameters for adding a comment to a pull request.
type AddPRCommentParams struct {
        Workspace   string // repo_owner
        RepoSlug    string // repo_name
        PullReqID   int
        CommentText string
        FilePath    string // optional, for inline
        LineFrom    int    // optional, for inline
        LineTo      int    // optional, for inline
        Account     string // optional, for future use
        Pending     bool   // optional, for pending comments
}

// addPRCommentPayload matches the Bitbucket API for PR comments.
type addPRCommentPayload struct {
        Content struct {
                Raw string `json:"raw"`
        } `json:"content"`
        Inline *struct {
                Path string `json:"path"`
                From int    `json:"from,omitempty"`
                To   int    `json:"to,omitempty"`
        } `json:"inline,omitempty"`
        Pending bool `json:"pending,omitempty"`
}

// AddPRComment adds a comment to a Bitbucket pull request.
// Returns the comment ID and status string.
func (c *Client) AddPRComment(
        ctx context.Context,
        tokenProvider TokenProvider,
        params AddPRCommentParams,
) (int64, string, error) <span class="cov10" title="5">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="4">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/comments",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
        )

        // Build the payload
        payload := addPRCommentPayload{}
        payload.Content.Raw = params.CommentText
        payload.Pending = params.Pending

        // If file path is provided, treat as inline comment
        if params.FilePath != "" </span><span class="cov1" title="1">{
                inline := &amp;struct {
                        Path string `json:"path"`
                        From int    `json:"from,omitempty"`
                        To   int    `json:"to,omitempty"`
                }{
                        Path: params.FilePath,
                }
                if params.LineFrom &gt; 0 </span><span class="cov1" title="1">{
                        inline.From = params.LineFrom
                }</span>
                <span class="cov1" title="1">if params.LineTo &gt; 0 </span><span class="cov1" title="1">{
                        inline.To = params.LineTo
                }</span>
                <span class="cov1" title="1">payload.Inline = inline</span>
        }

        // Make API call
        <span class="cov8" title="4">var response Comment
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[addPRCommentPayload, Comment]{
                Method: "POST",
                URL:    c.baseURL + path,
                Body:   &amp;payload,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return 0, "", fmt.Errorf("add pull request comment failed: %w", err)
        }</span>

        <span class="cov7" title="3">return response.ID, addPRCommentStatusSuccess, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ApprovePRParams contains parameters for approving a pull request.
type ApprovePRParams struct {
        Username      string `json:"-"`
        RepoSlug      string `json:"-"`
        PullRequestID int    `json:"-"`
}

// ApprovePR approves a specific pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/approve.
func (c *Client) ApprovePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ApprovePRParams,
) (*Participant, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var participant Participant
        path := fmt.Sprintf(
                "/repositories/%s/%s/pullrequests/%d/approve",
                params.Username,
                params.RepoSlug,
                params.PullRequestID,
        )
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, Participant]{
                Method: "POST",
                URL:    c.baseURL + path,
                Target: &amp;participant,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("approve pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;participant, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package bitbucket

import (
        "context"
        "log/slog"
        "net/http"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

// TokenProvider provides authentication tokens for Bitbucket API requests.
type TokenProvider interface {
        GetToken(ctx context.Context) (middleware.Token, error)
}

// Client provides access to Bitbucket Cloud API operations.
type Client struct {
        httpClient *http.Client
        baseURL    string
        logger     *slog.Logger
}

// ClientDeps contains dependencies for the Bitbucket client.
type ClientDeps struct {
        dig.In

        ClientFactory *httpservices.ClientFactory
        RootLogger    *slog.Logger
        BaseURL       string `name:"config.atlassian.bitbucket.baseUrl"`
}

// NewClient creates a new Bitbucket API client.
func NewClient(deps ClientDeps) *Client <span class="cov10" title="67">{
        return &amp;Client{
                httpClient: deps.ClientFactory.CreateClient(),
                baseURL:    deps.BaseURL,
                logger:     deps.RootLogger.WithGroup("bitbucket-client"),
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// CreatePRParams contains parameters for creating a pull request.
type CreatePRParams struct {
        Username string       `json:"-"`
        RepoSlug string       `json:"-"`
        Request  *PullRequest `json:"-"`
}

// CreatePR creates a new pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests.
func (c *Client) CreatePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params CreatePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests", params.Username, params.RepoSlug)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[PullRequest, PullRequest]{
                Method: "POST",
                URL:    c.baseURL + path,
                Body:   params.Request,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("create pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// CreatePullRequestTaskParams contains parameters for creating a task on a pull request.
type CreatePullRequestTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int

        // Required body parameters
        Content string // The task content

        // Optional body parameters
        CommentID int64 // Optional comment ID to associate with the task
        Pending   *bool // Optional status of the task (nil = default based on API)
}

// CreateTaskPayload represents the request payload for creating a task.
type CreateTaskPayload struct {
        Content struct {
                Raw string `json:"raw"`
        } `json:"content"`
        Comment *CommentReference `json:"comment,omitempty"`
        Pending *bool             `json:"pending,omitempty"`
}

// CommentReference represents a reference to a comment.
type CommentReference struct {
        ID int64 `json:"id"`
}

// CreatePullRequestTask creates a new task on a pull request.
func (c *Client) CreatePullRequestTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params CreatePullRequestTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID)

        // Create request payload
        payload := CreateTaskPayload{}
        payload.Content.Raw = params.Content

        if params.CommentID &gt; 0 </span><span class="cov1" title="1">{
                payload.Comment = &amp;CommentReference{
                        ID: params.CommentID,
                }
        }</span>

        <span class="cov8" title="3">if params.Pending != nil </span><span class="cov1" title="1">{
                payload.Pending = params.Pending
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PullRequestCommentTask
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[CreateTaskPayload, PullRequestCommentTask]{
                Method: "POST",
                URL:    c.baseURL + path,
                Body:   &amp;payload,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("create pull request task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package bitbucket

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

type contextKey string

// GetPRDiffParams contains parameters for getting diff for a pull request.
type GetPRDiffParams struct {
        RepoOwner string
        RepoName  string
        PRID      int
        FilePaths []string // optional
        Context   *int     // optional, default 3
        Account   *string  // optional
}

// GetPRDiff retrieves the diff for a pull request, handling parameters, pagination, and error validation.
func (c *Client) GetPRDiff(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetPRDiffParams,
) (string, error) <span class="cov10" title="9">{
        // Parameter validation
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return "", errors.New("RepoOwner is required")
        }</span>
        <span class="cov9" title="8">if params.RepoName == "" </span><span class="cov1" title="1">{
                return "", errors.New("RepoName is required")
        }</span>
        <span class="cov8" title="7">if params.PRID == 0 </span><span class="cov1" title="1">{
                return "", errors.New("PRID is required and must be non-zero")
        }</span>

        <span class="cov8" title="6">token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov7" title="5">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build path
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/diff",
                url.PathEscape(params.RepoOwner),
                url.PathEscape(params.RepoName),
                params.PRID,
        )

        // Build query parameters
        query := url.Values{}
        if len(params.FilePaths) &gt; 0 </span><span class="cov1" title="1">{
                for _, fp := range params.FilePaths </span><span class="cov3" title="2">{
                        query.Add("path", fp)
                }</span>
        }
        <span class="cov7" title="5">if params.Context != nil </span><span class="cov1" title="1">{
                query.Set("context", strconv.Itoa(*params.Context))
        }</span>
        // Bitbucket API does not support account as a query param, but if needed as a header:
        <span class="cov7" title="5">if params.Account != nil </span><span class="cov1" title="1">{
                // Use a custom header for account if required by internal convention
                const contextKeyAtlassianAccount = contextKey("X-Atlassian-Account")
                ctxWithAuth = context.WithValue(ctxWithAuth, contextKeyAtlassianAccount, *params.Account)
        }</span>

        <span class="cov7" title="5">fullURL := c.baseURL + path
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                fullURL += "?" + query.Encode()
        }</span>

        <span class="cov7" title="5">var aggregatedDiff []byte
        nextURL := fullURL
        for </span><span class="cov8" title="6">{
                req, reqErr := http.NewRequestWithContext(ctxWithAuth, http.MethodGet, nextURL, nil)
                if reqErr != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create request: %w", reqErr)
                }</span>
                <span class="cov8" title="6">req.Header.Set("Accept", "text/plain")
                if params.Account != nil </span><span class="cov1" title="1">{
                        req.Header.Set("X-Atlassian-Account", *params.Account)
                }</span>

                <span class="cov8" title="6">resp, doErr := c.httpClient.Do(req)
                if doErr != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("get diff failed: %w", doErr)
                }</span>
                <span class="cov7" title="5">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        body, _ := io.ReadAll(resp.Body)
                        return "", fmt.Errorf("get diff failed: status %d, body: %s", resp.StatusCode, string(body))
                }</span>

                <span class="cov7" title="5">body, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("failed to read diff response: %w", readErr)
                }</span>
                <span class="cov6" title="4">aggregatedDiff = append(aggregatedDiff, body...)

                // Check for pagination: Bitbucket raw diff endpoint does not paginate, but if it did, look for a "next" link header
                nextLink := resp.Header.Get("X-Next-Page")
                if nextLink == "" </span><span class="cov5" title="3">{
                        break</span>
                }
                <span class="cov1" title="1">nextURL = nextLink</span>
        }

        <span class="cov5" title="3">return string(aggregatedDiff), nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package bitbucket

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strconv"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

func paginateDiffStat(
        ctx context.Context,
        httpClient *http.Client,
        startURL string,
) ([]DiffStat, int, int, int, error) <span class="cov7" title="4">{
        var (
                allValues []DiffStat
                page      int
                pageLen   int
                totalSize int
                firstPage = true
        )
        nextURL := startURL
        for </span><span class="cov7" title="5">{
                var resp paginatedResponse
                pageErr := httpservices.SendRequest(
                        ctx,
                        httpClient,
                        httpservices.SendRequestParams[interface{}, paginatedResponse]{
                                Method: "GET",
                                URL:    nextURL,
                                Target: &amp;resp,
                        },
                )
                if pageErr != nil </span><span class="cov1" title="1">{
                        return nil, 0, 0, 0, fmt.Errorf("get diffstat failed: %w", pageErr)
                }</span>

                <span class="cov7" title="4">if firstPage </span><span class="cov5" title="3">{
                        page = resp.Page
                        pageLen = resp.PageLen
                        totalSize = resp.Size
                        firstPage = false
                }</span>
                <span class="cov7" title="4">allValues = append(allValues, resp.Values...)

                if resp.Next == "" </span><span class="cov5" title="3">{
                        break</span>
                }
                <span class="cov1" title="1">nextURL = resp.Next</span>
        }
        <span class="cov5" title="3">return allValues, page, pageLen, totalSize, nil</span>
}

type paginatedResponse struct {
        Size     int        `json:"size,omitempty"`
        Page     int        `json:"page,omitempty"`
        PageLen  int        `json:"pagelen,omitempty"`
        Next     string     `json:"next,omitempty"`
        Previous string     `json:"previous,omitempty"`
        Values   []DiffStat `json:"values"`
}

// GetPRDiffStatParams contains parameters for getting diffstat for a pull request.
type GetPRDiffStatParams struct {
        RepoOwner string
        RepoName  string
        PRID      int
        FilePaths []string // optional
        Context   *int     // optional, default 3
        Account   *string  // optional
}

// GetPRDiffStat retrieves the diffstat for a pull request, handling all query parameters,
// pagination, and model unification.
func (c *Client) GetPRDiffStat(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetPRDiffStatParams,
) (*struct {
        Size    int        `json:"size,omitempty"`
        Page    int        `json:"page,omitempty"`
        PageLen int        `json:"pagelen,omitempty"`
        Values  []DiffStat `json:"values"`
}, error) <span class="cov10" title="8">{
        // Validate required parameters
        if params.RepoOwner == "" </span><span class="cov1" title="1">{
                return nil, errors.New("RepoOwner is required")
        }</span>
        <span class="cov9" title="7">if params.RepoName == "" </span><span class="cov1" title="1">{
                return nil, errors.New("RepoName is required")
        }</span>
        <span class="cov8" title="6">if params.PRID == 0 </span><span class="cov1" title="1">{
                return nil, errors.New("PRID is required and must be non-zero")
        }</span>

        <span class="cov7" title="5">token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov7" title="4">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build base path
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/diffstat",
                url.PathEscape(params.RepoOwner),
                url.PathEscape(params.RepoName),
                params.PRID,
        )

        // Build query parameters
        query := url.Values{}
        if len(params.FilePaths) &gt; 0 </span><span class="cov1" title="1">{
                for _, fp := range params.FilePaths </span><span class="cov4" title="2">{
                        query.Add("path", fp)
                }</span>
        }
        <span class="cov7" title="4">if params.Context != nil </span><span class="cov1" title="1">{
                query.Set("context", strconv.Itoa(*params.Context))
        }</span>
        <span class="cov7" title="4">if params.Account != nil </span><span class="cov1" title="1">{
                query.Set("account_id", *params.Account)
        }</span>

        // Initial URL
        <span class="cov7" title="4">baseURL := c.baseURL + path
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                baseURL += "?" + query.Encode()
        }</span>

        <span class="cov7" title="4">allValues, page, pageLen, totalSize, err := paginateDiffStat(ctxWithAuth, c.httpClient, baseURL)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return &amp;struct {
                Size    int        `json:"size,omitempty"`
                Page    int        `json:"page,omitempty"`
                PageLen int        `json:"pagelen,omitempty"`
                Values  []DiffStat `json:"values"`
        }{
                Size:    totalSize,
                Page:    page,
                PageLen: pageLen,
                Values:  allValues,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetFileContentParams contains parameters for getting file content from a commit.
type GetFileContentParams struct {
        RepoOwner  string
        RepoName   string
        CommitHash string
        FilePath   string
        Account    *string // optional
}

// FileContent represents the raw file content.

// GetFileContent retrieves the content of a file at a specific commit.
func (c *Client) GetFileContent(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetFileContentParams,
) (*FileContent, error) <span class="cov10" title="9">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov9" title="8">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the path
        path := fmt.Sprintf("/repositories/%s/%s/src/%s/%s",
                url.PathEscape(params.RepoOwner),
                url.PathEscape(params.RepoName),
                url.PathEscape(params.CommitHash),
                params.FilePath,
        )

        // Add ?account=... if provided
        fullURL := c.baseURL + path
        if params.Account != nil &amp;&amp; *params.Account != "" </span><span class="cov3" title="2">{
                u, parseErr := url.Parse(fullURL)
                if parseErr != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse request URL: %w", parseErr)
                }</span>
                <span class="cov1" title="1">q := u.Query()
                q.Set("account", *params.Account)
                u.RawQuery = q.Encode()
                fullURL = u.String()</span>
        }

        <span class="cov8" title="7">req, err := http.NewRequestWithContext(ctxWithAuth, http.MethodGet, fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="7">req.Header.Set("Accept", "text/plain")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov5" title="3">{
                return nil, fmt.Errorf("get file content failed: %w", err)
        }</span>
        <span class="cov6" title="4">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read file content response: %w", err)
        }</span>

        <span class="cov5" title="3">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                // Include response body in error for better diagnostics
                return nil, fmt.Errorf("get file content failed: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov5" title="3">return &amp;FileContent{
                Path:    params.FilePath,
                Commit:  params.CommitHash,
                Content: string(body),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetPRParams contains parameters for getting a pull request.
type GetPRParams struct {
        Username      string `json:"-"`
        RepoSlug      string `json:"-"`
        PullRequestID int    `json:"-"`
}

// GetPR retrieves a specific pull request by ID.
// GET /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}.
func (c *Client) GetPR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetPRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d", params.Username, params.RepoSlug, params.PullRequestID)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, PullRequest]{
                Method: "GET",
                URL:    c.baseURL + path,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetTaskParams contains parameters for getting a specific task on a pull request.
type GetTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int
        TaskID    int
}

// GET /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}.
func (c *Client) GetTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks/%d",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
                params.TaskID)

        var task PullRequestCommentTask
        err = httpservices.SendRequest(
                ctxWithAuth,
                c.httpClient,
                httpservices.SendRequestParams[interface{}, PullRequestCommentTask]{
                        Method: "GET",
                        URL:    c.baseURL + path,
                        Target: &amp;task,
                },
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;task, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ListPRComments retrieves all comments for a specific pull request.
// GET /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments.
func (c *Client) ListPRComments(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ListPRCommentsParams,
) (*ListPRCommentsResponse, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/comments",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PRID,
        )

        var response ListPRCommentsResponse
        err = httpservices.SendRequest(
                ctxWithAuth, c.httpClient,
                httpservices.SendRequestParams[interface{}, ListPRCommentsResponse]{
                        Method: "GET",
                        URL:    c.baseURL + path,
                        Target: &amp;response,
                })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("list pull request comments failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"
        "strconv"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ListPullRequestTasksParams contains parameters for listing tasks on a pull request.
type ListPullRequestTasksParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int

        // Optional query parameters
        Query   string
        Sort    string
        PageLen int
}

// ListPullRequestTasks returns a paginated list of tasks on a pull request.
func (c *Client) ListPullRequestTasks(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ListPullRequestTasksParams,
) (*PaginatedTasks, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL with query parameters
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID)

        query := url.Values{}
        if params.Query != "" </span><span class="cov1" title="1">{
                query.Add("q", params.Query)
        }</span>
        <span class="cov8" title="3">if params.Sort != "" </span><span class="cov1" title="1">{
                query.Add("sort", params.Sort)
        }</span>
        <span class="cov8" title="3">if params.PageLen &gt; 0 </span><span class="cov1" title="1">{
                query.Add("pagelen", strconv.Itoa(params.PageLen))
        }</span>

        <span class="cov8" title="3">requestURL := c.baseURL + path
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                requestURL += "?" + query.Encode()
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PaginatedTasks
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[interface{}, PaginatedTasks]{
                Method: "GET",
                URL:    requestURL,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("list pull request tasks failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// MergePRParams contains parameters for merging a pull request.
type MergePRParams struct {
        Username        string                      `json:"-"`
        RepoSlug        string                      `json:"-"`
        PullRequestID   int                         `json:"-"`
        MergeParameters *PullRequestMergeParameters `json:"-"`
}

// MergePR merges a pull request.
// POST /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}/merge.
func (c *Client) MergePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params MergePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf(
                "/repositories/%s/%s/pullrequests/%d/merge",
                params.Username,
                params.RepoSlug,
                params.PullRequestID,
        )
        err = httpservices.SendRequest(
                ctxWithAuth,
                c.httpClient,
                httpservices.SendRequestParams[PullRequestMergeParameters, PullRequest]{
                        Method: "POST",
                        URL:    c.baseURL + path,
                        Body:   params.MergeParameters,
                        Target: &amp;pullRequest,
                },
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("merge pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"
        "time"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// RequestPRChangesParams contains parameters for requesting changes on a pull request.
type RequestPRChangesParams struct {
        Workspace string // repo_owner
        RepoSlug  string // repo_name
        PullReqID int
        Account   string // optional, for future use
}

// RequestPRChanges requests changes on a specific pull request.
// POST /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes
// Returns status and timestamp of the request.
func (c *Client) RequestPRChanges(
        ctx context.Context,
        tokenProvider TokenProvider,
        params RequestPRChangesParams,
) (string, time.Time, error) <span class="cov10" title="3">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return "", time.Time{}, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov6" title="2">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/request-changes",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
        )

        // The Bitbucket API returns the participant object with the new state.
        var participant Participant
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, Participant]{
                Method: "POST",
                URL:    c.baseURL + path,
                Target: &amp;participant,
        })
        if err != nil </span><span class="cov1" title="1">{
                return "", time.Time{}, fmt.Errorf("request changes failed: %w", err)
        }</span>

        // Return the participant state and current timestamp
        <span class="cov1" title="1">return participant.State, time.Now().UTC(), nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">//go:build !release

package bitbucket

import "github.com/go-faker/faker/v4"

// PullRequestOpt is a function that configures a PullRequest.
type PullRequestOpt func(*PullRequest)

// WithPullRequestTitle sets the title of the pull request.
func WithPullRequestTitle(title string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Title = title
        }</span>
}

// WithPullRequestDescription sets the description of the pull request.
func WithPullRequestDescription(description string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Description = description
        }</span>
}

// WithPullRequestID sets the ID of the pull request.
func WithPullRequestID(id int) PullRequestOpt <span class="cov1" title="1">{
        return func(pr *PullRequest) </span><span class="cov1" title="1">{
                pr.ID = id
        }</span>
}

// WithPullRequestState sets the state of the pull request.
func WithPullRequestState(state string) PullRequestOpt <span class="cov4" title="3">{
        return func(pr *PullRequest) </span><span class="cov4" title="3">{
                pr.State = state
        }</span>
}

// WithPullRequestSourceBranch sets the source branch of the pull request.
func WithPullRequestSourceBranch(name string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Source.Branch.Name = name
        }</span>
}

// WithPullRequestDestinationBranch sets the destination branch of the pull request.
func WithPullRequestDestinationBranch(name string) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                if pr.Destination == nil </span><span class="cov0" title="0">{
                        pr.Destination = &amp;PullRequestDestination{}
                }</span>
                <span class="cov0" title="0">pr.Destination.Branch.Name = name</span>
        }
}

// WithPullRequestCloseSourceBranch sets whether to close the source branch.
func WithPullRequestCloseSourceBranch(closeFlag bool) PullRequestOpt <span class="cov1" title="1">{
        return func(pr *PullRequest) </span><span class="cov1" title="1">{
                pr.CloseSourceBranch = closeFlag
        }</span>
}

// WithPullRequestAuthor sets the author of the pull request.
func WithPullRequestAuthor(author *PullRequestAuthor) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Author = author
        }</span>
}

// WithPullRequestReviewers sets the reviewers for the pull request.
func WithPullRequestReviewers(reviewers []PullRequestAuthor) PullRequestOpt <span class="cov0" title="0">{
        return func(pr *PullRequest) </span><span class="cov0" title="0">{
                pr.Reviewers = reviewers
        }</span>
}

// PullRequestAuthorOpt is a function that configures a PullRequestAuthor.
type PullRequestAuthorOpt func(*PullRequestAuthor)

// WithAuthorUsername sets the username of the author.
func WithAuthorUsername(username string) PullRequestAuthorOpt <span class="cov0" title="0">{
        return func(a *PullRequestAuthor) </span><span class="cov0" title="0">{
                a.Username = username
        }</span>
}

// WithAuthorDisplayName sets the display name of the author.
func WithAuthorDisplayName(displayName string) PullRequestAuthorOpt <span class="cov0" title="0">{
        return func(a *PullRequestAuthor) </span><span class="cov0" title="0">{
                a.DisplayName = displayName
        }</span>
}

// NewRandomPullRequest generates a random PullRequest for testing.
func NewRandomPullRequest(opts ...PullRequestOpt) *PullRequest <span class="cov9" title="15">{
        pr := &amp;PullRequest{
                ID:          int(faker.RandomUnixTime()),
                Title:       "PR-" + faker.Sentence(),
                Description: faker.Paragraph(),
                State:       "OPEN",
                Source: PullRequestSource{
                        Branch: PullRequestBranch{
                                Name: "feature/" + faker.Word(),
                        },
                },
                Destination: &amp;PullRequestDestination{
                        Branch: PullRequestBranch{
                                Name: "main",
                        },
                },
                CloseSourceBranch: true,
                Author:            NewRandomPullRequestAuthor(),
                Type:              "pullrequest",
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov6" title="5">{
                opt(pr)
        }</span>

        <span class="cov9" title="15">return pr</span>
}

// NewRandomPullRequestAuthor generates a random PullRequestAuthor for testing.
func NewRandomPullRequestAuthor(opts ...PullRequestAuthorOpt) *PullRequestAuthor <span class="cov10" title="18">{
        username := faker.Username()
        author := &amp;PullRequestAuthor{
                AccountID:   faker.UUIDHyphenated(),
                DisplayName: faker.Name(),
                Nickname:    username,
                Username:    username,
                UUID:        faker.UUIDHyphenated(),
                Type:        "user",
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(author)
        }</span>

        <span class="cov10" title="18">return author</span>
}

// NewRandomParticipant generates a random Participant for testing.
func NewRandomParticipant(approved bool) *Participant <span class="cov3" title="2">{
        state := "changes_requested"
        if approved </span><span class="cov3" title="2">{
                state = "approved"
        }</span>

        <span class="cov3" title="2">return &amp;Participant{
                User:     *NewRandomPullRequestAuthor(),
                Role:     "REVIEWER",
                Approved: approved,
                State:    state,
                Type:     "participant",
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package bitbucket

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// UpdatePRParams contains parameters for updating a pull request.
type UpdatePRParams struct {
        Username      string       `json:"-"`
        RepoSlug      string       `json:"-"`
        PullRequestID int          `json:"-"`
        Request       *PullRequest `json:"-"`
}

// UpdatePR updates a pull request.
// PUT /repositories/{username}/{repo_slug}/pullrequests/{pull_request_id}.
func (c *Client) UpdatePR(
        ctx context.Context,
        tokenProvider TokenProvider,
        params UpdatePRParams,
) (*PullRequest, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        var pullRequest PullRequest
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d", params.Username, params.RepoSlug, params.PullRequestID)
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[PullRequest, PullRequest]{
                Method: "PUT",
                URL:    c.baseURL + path,
                Body:   params.Request,
                Target: &amp;pullRequest,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("update pull request failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;pullRequest, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package bitbucket

import (
        "context"
        "fmt"
        "net/url"

        "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// UpdateTaskParams contains parameters for updating a task on a pull request.
type UpdateTaskParams struct {
        // Required path parameters
        Workspace string
        RepoSlug  string
        PullReqID int
        TaskID    int

        // Optional update parameters
        Content string // The updated task content
        State   string // The state of the task ("RESOLVED" or "UNRESOLVED")
}

// UpdateTaskPayload represents the request payload for updating a task.
type UpdateTaskPayload struct {
        Content *TaskContentUpdate `json:"content,omitempty"`
        State   string             `json:"state,omitempty"`
}

// TaskContentUpdate represents the content update for a task.
type TaskContentUpdate struct {
        Raw string `json:"raw"`
}

// PUT /repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/tasks/{task_id}.
func (c *Client) UpdateTask(
        ctx context.Context,
        tokenProvider TokenProvider,
        params UpdateTaskParams,
) (*PullRequestCommentTask, error) <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthTokenV2(ctx, token)

        // Build the URL
        path := fmt.Sprintf("/repositories/%s/%s/pullrequests/%d/tasks/%d",
                url.PathEscape(params.Workspace),
                url.PathEscape(params.RepoSlug),
                params.PullReqID,
                params.TaskID)

        // Create request payload
        payload := UpdateTaskPayload{}

        if params.Content != "" </span><span class="cov1" title="1">{
                payload.Content = &amp;TaskContentUpdate{
                        Raw: params.Content,
                }
        }</span>

        <span class="cov8" title="3">if params.State != "" </span><span class="cov8" title="3">{
                payload.State = params.State
        }</span>

        // Make API call
        <span class="cov8" title="3">var response PullRequestCommentTask
        err = http.SendRequest(ctxWithAuth, c.httpClient, http.SendRequestParams[UpdateTaskPayload, PullRequestCommentTask]{
                Method: "PUT",
                URL:    c.baseURL + path,
                Body:   &amp;payload,
                Target: &amp;response,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("update task failed: %w", err)
        }</span>

        <span class="cov5" title="2">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package http

import (
        "log/slog"
        "net/http"
        "time"

        "github.com/gemyago/atlacp/internal/services/http/middleware"
        "go.uber.org/dig"
)

const (
        // defaultClientTimeout is the default timeout for HTTP clients.
        defaultClientTimeout = 30 * time.Second
)

// ClientFactoryDeps contains dependencies for the client factory.
type ClientFactoryDeps struct {
        dig.In

        RootLogger *slog.Logger
}

// ClientOption configures HTTP client creation.
type ClientOption func(*clientConfig)

// clientConfig holds internal configuration for HTTP client creation.
type clientConfig struct {
        timeout             time.Duration
        enableAuth          bool
        enableLogging       bool
        enableErrorHandling bool
}

// WithTimeout sets the HTTP client timeout.
func WithTimeout(timeout time.Duration) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.timeout = timeout
        }</span>
}

// WithAuth sets whether authentication middleware is enabled.
func WithAuth(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableAuth = enabled
        }</span>
}

// WithLogging sets whether logging middleware is enabled.
func WithLogging(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableLogging = enabled
        }</span>
}

// WithErrorHandling sets whether error handling middleware is enabled.
func WithErrorHandling(enabled bool) ClientOption <span class="cov1" title="1">{
        return func(c *clientConfig) </span><span class="cov1" title="1">{
                c.enableErrorHandling = enabled
        }</span>
}

// ClientFactory is responsible for creating configured HTTP clients with middleware.
type ClientFactory struct {
        logger *slog.Logger
}

// NewClientFactory creates a new client factory.
func NewClientFactory(deps ClientFactoryDeps) *ClientFactory <span class="cov10" title="84">{
        return &amp;ClientFactory{
                logger: deps.RootLogger.WithGroup("http-client-factory"),
        }
}</span>

// CreateClient creates a new HTTP client with the specified options.
// Middleware is applied in the order: Logging -&gt; Auth -&gt; ErrorHandling -&gt; BaseTransport
// This ensures logging captures the full request lifecycle, auth adds headers, and error handling catches issues.
func (f *ClientFactory) CreateClient(options ...ClientOption) *http.Client <span class="cov10" title="84">{
        config := &amp;clientConfig{
                timeout:             defaultClientTimeout,
                enableAuth:          true, // Default: enabled
                enableLogging:       true, // Default: enabled
                enableErrorHandling: true, // Default: enabled
        }

        for _, option := range options </span><span class="cov3" title="4">{
                option(config)
        }</span>

        // Start with the base transport
        <span class="cov10" title="84">transport := http.DefaultTransport

        // Apply middleware in reverse order (innermost to outermost)
        // Error handling middleware is applied closest to the base transport
        if config.enableErrorHandling </span><span class="cov9" title="83">{
                transport = middleware.NewErrorHandlingMiddleware(transport, middleware.ErrorHandlingMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        // Auth middleware wraps error handling
        <span class="cov10" title="84">if config.enableAuth </span><span class="cov9" title="83">{
                transport = middleware.NewAuthenticationMiddleware(transport, middleware.AuthenticationMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        // Logging middleware is outermost to capture full request lifecycle
        <span class="cov10" title="84">if config.enableLogging </span><span class="cov9" title="83">{
                transport = middleware.NewLoggingMiddleware(transport, middleware.LoggingMiddlewareDeps{
                        RootLogger: f.logger,
                })
        }</span>

        <span class="cov10" title="84">return &amp;http.Client{
                Transport: transport,
                Timeout:   config.timeout,
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
)

// authTokenKey is the context key for storing authentication tokens.
type authTokenKey struct{}

// Token represents an authentication token with a type and value.
type Token struct {
        Type  string
        Value string
}

// WithAuthTokenV2 adds a Token struct to the context.
func WithAuthTokenV2(ctx context.Context, token Token) context.Context <span class="cov9" title="67">{
        return context.WithValue(ctx, authTokenKey{}, token)
}</span>

// WithAuthToken adds a Bearer authentication token to the context (legacy API).
func WithAuthToken(ctx context.Context, token string) context.Context <span class="cov6" title="12">{
        return WithAuthTokenV2(ctx, Token{Type: "Bearer", Value: token})
}</span>

// AuthTokenFromContext extracts the Token from the context.
func AuthTokenFromContext(ctx context.Context) (Token, bool) <span class="cov9" title="66">{
        token, ok := ctx.Value(authTokenKey{}).(Token)
        return token, ok
}</span>

// AuthenticationMiddlewareDeps contains dependencies for the authentication middleware.
type AuthenticationMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// AuthenticationMiddleware wraps an http.RoundTripper to add authentication headers.
type AuthenticationMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewAuthenticationMiddleware creates a new authentication middleware
// Tokens are injected via context using WithAuthToken.
func NewAuthenticationMiddleware(transport http.RoundTripper, deps AuthenticationMiddlewareDeps) http.RoundTripper <span class="cov10" title="87">{
        return &amp;AuthenticationMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-auth-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface
// Extracts token from context and adds Authorization header.
func (a *AuthenticationMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="65">{
        // Extract token from context
        token, hasToken := AuthTokenFromContext(req.Context())

        // If no token in context, log and pass request through unchanged
        if !hasToken || token.Value == "" </span><span class="cov2" title="2">{
                a.logger.DebugContext(req.Context(), "No authentication token found in context, passing request through unchanged")
                return a.transport.RoundTrip(req)
        }</span>

        // Clone the request to avoid modifying the original
        <span class="cov9" title="63">clonedReq := req.Clone(req.Context())

        // Add Authorization header
        clonedReq.Header.Set("Authorization", token.Type+" "+token.Value)

        // Pass the modified request to the next transport
        return a.transport.RoundTrip(clonedReq)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "io"
        "log/slog"
        "net/http"
)

const (
        // HTTP status code boundaries for error classification.
        httpStatusClientErrorMin = 400
        httpStatusServerErrorMin = 500
)

// HTTPError represents an HTTP-related error with context.
type HTTPError struct {
        StatusCode int
        Method     string
        URL        string
        Message    string
        Err        error
}

// Error implements the error interface.
func (e *HTTPError) Error() string <span class="cov8" title="40">{
        if e.Err != nil </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov8" title="39">return e.Message</span>
}

// Unwrap implements error unwrapping for error chain support.
func (e *HTTPError) Unwrap() error <span class="cov2" title="2">{
        return e.Err
}</span>

// ErrorHandlingMiddlewareDeps contains dependencies for the error handling middleware.
type ErrorHandlingMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// ErrorHandlingMiddleware wraps an http.RoundTripper to add generic HTTP error handling.
type ErrorHandlingMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewErrorHandlingMiddleware creates a new error handling middleware.
func NewErrorHandlingMiddleware(transport http.RoundTripper, deps ErrorHandlingMiddlewareDeps) http.RoundTripper <span class="cov10" title="88">{
        return &amp;ErrorHandlingMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-error-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface.
// Handles HTTP errors by wrapping non-2xx responses and transport errors in HTTPError.
func (e *ErrorHandlingMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="66">{
        // Call next transport
        resp, err := e.transport.RoundTrip(req)

        // Handle transport errors (network issues, etc.)
        if err != nil </span><span class="cov1" title="1">{
                httpErr := &amp;HTTPError{
                        StatusCode: 0, // No status code for transport errors
                        Method:     req.Method,
                        URL:        req.URL.String(),
                        Message:    "HTTP transport error",
                        Err:        err,
                }
                e.logger.ErrorContext(req.Context(), "HTTP transport error",
                        "method", req.Method,
                        "url", req.URL.String(),
                        "error", err,
                )
                return nil, httpErr
        }</span>

        // Handle HTTP error status codes
        <span class="cov9" title="65">if resp.StatusCode &gt;= httpStatusClientErrorMin </span><span class="cov7" title="21">{
                var message string
                if resp.StatusCode &gt;= httpStatusServerErrorMin </span><span class="cov2" title="2">{
                        message = fmt.Sprintf("HTTP server error (%d %s)", resp.StatusCode, resp.Status)
                }</span> else<span class="cov6" title="19"> {
                        message = fmt.Sprintf("HTTP client error (%d %s)", resp.StatusCode, resp.Status)
                }</span>

                <span class="cov7" title="21">httpErr := &amp;HTTPError{
                        StatusCode: resp.StatusCode,
                        Method:     req.Method,
                        URL:        req.URL.String(),
                        Message:    message,
                        Err:        nil, // No underlying error for HTTP status errors
                }

                // Read response body for logging, but preserve it for downstream code
                var bodyBytes []byte
                if resp.Body != nil </span><span class="cov7" title="21">{
                        bodyBytes, _ = io.ReadAll(resp.Body)
                        // Close the original body to prevent resource leaks
                        resp.Body.Close()
                        // Replace with a new reader containing the same data
                        resp.Body = io.NopCloser(bytes.NewReader(bodyBytes))
                }</span>

                // Log the error with body content
                <span class="cov7" title="21">e.logger.WarnContext(req.Context(), "HTTP error response",
                        "method", req.Method,
                        "url", req.URL.String(),
                        "status_code", resp.StatusCode,
                        "status", resp.Status,
                        "response_body", string(bodyBytes),
                )

                // Return both the error and the response so downstream code can inspect the body
                return resp, httpErr</span>
        }

        // Success case - pass through unchanged
        <span class="cov8" title="44">return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "time"
)

// LoggingMiddlewareDeps contains dependencies for the logging middleware.
type LoggingMiddlewareDeps struct {
        RootLogger *slog.Logger
}

// LoggingMiddleware wraps an http.RoundTripper to add structured logging.
type LoggingMiddleware struct {
        transport http.RoundTripper
        logger    *slog.Logger
}

// NewLoggingMiddleware creates a new logging middleware.
func NewLoggingMiddleware(transport http.RoundTripper, deps LoggingMiddlewareDeps) http.RoundTripper <span class="cov10" title="86">{
        return &amp;LoggingMiddleware{
                transport: transport,
                logger:    deps.RootLogger.WithGroup("http-logging-middleware"),
        }
}</span>

// RoundTrip implements http.RoundTripper interface.
// Logs request and response details with structured logging.
func (l *LoggingMiddleware) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov9" title="64">{
        start := time.Now()

        // Log request
        l.logger.DebugContext(req.Context(), "HTTP request started",
                slog.String("method", req.Method),
                slog.String("url", req.URL.String()),
                slog.String("host", req.Host),
        )

        // Call next transport
        resp, err := l.transport.RoundTrip(req)
        duration := time.Since(start)

        // Log response
        if err != nil </span><span class="cov7" title="20">{
                l.logger.ErrorContext(req.Context(), "HTTP request failed",
                        slog.String("method", req.Method),
                        slog.String("url", req.URL.String()),
                        slog.Duration("duration", duration),
                        slog.Any("error", err),
                )
                return nil, err
        }</span>

        <span class="cov8" title="44">l.logger.DebugContext(req.Context(), "HTTP request completed",
                slog.String("method", req.Method),
                slog.String("url", req.URL.String()),
                slog.Int("status_code", resp.StatusCode),
                slog.Duration("duration", duration),
        )

        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
)

// Use interface{} if no body and or target are needed.
type SendRequestParams[TBody any, TTarget any] struct {
        // HTTP method (GET, POST, PUT, DELETE, etc.)
        Method string

        // Full URL for the request
        URL string

        // Request body to be JSON marshaled (can be nil for GET requests)
        Body *TBody

        // Target to unmarshal response into (can be nil if response not needed)
        Target *TTarget
}

// SendRequest performs an HTTP request with generic body and target types.
// This is a shared function that can be used by all API clients for consistent
// request handling, error processing, and response unmarshaling.
func SendRequest[TBody any, TTarget any](
        ctx context.Context,
        client *http.Client,
        params SendRequestParams[TBody, TTarget],
) error <span class="cov10" title="57">{
        var reqBody bytes.Buffer
        if params.Body != nil </span><span class="cov8" title="25">{
                if err := json.NewEncoder(&amp;reqBody).Encode(params.Body); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to marshal request body: %w", err)
                }</span>
        }

        <span class="cov9" title="56">req, err := http.NewRequestWithContext(ctx, params.Method, params.URL, &amp;reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov9" title="56">if params.Body != nil </span><span class="cov8" title="24">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov9" title="56">resp, err := client.Do(req)
        if err != nil </span><span class="cov7" title="18">{
                return fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov9" title="38">defer resp.Body.Close()

        if params.Target != nil </span><span class="cov8" title="33">{
                if err = json.NewDecoder(resp.Body).Decode(params.Target); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to unmarshal response into target: %w", err)
                }</span>
        }

        <span class="cov9" title="37">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package jira

import (
        "context"
        "log/slog"
        "net/http"
        "strings"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "go.uber.org/dig"
)

// TokenProvider provides authentication tokens for Jira API requests.
type TokenProvider interface {
        GetToken(ctx context.Context) (string, error)
}

// Client provides access to Jira Cloud API operations.
type Client struct {
        httpClient *http.Client
        baseURL    string
        logger     *slog.Logger
}

// ClientDeps contains dependencies for the Jira client.
type ClientDeps struct {
        dig.In

        ClientFactory *httpservices.ClientFactory
        RootLogger    *slog.Logger
        BaseURL       string `name:"config.atlassian.jira.baseUrl"`
}

// NewClient creates a new Jira API client.
func NewClient(deps ClientDeps) *Client <span class="cov10" title="14">{
        return &amp;Client{
                httpClient: deps.ClientFactory.CreateClient(),
                baseURL:    deps.BaseURL,
                logger:     deps.RootLogger.WithGroup("jira-client"),
        }
}</span>

// GetBaseURL returns the base URL with the domain replaced.
// The baseURL contains a placeholder {domain} that needs to be replaced with the actual domain.
func (c *Client) GetBaseURL(domain string) string <span class="cov9" title="11">{
        return strings.ReplaceAll(c.baseURL, "{domain}", domain)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package jira

import (
        "context"
        "fmt"
        "net/url"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// GetTicketParams contains parameters for retrieving a Jira ticket.
type GetTicketParams struct {
        Domain    string   `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey string   `json:"-"` // The ticket key (e.g., "PROJECT-123")
        Fields    []string `json:"-"` // Optional fields to include
        Expand    []string `json:"-"` // Optional expansions (e.g., "renderedFields", "transitions")
}

// GetTicket retrieves a Jira ticket by its key.
// GET /rest/api/3/issue/{issueIdOrKey}.
func (c *Client) GetTicket(
        ctx context.Context,
        tokenProvider TokenProvider,
        params GetTicketParams,
) (*Ticket, error) <span class="cov8" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov7" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s", params.TicketKey)

        // Add query parameters if provided
        requestURL, err := url.Parse(baseURL + path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        <span class="cov7" title="3">query := requestURL.Query()
        if len(params.Fields) &gt; 0 </span><span class="cov1" title="1">{
                query.Set("fields", joinStrings(params.Fields))
        }</span>
        <span class="cov7" title="3">if len(params.Expand) &gt; 0 </span><span class="cov1" title="1">{
                query.Set("expand", joinStrings(params.Expand))
        }</span>
        <span class="cov7" title="3">requestURL.RawQuery = query.Encode()

        var ticket Ticket
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, httpservices.SendRequestParams[interface{}, Ticket]{
                Method: "GET",
                URL:    requestURL.String(),
                Target: &amp;ticket,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("get ticket failed: %w", err)
        }</span>

        <span class="cov4" title="2">return &amp;ticket, nil</span>
}

// joinStrings joins a slice of strings with commas.
func joinStrings(items []string) string <span class="cov4" title="2">{
        result := ""
        for i, item := range items </span><span class="cov10" title="5">{
                if i &gt; 0 </span><span class="cov7" title="3">{
                        result += ","
                }</span>
                <span class="cov10" title="5">result += item</span>
        }
        <span class="cov4" title="2">return result</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package jira

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// ManageLabelsParams contains parameters for managing labels on a Jira ticket.
type ManageLabelsParams struct {
        Domain       string   `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey    string   `json:"-"` // The ticket key (e.g., "PROJECT-123")
        AddLabels    []string `json:"-"` // Labels to add to the ticket
        RemoveLabels []string `json:"-"` // Labels to remove from the ticket
}

// ManageLabels adds and/or removes labels from a Jira ticket.
// PUT /rest/api/3/issue/{issueIdOrKey}.
func (c *Client) ManageLabels(
        ctx context.Context,
        tokenProvider TokenProvider,
        params ManageLabelsParams,
) error <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s", params.TicketKey)

        // Create label update request
        request := LabelUpdateRequest{}
        request.Update.Labels = make([]LabelOperation, 0, len(params.AddLabels)+len(params.RemoveLabels))

        // Add labels
        for _, label := range params.AddLabels </span><span class="cov10" title="4">{
                request.Update.Labels = append(request.Update.Labels, LabelOperation{
                        Add: label,
                })
        }</span>

        // Remove labels
        <span class="cov8" title="3">for _, label := range params.RemoveLabels </span><span class="cov1" title="1">{
                request.Update.Labels = append(request.Update.Labels, LabelOperation{
                        Remove: label,
                })
        }</span>

        <span class="cov8" title="3">sendParams := httpservices.SendRequestParams[LabelUpdateRequest, interface{}]{
                Method: "PUT",
                URL:    baseURL + path,
                Body:   &amp;request,
                Target: nil, // No response body expected for successful update
        }
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, sendParams)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("manage labels failed: %w", err)
        }</span>

        <span class="cov5" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package jira

import (
        "context"
        "fmt"

        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/http/middleware"
)

// TransitionTicketParams contains parameters for transitioning a Jira ticket.
type TransitionTicketParams struct {
        Domain       string                 `json:"-"` // Jira domain (e.g., "company" in company.atlassian.net)
        TicketKey    string                 `json:"-"` // The ticket key (e.g., "PROJECT-123")
        TransitionID string                 `json:"-"` // The ID of the transition to perform
        Fields       map[string]interface{} `json:"-"` // Optional fields to update during transition
        Update       map[string]interface{} `json:"-"` // Optional updates to perform during transition
}

// TransitionTicket transitions a Jira ticket to a new status.
// POST /rest/api/3/issue/{issueIdOrKey}/transitions.
func (c *Client) TransitionTicket(
        ctx context.Context,
        tokenProvider TokenProvider,
        params TransitionTicketParams,
) error <span class="cov10" title="4">{
        token, err := tokenProvider.GetToken(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get token: %w", err)
        }</span>
        <span class="cov8" title="3">ctxWithAuth := middleware.WithAuthToken(ctx, token)

        baseURL := c.GetBaseURL(params.Domain)
        path := fmt.Sprintf("/issue/%s/transitions", params.TicketKey)

        // Create transition request
        request := TransitionRequest{
                Fields: params.Fields,
                Update: params.Update,
        }
        request.Transition.ID = params.TransitionID

        sendParams := httpservices.SendRequestParams[TransitionRequest, interface{}]{
                Method: "POST",
                URL:    baseURL + path,
                Body:   &amp;request,
                Target: nil, // No response body expected for successful transition
        }
        err = httpservices.SendRequest(ctxWithAuth, c.httpClient, sendParams)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("transition ticket failed: %w", err)
        }</span>

        <span class="cov5" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import (
        "time"

        "github.com/gemyago/atlacp/internal/di"
        "github.com/gemyago/atlacp/internal/services/bitbucket"
        httpservices "github.com/gemyago/atlacp/internal/services/http"
        "github.com/gemyago/atlacp/internal/services/jira"
        "go.uber.org/dig"
)

func Register(container *dig.Container) error <span class="cov10" title="2">{
        return di.ProvideAll(container,
                NewTimeProvider,
                di.ProvideValue(time.NewTicker),
                NewShutdownHooks,
                httpservices.NewClientFactory,
                bitbucket.NewClient,
                jira.NewClient,
                NewAtlassianAccountsRepository,
        )
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// ShutdownHooks are used to implement a graceful shutdown
// of the application. This may include closing database connections, flushing pending
// events to the queue, shutting down the http server, etc.

package services

import (
        "context"
        "fmt"
        "log/slog"
        "reflect"
        "time"

        "go.uber.org/dig"
        "golang.org/x/sync/errgroup"
)

type shutdownHook struct {
        name       string
        shutdownFn func(ctx context.Context) error
}

type ShutdownHooks struct {
        logger *slog.Logger
        hooks  []shutdownHook
        deps   ShutdownHooksRegistryDeps
}

// HasHook checks if a shutdown hook with the given name is registered.
// Typical usage is in tests and must be carefully considered for production scenarios.
func (h *ShutdownHooks) HasHook(name string, method any) bool <span class="cov6" title="4">{
        for _, hook := range h.hooks </span><span class="cov4" title="3">{
                if hook.name == name </span><span class="cov3" title="2">{
                        return reflect.ValueOf(hook.shutdownFn).Pointer() == reflect.ValueOf(method).Pointer()
                }</span>
        }
        <span class="cov3" title="2">return false</span>
}

func (h *ShutdownHooks) Register(name string, shutdown func(ctx context.Context) error) <span class="cov10" title="12">{
        h.hooks = append(h.hooks, shutdownHook{name: name, shutdownFn: shutdown})
}</span>

func (h *ShutdownHooks) RegisterNoCtx(name string, shutdown func() error) <span class="cov4" title="3">{
        h.Register(name, func(_ context.Context) error </span><span class="cov4" title="3">{
                return shutdown()
        }</span>)
}

func (h *ShutdownHooks) PerformShutdown(ctx context.Context) error <span class="cov6" title="5">{
        ctx, cancel := context.WithTimeout(ctx, h.deps.GracefulShutdownTimeout)
        defer cancel()

        errGrp := errgroup.Group{}
        for _, hook := range h.hooks </span><span class="cov9" title="10">{
                errGrp.Go(func() error </span><span class="cov9" title="10">{
                        hookName := hook.name
                        h.logger.InfoContext(ctx, fmt.Sprintf("Shutting down %s", hookName))
                        if err := hook.shutdownFn(ctx); err != nil </span><span class="cov1" title="1">{
                                return fmt.Errorf("failed to perform shutdown hook %s: %w", hookName, err)
                        }</span>
                        <span class="cov8" title="9">return nil</span>
                })
        }

        <span class="cov6" title="5">done := make(chan error)
        go func() </span><span class="cov6" title="5">{
                done &lt;- errGrp.Wait()
        }</span>()

        <span class="cov6" title="5">select </span>{
        case err := &lt;-done:<span class="cov6" title="5">
                return err</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        }
}

type ShutdownHooksRegistryDeps struct {
        dig.In

        RootLogger *slog.Logger

        // config
        GracefulShutdownTimeout time.Duration `name:"config.gracefulShutdownTimeout"`
}

func NewShutdownHooks(deps ShutdownHooksRegistryDeps) *ShutdownHooks <span class="cov10" title="12">{
        return &amp;ShutdownHooks{
                logger: deps.RootLogger.WithGroup("shutdown"),
                deps:   deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">//go:build !release

package services

import (
        "time"

        "github.com/gemyago/atlacp/internal/diag"
        "github.com/go-faker/faker/v4"
)

type MockNow struct {
        value time.Time
}

var _ TimeProvider = &amp;MockNow{}

func (m *MockNow) SetValue(t time.Time) <span class="cov0" title="0">{
        m.value = t
}</span>

func (m *MockNow) Now() time.Time <span class="cov0" title="0">{
        return m.value
}</span>

func NewMockNow() *MockNow <span class="cov0" title="0">{
        return &amp;MockNow{
                value: time.UnixMilli(faker.RandomUnixTime()),
        }
}</span>

func MockNowValue(p TimeProvider) time.Time <span class="cov0" title="0">{
        mp, ok := p.(*MockNow)
        if !ok </span><span class="cov0" title="0">{
                panic("provided TimeProvider is not a MockNow")</span>
        }
        <span class="cov0" title="0">return mp.value</span>
}

const defaultTestShutdownTimeout = 30 * time.Second

func NewTestShutdownHooks() *ShutdownHooks <span class="cov10" title="6">{
        return NewShutdownHooks(ShutdownHooksRegistryDeps{
                RootLogger:              diag.RootTestLogger(),
                GracefulShutdownTimeout: defaultTestShutdownTimeout,
        })
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package services

import "time"

type TimeProvider interface {
        Now() time.Time
}

type timeProviderFn func() time.Time

func (fn timeProviderFn) Now() time.Time <span class="cov8" title="1">{
        return fn()
}</span>

func NewTimeProvider() TimeProvider <span class="cov8" title="1">{
        return timeProviderFn(time.Now)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">//go:build !release

package mocks

import (
        "testing"
)

// GetMock is a helper function to get a mock from a given instance.
// Note: This should only be used internally in tests.
func GetMock[TOutput any](t *testing.T, input interface{}) TOutput <span class="cov10" title="118">{
        mock, ok := input.(TOutput)
        if !ok </span><span class="cov0" title="0">{
                t.Fatalf("input is not a %T", input)
        }</span>
        <span class="cov10" title="118">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
